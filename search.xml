<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[「PKUWC2018」题解]]></title>
    <url>%2F2019%2F12%2F20%2F%E3%80%8CPKUSC2018%E3%80%8D%E9%A2%98%E8%A7%A3-Solution%2F</url>
    <content type="text"><![CDATA[PKUSC都是神仙题，蒟蒻我根本做不来。 传送门真实排名最大前缀和主斗地星际穿越神仙的游戏PKUSC 真实排名题解这道题目还是比较简单的，就是有几个坑。 对于第$i$个人，有两种情况：他的成绩没有翻倍或者他的成绩翻倍了。 没有翻倍： 那么分数在区间$[\lceil \frac{A_i}{2}\rceil,A_i-1]$内的人的分数不能翻倍，设除$i$外有$x$个人的分数不在这个区间内，那么此时的方案数为$\tbinom{x}{k}$。 翻倍了： 那么分数在区间$[A_i,2\cdot A_i-1]$内的人的分数必须翻倍，设有$x$个人的分数在这个区间内，那么此时的方案数为$\tbinom{n-x}{k-x}$。 还有一种特殊情况需要处理：$A_i=0$，此时的方案数为$\tbinom{n}{k}$。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;typedef long long LL;const int maxn=100005,TT=998244353;int n,K,A[maxn],B[maxn],fac[maxn],inv[maxn];inline int read()&#123; int ret=0,f=1;char ch=getchar(); while(ch&lt;'0'||ch&gt;'9')&#123;if(ch=='-')f=-f;ch=getchar();&#125; while(ch&gt;='0'&amp;&amp;ch&lt;='9')&#123;ret=ret*10+ch-'0';ch=getchar();&#125; return ret*f;&#125;inline int QP(int a,int b)&#123; int ret=1,w=a; while(b) &#123; if(b&amp;1) ret=(LL)ret*w%TT; w=(LL)w*w%TT;b&gt;&gt;=1; &#125; return ret;&#125;inline int C(int n,int m)&#123;if(m&lt;0)return 0;return (LL)fac[n]*inv[m]%TT*inv[n-m]%TT;&#125;inline int Count(int x)&#123;return upper_bound(B,B+n+1,x)-B-1;&#125;int main()&#123; n=read();K=read();fac[0]=1; for(int i=1;i&lt;=n;i++) fac[i]=(LL)fac[i-1]*i%TT; inv[n]=QP(fac[n],TT-2); for(int i=n-1;i&gt;=0;i--) inv[i]=(LL)inv[i+1]*(i+1)%TT; for(int i=1;i&lt;=n;i++) A[i]=B[i]=read(); sort(B+1,B+1+n);B[0]=-1; for(int i=1;i&lt;=n;i++) &#123; if(A[i]==0) &#123; printf("%d\n",C(n,K)); continue; &#125; int cntl=Count(A[i]-1)-Count((A[i]+1)/2-1)+1,ans=C(n-cntl,K); int cntr=Count(2*A[i]-1)-Count(A[i]-1);ans=(ans+C(n-cntr,K-cntr))%TT; printf("%d\n",ans); &#125; return 0;&#125; 最大前缀和题解看到这个数据范围，状压DP肯定是跑不掉了。 一个数列可能有多个最大前缀和，方便起见，我们只关心包含元素个数最大的一个。 设$\sum{i=1}^{j}{a_i}$为最大前缀和，且$j$为所有最大的前缀和中最大的，那么就有$\forall k\in[j+1,n],\sum{i=j+1}^{k}{a_i}&lt;0$。 令$U$为由原序列中所有元素组成的集合，$S$为$U$的一个子集，$F[S]$表示由$S$中所有元素构成的排列中，最大前缀和包含了$S$中所有元素的排列的数量，$G[S]$表示任意一个前缀和都严格小于$0$的排列的数量，$Sum[S]$表示由$S$中所有元素的加和。 如果已经求出了$F$和$G$，那么不难得到答案： ans=\sum_{S\subseteq U}{F[S]\cdot G[U\bigoplus S]}\cdot Sum[S]考虑如何求$F$和$G$，假设已经求得了$F[S]$和$G[S]$，考虑如何转移。 枚举$i\notin S$，然后把$i$放到$S$的排列的最前面，如果如果此时$Sum[S]\geq 0$，那么就有转移： F[S|i]+=F[S]考虑把$i$放在最后面，如果有$a_i+Sum[S]&lt;0$，那么就有转移： G[S|i]+=G[S]由于一个前缀和至少包含一个元素，所以就有初始值$F[S]=[|S|==1]$。 由于当一个前缀和包含了所有元素之后，最大前缀和之后就没有元素了，所以就有初始值$G[0]=1$。 然后这题就解完了，时间复杂度$O(n\cdot 2^n)$。 代码1234567891011121314151617181920212223242526272829303132#include&lt;cstdio&gt;using namespace std;typedef long long LL;const int maxn=25,TT=998244353;int n,a[maxn],sum[(1&lt;&lt;20)+5],F[(1&lt;&lt;20)+5],G[(1&lt;&lt;20)+5],ans;inline void Inc(int&amp; x,int y)&#123;x=(x+y&gt;=TT?x+y-TT:x+y);&#125;int main()&#123; scanf("%d",&amp;n); for(int i=1;i&lt;=n;i++) scanf("%d",&amp;a[i]); for(int S=0;S&lt;(1&lt;&lt;n);S++) for(int j=1;j&lt;=n;j++) if(S&amp;(1&lt;&lt;(j-1))) &#123;sum[S]=sum[S-(1&lt;&lt;(j-1))]+a[j];break;&#125; G[0]=1; for(int i=1;i&lt;=n;i++) F[1&lt;&lt;(i-1)]=1; for(int S=0;S&lt;(1&lt;&lt;n);S++) &#123; for(int j=1;j&lt;=n;j++) &#123; if(!(S&amp;(1&lt;&lt;(j-1)))) &#123; if(sum[S]&gt;=0) Inc(F[S|(1&lt;&lt;(j-1))],F[S]); if(sum[S]+a[j]&lt;0) Inc(G[S|(1&lt;&lt;(j-1))],G[S]); &#125; &#125; &#125; for(int S=0;S&lt;(1&lt;&lt;n);S++) Inc(ans,(LL)F[S]*G[(1&lt;&lt;n)-1-S]%TT*(sum[S]+TT)%TT); printf("%d\n",ans); return 0;&#125; 主斗地题解大模拟。 仔细阅读题目中的规则，不难发现，在这题中很多打法是无用的，顺子、对子、双顺、三张、三顺全都可以拆成单牌来打；飞机带翅膀拆成三带一和三带二打，并且还少了要求数码不同的限制。这样我们需要考虑的出牌方式就只有三带一、三带二、四带二和打单牌了，这对一道大模拟来说真是莫大的好消息。 并且良心出题人把3去掉了，因此吉老师的牌的可能的种类就大大减少了，大概是$10^6$级别。 所以可以暴枚吉老师的牌，然后再考虑，对于一副吉老师的牌，是否存在合法的打法。 可以一开始先确定三带一加上三带二的数量和四带二的数量，最后再枚举三带一的数量以及考虑怎么带（因为对于一个玩家来说，我们只关心三带一的数量和三带二的数量，而并不关心具体是哪些三张牌带了一张，哪些三张牌带了两张）。 对于吉老师，肯定是尽量带大的散牌，对于XX网友，肯定是尽量带小的牌。并且需要先确定带哪些对子，再确定带哪些单牌。 具体实现参加代码。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113#include&lt;cstdio&gt;#include&lt;cctype&gt;#include&lt;cstring&gt;using namespace std;const int maxn=20;const char C[maxn]="3456789TJQKA2wW";int XX[maxn],lft[maxn],Xcnt[maxn],ans,Jcnt[maxn];inline int Get()&#123; char ch=getchar(); while(!isalpha(ch)&amp;&amp;!isdigit(ch)) ch=getchar(); for(int i=1;;i++) if(ch==C[i]) return i; return -1;&#125;inline bool CheckB(int dy,int dye)&#123; static int tepX[maxn],tepJ[maxn]; for(int i=0;i&lt;=dye;i++) //枚举带一和带二的数量 &#123; memcpy(tepX,Xcnt,sizeof(tepX)); memcpy(tepJ,Jcnt,sizeof(tepJ)); int bri=dy+i,pai=dye-i; for(int j=14;j;j--) //吉老师带大牌 &#123; while(pai&amp;&amp;tepJ[j]&gt;=2)&#123;tepJ[j]-=2;pai--;&#125; while(bri&amp;&amp;tepJ[j]&gt;=1)&#123;tepJ[j]-=1;bri--;&#125; &#125; if(bri&gt;0||pai&gt;0) continue; bri=dy+i;pai=dye-i; for(int j=1;j&lt;=14;j++) //XX网友带小牌 &#123; while(pai&amp;&amp;tepX[j]&gt;=2)&#123;tepX[j]-=2;pai--;&#125; while(bri&amp;&amp;tepX[j]&gt;=1)&#123;tepX[j]-=1;bri--;&#125; &#125; if(bri&gt;0||pai&gt;0) continue; bool suc=true; for(int j=1,p=1;j&lt;=14&amp;&amp;suc;j++) //剩下的牌一定要严格的一张压一张 &#123; while(tepJ[j]--) &#123; while(p&lt;=14&amp;&amp;(p&lt;=j||!tepX[p])) p++; if(p&gt;14)&#123;suc=false;break;&#125; tepX[p]--; &#125; &#125; if(suc) return true; &#125; return false;&#125;inline bool check(int s,int sa,int si,int dy,int dye) //暴枚三张和四张的打法&#123; if(s&gt;14) &#123; if(sa||si) return false; //两人打的三张和四张的数量必须一样 return CheckB(dy,dye); &#125; if(Jcnt[s]&gt;=3) &#123; Jcnt[s]-=3; bool ret=check(s+1,sa+1,si,dy,dye+1); Jcnt[s]+=3; if(ret) return true; &#125; if(Jcnt[s]&gt;=4) &#123; Jcnt[s]-=4; bool ret=check(s+1,sa,si+1,dy+2,dye); Jcnt[s]+=4; if(ret) return true; &#125; if(Xcnt[s]&gt;=3&amp;&amp;sa) //XX网友的牌要压着吉老师打 &#123; Xcnt[s]-=3; bool ret=check(s+1,sa-1,si,dy,dye); Xcnt[s]+=3; if(ret) return true; &#125; if(Xcnt[s]&gt;=4&amp;&amp;si) &#123; Xcnt[s]-=4; bool ret=check(s+1,sa,si-1,dy,dye); Xcnt[s]+=4; if(ret) return true; &#125; return check(s+1,sa,si,dy,dye);&#125;void DFS(int step,int s) //暴枚吉老师的牌&#123; if(step&gt;17) &#123; if(check(1,0,0,0,0)) ans++; return; &#125; for(int i=s;i&lt;=14;i++) &#123; if(lft[i]) &#123; lft[i]--; Jcnt[i]++; DFS(step+1,i); Jcnt[i]--; lft[i]++; &#125; &#125;&#125;int main()&#123; for(int i=1;i&lt;=12;i++) lft[i]=4; lft[13]=lft[14]=1; for(int i=1;i&lt;=17;i++)&#123;XX[i]=Get();lft[XX[i]]--;Xcnt[XX[i]]++;&#125; DFS(1,1); printf("%d\n",ans); return 0;&#125; 星际穿越题解先考虑这个图有什么性质，以及最短路径有什么特点。 不难发现，肯定存在一条最短路径，向右跳了最多一次，而且是在起点向右跳。 令$tl[i]=\min_{j=i}^{n}l[j]$，如果$i$不是起点，那么区间$[tl[i],i-1]$中的所有点均可以看作可以由点$i$一次穿越到达（实际上可能并未经过点$i$，但是穿越次数和看为从$i$一次穿越到达一样），这样转化之后，每次都向左穿越到此意义下最靠左的位置肯定可以得到一条最短路径（起点除外）。 考虑倍增，设$F[i][j]$表示从$i$开始向左穿越$2^j$次能到达的最靠左的位置，$G[i][j]$表示从$i$出发到区间$[F[i][j],i]$中所有位置的最短路径长度和。 对于$F[i][j]$和$G[i][j]$，有： F[i][0]=tl[i];\\ G[i][0]=i-tl[i];\\ F[i][j]=F[F[i][j-1]][j-1];\\ G[i][j]=G[i][j-1]+(F[i][j-1]-F[i][j])*2^{j-1}+G[F[i][j-1]][j-1];\\然后对于每一个询问，差分一下然后倍增即可求解出答案。倍增的时候每次跳跃记得预先加上前面那部分的贡献。注意起点特殊处理。 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;typedef long long LL;const int maxn=300005;int n,q,l[maxn],tl[maxn];LL F[maxn][20],G[maxn][20];inline int read()&#123; int ret=0,f=1;char ch=getchar(); while(ch&lt;'0'||ch&gt;'9')&#123;if(ch=='-')f=-f;ch=getchar();&#125; while(ch&gt;='0'&amp;&amp;ch&lt;='9')&#123;ret=ret*10+ch-'0';ch=getchar();&#125; return ret*f;&#125;inline LL gcd(LL x,LL y)&#123;return !y?x:gcd(y,x%y);&#125;inline LL Calc(int X,int L)&#123; LL ret=0;int t=X; for(int i=18;i&gt;=0;i--) if(F[t][i]&gt;=L) &#123;ret+=G[t][i];t=F[t][i];ret+=(t-L)*(1&lt;&lt;i);&#125; return ret+t-L;&#125;inline LL Solve(int X,int L)&#123; if(L&gt;=l[X]) return X-L; return Calc(l[X],L)+X-L;&#125;int main()&#123; n=read(); for(int i=2;i&lt;=n;i++) l[i]=read(); tl[n]=l[n]; for(int i=n-1;i;i--) tl[i]=min(tl[i+1],l[i]); q=read(); for(int i=1;i&lt;=n;i++) &#123; F[i][0]=tl[i]; G[i][0]=i-tl[i]; for(int j=1;j&lt;=18;j++) &#123; F[i][j]=F[F[i][j-1]][j-1]; G[i][j]=G[i][j-1]+((LL)F[i][j-1]-F[i][j])*(1&lt;&lt;(j-1))+G[F[i][j-1]][j-1]; &#125; &#125; while(q--) &#123; int L=read(),R=read(),X=read(); LL u=Solve(X,L)-Solve(X,R+1),d=R-L+1,g=gcd(u,d); u/=g;d/=g;printf("%lld/%lld\n",u,d); &#125; return 0;&#125; 神仙的游戏题解神仙的游戏蒟蒻我是根本玩不来。 首先需要考虑一下这个题目有什么性质： 自己画几个图之后不难发现，对于一个长度为$len$的前缀，如果他是一个border，那么这个$n-len$必定为这个字符串循环节的长度，并且反过来也成立。 因为?可以随便取，这里就不管它了。我们只需要考虑哪些情况下的，长度为len的前缀不是border。 对于一个$0$，设它的下标为$i$，对于一个$1$，设它的下标为$j$，那么就有： \forall len,(n-len)|(|i-j|)长度为$len$的前缀不是一个border（中间的竖线表示整除）。 考虑构造两个多项式： F(x)=\sum_{i=1}^{n}{[S_i=='1']x^i}\\ G(x)=\sum_{i=1}^{n}{[S_{n-i+1}=='0']x^i}\\然后用FFT或者NTT将两个多项式卷乘起来，设卷积的结果为$H()$。 此时如果存在一对01，且它们的下标之差为$i$，那么就等价于$[x^{n+1-i}]H(x)+[x^{n+1+i}]H(x)&gt;0$。 此时就可以判断一个长度为$len$是否是一个border了。 然后这题就解决了，复杂度$O(n\log n)$。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;typedef long long LL;const int maxn=500005,maxl=(1&lt;&lt;20)+5,TT=998244353;int n,f[maxn],A[maxl],B[maxl],r[maxl];char S[maxn];LL ans;inline int QP(int a,int b)&#123; int ret=1,w=a; while(b) &#123; if(b&amp;1) ret=(LL)ret*w%TT; w=(LL)w*w%TT;b&gt;&gt;=1; &#125; return ret;&#125;inline void NTT(int* A,int limit,int typ)&#123; for(int i=0;i&lt;limit;i++) if(i&lt;r[i]) swap(A[i],A[r[i]]); for(int mid=1;mid&lt;limit;mid&lt;&lt;=1) &#123; int gn=QP(3,(TT-1)/(mid&lt;&lt;1)); if(typ&lt;0) gn=QP(gn,TT-2); for(int j=0;j&lt;limit;j+=mid&lt;&lt;1) &#123; int g=1; for(int k=0;k&lt;mid;k++,g=(LL)g*gn%TT) &#123; int x=A[j+k],y=(LL)g*A[j+k+mid]%TT; A[j+k]=(x+y)%TT; A[j+k+mid]=(x-y+TT)%TT; &#125; &#125; &#125; if(typ&lt;0) &#123; int inv=QP(limit,TT-2); for(int i=0;i&lt;limit;i++) A[i]=(LL)A[i]*inv%TT; &#125;&#125;inline void Solve()&#123; memset(A,0,sizeof(A)); memset(B,0,sizeof(B)); for(int i=1;i&lt;=n;i++) &#123; A[i]=(S[i]-'0'==1); B[i]=(S[n-i+1]-'0'==0); &#125; int limit=1,l=0; while(limit&lt;=2*n)&#123;limit&lt;&lt;=1;l++;&#125; for(int i=0;i&lt;limit;i++) r[i]=(r[i&gt;&gt;1]&gt;&gt;1)|((i&amp;1)&lt;&lt;(l-1)); NTT(A,limit,1);NTT(B,limit,1); for(int i=0;i&lt;limit;i++) A[i]=(LL)A[i]*B[i]%TT; NTT(A,limit,-1); for(int i=1;i&lt;n;i++) if(A[n+1+i]||A[n+1-i]) for(int j=1;j*j&lt;=i;j++) if(i%j==0) f[n-i/j]=f[n-j]=0;&#125;int main()&#123; gets(S+1);n=strlen(S+1); for(int i=1;i&lt;=n;i++) f[i]=1; Solve(); for(int i=1;i&lt;=n;i++) ans=ans^((LL)f[i]*i*i); printf("%lld\n",ans); return 0;&#125; PKUSC题解计算几何，好讨厌啊。 虽然题面里保证了精度不会卡得很严，比较友好，但是作为一道计算几何，精度问题还是很讨厌的，特别是对于我这种蒟蒻。 由于期望具有线性性，所以可以分开计算每个敌人的贡献，最后再累加起来。 一个敌人的贡献等于多边形匀速转过一圈时，敌人在多边形内的时间与总时间的比值。 考虑如何判断一个点是否在一个可能是凹多边形的多边形内部，我这里用的是引射线法：从需要判断的点引出一条射线，计算这条射线与多边形的边的相交次数。如果相交了奇数次，那么就在多边形内部；如果相交了偶数次，那么就在多边形外部。 然后对于每一个点，计算出它与多边形的每一条边是否可能相交，以及相交时转过的角度。注意在本题中，转多边形和转点本质上是一样的，计算交点的话解一个一元二次方程即可。我们称转过的角度$\alpha$为关键角度当前仅当在转过$\alpha$之后，该点与多边形的某一条边相交。 预处理出所有关键角度并排序之后（注意去重），不难发现当转过角度在某两个相邻的关键角度之间时，该点在多边形的内外情况相同。 所以对于每一个点，我们需要计算出他的所有关键角度，并确定旋转角度在某一个区间内时该点是在多边形内部还是外部，然后累加计算答案。时间复杂度为$O(nm^2)$。 代码注意由于本蒟蒻很菜，并不怎么会处理计算几何里的精度问题，所以下面的代码仅保证基本思路正确且能通过洛谷、BZOJ以及LOJ的测试数据，但是不保证不存在数据能通过精度问题把代码卡掉。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;algorithm&gt;using namespace std;const int maxn=205,maxm=505;const double eps=1e-9,Pi=acos(-1);int n,m;double ans;inline int read()&#123; int ret=0,f=1;char ch=getchar(); while(ch&lt;'0'||ch&gt;'9')&#123;if(ch=='-')f=-f;ch=getchar();&#125; while(ch&gt;='0'&amp;&amp;ch&lt;='9')&#123;ret=ret*10+ch-'0';ch=getchar();&#125; return ret*f;&#125;inline double ABS(double x)&#123;return x&lt;0?-x:x;&#125;struct Point&#123; double x,y,r; Point(double a=0,double b=0)&#123;x=a;y=b;&#125; inline double Angle() //计算一个点的极角大小 &#123; double t=asin(y/sqrt(x*x+y*y)); if(t&gt;0) &#123; if(x&gt;0&amp;&amp;y&gt;0) return t; return Pi-t; &#125; if(x&lt;0&amp;&amp;y&lt;0) return Pi-t; return 2*Pi+t; &#125;&#125;P[maxm],E[maxn];struct Line&#123; double k,b,x;bool inf;Point A,B; inline void Init(Point p1,Point p2) //根据两个端点确定解析式 &#123; A=p1;B=p2; if(ABS(p1.x-p2.x)&lt;eps)&#123;inf=true;x=p1.x;k=b=0;&#125; //线是竖着的 else&#123;k=(p2.y-p1.y)/(p2.x-p1.x);b=p1.y-k*p1.x;inf=false;x=0;&#125; &#125;&#125;L[maxm];inline bool AtEdge(Point p,Line L,bool typ=-1) //判断一个点是否在一条线段上&#123; double eps=1e-6; if(L.inf) &#123; if(ABS(p.x-L.x)&lt;eps&amp;&amp;min(L.A.y,L.B.y)-eps&lt;=p.y&amp;&amp;p.y&lt;=max(L.A.y,L.B.y)+eps) return true; &#125; else &#123; if(ABS(p.y-L.k*p.x-L.b)&lt;eps&amp;&amp;min(L.A.x,L.B.x)-eps&lt;=p.x&amp;&amp;p.x&lt;=max(L.A.x,L.B.x)+eps) return true; &#125; return false;&#125;inline bool check(Point p)&#123; for(int i=1;i&lt;=m;i++) if(AtEdge(p,L[i],1)) return true; return false;&#125;inline bool InOrOut(Point p) //判断一个点是否在多边形内部&#123; while(true) &#123; double k=(double)rand()/RAND_MAX;//ran一个射线的斜率，尽量避免与线段的端点相交 if(k&lt;1e-6) continue; //防止斜率过小或者过大带来精度问题 if(rand()&amp;1) k=1/k; double b=p.y-p.x*k; bool fal=false; for(int i=1;i&lt;=m;i++) if(ABS(L[i].A.x*k+b-L[i].A.y)&lt;eps||ABS(L[i].B.x*k+b-L[i].B.y)&lt;eps) &#123;fal=true;break;&#125; if(fal) continue; int cnt=0; for(int i=1;i&lt;=m;i++) &#123; Point cp; if(L[i].inf) &#123; cp.x=L[i].x;cp.y=cp.x*k+b; if(p.x-eps&lt;=cp.x&amp;&amp;AtEdge(cp,L[i])) cnt++; &#125; else &#123; cp.x=(L[i].b-b)/(k-L[i].k);cp.y=k*cp.x+b; if(p.x-eps&lt;=cp.x&amp;&amp;AtEdge(cp,L[i])) cnt++; &#125; &#125; return cnt&amp;1; &#125;&#125;inline void Solve(Point p) //计算每个点的贡献&#123; static double an[maxm*2],ap,aq[maxn*2]; int len=0,cnt=0;ap=p.Angle(); for(int i=1;i&lt;=m;i++) &#123; Point cp1,cp2; if(L[i].inf) &#123; double t=p.r*p.r-L[i].x*L[i].x; if(t&lt;0) continue; cp1.x=cp2.x=L[i].x; cp1.y=sqrt(t);cp2.y=-sqrt(t); &#125; else &#123; double a=L[i].k*L[i].k+1,b=2*L[i].k*L[i].b,c=L[i].b*L[i].b-p.r*p.r,delta=b*b-4*a*c; if(delta+eps&lt;0) continue; if(delta&lt;0) delta=0; delta=sqrt(delta); cp1.x=(-b+delta)/(2*a);cp1.y=cp1.x*L[i].k+L[i].b; cp2.x=(-b-delta)/(2*a);cp2.y=cp2.x*L[i].k+L[i].b; &#125; if(AtEdge(cp1,L[i])) &#123; an[++len]=cp1.Angle()-ap; if(an[len]&lt;0) an[len]+=2*Pi; &#125; if(AtEdge(cp2,L[i])) &#123; an[++len]=cp2.Angle()-ap; if(an[len]&lt;0) an[len]+=2*Pi; &#125; &#125; sort(an+1,an+1+len); an[++len]=2*Pi; for(int i=1;i&lt;=len;) &#123; int j=i; while(ABS(an[j+1]-an[i])&lt;eps&amp;&amp;j&lt;len) j++; aq[++cnt]=an[i];i=j+1; &#125; for(int i=1;i&lt;=cnt;i++) &#123; double ant=ap+aq[i]-1e-6;Point tp; tp.x=p.r*cos(ant);tp.y=p.r*sin(ant); ans+=InOrOut(tp)*(aq[i]-aq[i-1])/(2*Pi); &#125;&#125;int main()&#123; n=read();m=read(); for(int i=1;i&lt;=n;i++) &#123; E[i].x=read(); E[i].y=read(); E[i].r=sqrt(E[i].x*E[i].x+E[i].y*E[i].y); &#125; for(int i=1;i&lt;=m;i++) &#123; P[i].x=read(); P[i].y=read(); &#125; for(int i=1;i&lt;m;i++) L[i].Init(P[i],P[i+1]); L[m].Init(P[m],P[1]); for(int i=1;i&lt;=n;i++) &#123; if(E[i].r&lt;eps) //敌人在原点上，转不动 &#123; if(!check(E[i])) ans+=InOrOut(E[i]); swap(E[i],E[n]);n--;i--; &#125; &#125; for(int i=1;i&lt;=n;i++) Solve(E[i]); printf("%.5lf\n",ans); return 0;&#125;]]></content>
      <categories>
        <category>PKUSC</category>
      </categories>
      <tags>
        <tag>PKUSC</tag>
        <tag>PKUSC2018</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「PKUWC2018」题解]]></title>
    <url>%2F2019%2F12%2F19%2F%E3%80%8CPKUWC2018%E3%80%8D%E9%A2%98%E8%A7%A3-Solution%2F</url>
    <content type="text"><![CDATA[PKUWC都是神仙题，蒟蒻我根本做不来。 传送门MinimaxSlay the Spire随机算法随机游走猎人杀斗地主 Minimax题解答案的表达式看上去极其诡异，但是观察过后，不难发现，只要求出每种权值出现的概率，问题就迎刃而解了（废话）。 首先需要抓住题目中保证的两个性质，一个是权值互不相同，另一个是有儿子的节点最多只有两个儿子。 设第$i$个节点出现权值$j$的概率为$g_{i,j}$，那么由于权值互不相同，左右儿子中最多只有一个节点可能出现权值$j$。 设左儿子的编号为$L$，右儿子为$R$，如果左儿子可能出现权值$j$，那么就有： g_{i,j}=g_{L,j}\cdot(\sum_{k=1}^{j-1}{g_{R,k}\cdot p_i}+\sum_{k=j+1}^{n}{g_{R,k}\cdot(1-p_i))}右儿子可能出现权值$j$的情况同理。 考虑这个转移的过程，相当于权值$j$出现的概率被乘上了 (\sum_{k=1}^{j-1}{g_{R,k}\cdot p_i}+\sum_{k=j+1}^{n}{g_{R,k}\cdot(1-p_i))}仔细观察这个式子，里面是一个前缀和和一个后缀和，所以可以通过对支持乘法操作的线段树进行合并操作来实现转移，不断向上合并之后就可以求出根节点每种权值出现的概率了。具体实现参见代码（感觉还是挺妙的）。 时间复杂度和空间复杂度都是$O(n\log n)$。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;typedef long long LL;const int maxn=300005,TT=998244353,inv=796898467;int n,P[maxn],W[maxn],num[maxn],tot,lnk[maxn],son[maxn],nxt[maxn],ans;inline int read()&#123; int ret=0,f=1;char ch=getchar(); while(ch&lt;'0'||ch&gt;'9')&#123;if(ch=='-')f=-f;ch=getchar();&#125; while(ch&gt;='0'&amp;&amp;ch&lt;='9')&#123;ret=ret*10+ch-'0';ch=getchar();&#125; return ret*f;&#125;inline void add_e(int x,int y)&#123;tot++;son[tot]=y;nxt[tot]=lnk[x];lnk[x]=tot;&#125;struct SegmentTree&#123; int tot,R[maxn]; inline int New()&#123;tot++;Tree[tot].Tag=1;return tot;&#125; struct Node&#123;int Sum,Tag,L,R;&#125;Tree[maxn*40]; inline void PushUp(int rt)&#123;Tree[rt].Sum=(Tree[Tree[rt].L].Sum+Tree[Tree[rt].R].Sum)%TT;&#125; inline void PushDown(int rt) &#123; Tree[Tree[rt].L].Sum=(LL)Tree[Tree[rt].L].Sum*Tree[rt].Tag%TT;Tree[Tree[rt].L].Tag=(LL)Tree[Tree[rt].L].Tag*Tree[rt].Tag%TT; Tree[Tree[rt].R].Sum=(LL)Tree[Tree[rt].R].Sum*Tree[rt].Tag%TT;Tree[Tree[rt].R].Tag=(LL)Tree[Tree[rt].R].Tag*Tree[rt].Tag%TT; Tree[rt].Tag=1; &#125; inline int Merge(int rt1,int rt2,int P,int Pre1=0,int Suf1=0,int Pre2=0,int Suf2=0) &#123; if(!rt1&amp;&amp;!rt2) return 0; PushDown(rt1);PushDown(rt2); int rt=New(); if(!rt1) &#123; int mul=((LL)P*Pre1+(LL)(1-P+TT)*Suf1)%TT; Tree[rt]=Tree[rt2]; Tree[rt].Sum=(LL)Tree[rt2].Sum*mul%TT; Tree[rt].Tag=(LL)Tree[rt2].Tag*mul%TT; &#125; else if(!rt2) &#123; int mul=((LL)P*Pre2+(LL)(1-P+TT)*Suf2)%TT; Tree[rt]=Tree[rt1]; Tree[rt].Sum=(LL)Tree[rt1].Sum*mul%TT; Tree[rt].Tag=(LL)Tree[rt1].Tag*mul%TT; &#125; else &#123; Tree[rt].L=Merge(Tree[rt1].L,Tree[rt2].L,P,Pre1,(Suf1+Tree[Tree[rt1].R].Sum)%TT,Pre2,(Suf2+Tree[Tree[rt2].R].Sum)%TT); Tree[rt].R=Merge(Tree[rt1].R,Tree[rt2].R,P,(Pre1+Tree[Tree[rt1].L].Sum)%TT,Suf1,(Pre2+Tree[Tree[rt2].L].Sum)%TT,Suf2); PushUp(rt); &#125; return rt; &#125; inline int NewTree(int P,int L=1,int R=num[0]) &#123; int rt=New(); if(L==R)&#123;Tree[rt].Sum=1;return rt;&#125; int M=(L+R)&gt;&gt;1; if(P&lt;=M) Tree[rt].L=NewTree(P,L,M); else Tree[rt].R=NewTree(P,M+1,R); PushUp(rt); return rt; &#125;&#125;ST;void DFS(int now)&#123; if(!lnk[now])&#123;ST.R[now]=ST.NewTree(W[now]);return;&#125; for(int i=lnk[now];i;i=nxt[i]) &#123; DFS(son[i]); if(!ST.R[now]) ST.R[now]=ST.R[son[i]]; else ST.R[now]=ST.Merge(ST.R[now],ST.R[son[i]],P[now]); &#125;&#125;void Solve(int L=1,int R=num[0],int rt=ST.R[1])&#123; if(L==R)&#123;ans=(ans+(LL)L*num[L]%TT*ST.Tree[rt].Sum%TT*ST.Tree[rt].Sum%TT)%TT;return;&#125; int M=(L+R)&gt;&gt;1; ST.PushDown(rt); Solve(L,M,ST.Tree[rt].L); Solve(M+1,R,ST.Tree[rt].R);&#125;int main()&#123; n=read(); for(int i=1;i&lt;=n;i++) &#123; int fi=read(); if(fi) add_e(fi,i); &#125; for(int i=1;i&lt;=n;i++) &#123; if(lnk[i]) P[i]=(LL)read()*inv%TT; else W[i]=num[++num[0]]=read(); &#125; sort(num+1,num+1+num[0]); for(int i=1;i&lt;=n;i++) if(!lnk[i]) W[i]=lower_bound(num+1,num+1+num[0],W[i])-num; DFS(1);Solve(); printf("%d\n",ans); return 0;&#125; Slay the Spire题解首先考虑一下，在抽到了$m$张牌之后，怎样打才比较优。 不难发现，肯定挑权值大的牌打，所有要打的攻击牌肯定都是在要打的强化牌打完之后才打的。 并且，由于强化牌上的数字最少为$2$，所以如果抽到的强化牌数量够多的话，一定会打出权值前$k-1$大的强化牌，然后再打出一张权值最大的攻击牌；如果抽到的强化牌数量比较少，那肯定会全部打出。 首先对两种牌的权值从大到小排序。 设权值第$i$大强化牌的权值为$p_i$，权值第$i$大的攻击牌的权值为$w_i$。 考虑两个DP： $F[i][j][0/1]$：表示考虑了前$i$张强化牌，打出了$j$张，第$i$张强化牌没打/打了时所有方案强化牌的乘积的和。 $G[i][j][0/1]$：表示考虑了前$i$张攻击牌，打出了$j$张，第$i$张攻击牌没打/打了时所有方案攻击牌的加和的和。 不难推出转移方程： F[i][j][0]=F[i-1][j][0]+F[i-1][j][1]\\ F[i][j][1]=(F[i-1][j-1][0]+F[i-1][j-1][1])\cdot p[i]\\ G[i][j][0]=G[i-1][j][0]+G[i-1][j][1]\\ G[i][j][1]=G[i-1][j-1][0]+G[i-1][j-1][1]+\tbinom{i-1}{j-1}\cdot w[i]上述两个数组处理好之后，可以开始考虑计算答案了。 首先可以枚举一下抽中的牌中强化牌的数量，设共$i$张，分两种情况考虑： $i&lt;k$，那么这种情况对答案的贡献为: (\sum_{j=1}^{n}{F[j][i][1]})\cdot(\sum_{j=1}^{n}{G[j][k-i]\cdot \tbinom{n-j}{m-k}}) $i\geq k$，此时的贡献为： (\sum_{j=1}^{n}{F[j][k-1][1]\cdot\tbinom{n-j}{i-k+1}})\cdot(\sum_{j=1}^{n}{G[j][1]\cdot \tbinom{n-j}{m-i-1}}) 累加起来即可得到答案。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;typedef long long LL;const int maxn=3005,TT=998244353;int T,n,m,k,C[maxn][maxn],w[maxn],p[maxn],F[maxn][maxn][2],G[maxn][maxn][2],ans;inline int read()&#123; int ret=0,f=1;char ch=getchar(); while(ch&lt;'0'||ch&gt;'9')&#123;if(ch=='-')f=-f;ch=getchar();&#125; while(ch&gt;='0'&amp;&amp;ch&lt;='9')&#123;ret=ret*10+ch-'0';ch=getchar();&#125; return ret*f;&#125;int main()&#123; for(int i=0;i&lt;=3000;i++) &#123; for(int j=0;j&lt;=i;j++) &#123; if(j==0) C[i][j]=1; else C[i][j]=(C[i-1][j-1]+C[i-1][j])%TT; &#125; &#125; T=read(); while(T--) &#123; n=read();m=read();k=read();ans=0; for(int i=0;i&lt;=n;i++) F[i][0][0]=1; for(int i=1;i&lt;=n;i++) p[i]=read(); for(int i=1;i&lt;=n;i++) w[i]=read(); sort(w+1,w+1+n);reverse(w+1,w+1+n); sort(p+1,p+1+n);reverse(p+1,p+1+n); for(int i=1;i&lt;=n;i++) &#123; for(int j=1;j&lt;=i;j++) &#123; F[i][j][0]=F[i-1][j][0]+F[i-1][j][1]; if(F[i][j][0]&gt;=TT) F[i][j][0]-=TT; F[i][j][1]=((LL)F[i-1][j-1][0]+F[i-1][j-1][1])*p[i]%TT; G[i][j][0]=G[i-1][j][0]+G[i-1][j][1]; if(G[i][j][0]&gt;=TT) G[i][j][0]-=TT; G[i][j][1]=((LL)G[i-1][j-1][0]+G[i-1][j-1][1]+(LL)C[i-1][j-1]*w[i])%TT; &#125; &#125; for(int i=0;i&lt;=m&amp;&amp;i&lt;=n;i++) &#123; int sum1=0,sum2=0; if(i&lt;k) &#123; for(int j=1;j&lt;=n;j++) &#123; sum1+=F[j][i][1];if(sum1&gt;=TT) sum1-=TT; sum2=(sum2+(LL)G[j][k-i][1]*C[n-j][m-k])%TT; &#125; &#125; else &#123; for(int j=1;j&lt;=n;j++) &#123; sum1=(sum1+(LL)F[j][k-1][1]*C[n-j][i-k+1])%TT; sum2=(sum2+(LL)G[j][1][1]*C[n-j][m-i-1])%TT; &#125; &#125; if(k==1||i==0) sum1=C[n][i]; ans=(ans+(LL)sum1*sum2)%TT; &#125; printf("%d\n",ans); &#125; return 0;&#125; 随机算法题解排列的总数很好求，考虑有多少种排列能求出正确的答案。 数据范围很小，考虑一个状压DP： $F[S][i]$表示当前的排列中已经包含了集合$S$中的所有元素，且最大独立的大小为$i$的方案数。 枚举下一个不在$S$中的节点$j$，使节点$j$加入到最大独立集中来。设$j$以及与$j$距离为$1$的点构成的集合为$T$，那么节点$j$需要放在排列中最靠前的一个空位，剩下的节点可以随意放排列中剩余的空位上。所以就有转移： F[S|T][i+1]+=F[S][i]*A_{n-|S|-1}^{|T-(S\bigcap T)|-1}初始有$F[0][0]=1$，最后的答案为$\frac{F[U][mx]}{n!}$，其中$U$为全集，$mx$为最大独立集的大小。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include&lt;cstdio&gt;using namespace std;typedef long long LL;const int maxn=25,TT=998244353;int n,m,lnk[maxn],A[maxn][maxn],cnt[(1&lt;&lt;20)+5],F[(1&lt;&lt;20)+5][21],mx,ifn,ans;bool vis[(1&lt;&lt;20)+5][21];inline int read()&#123; int ret=0,f=1;char ch=getchar(); while(ch&lt;'0'||ch&gt;'9')&#123;if(ch=='-')f=-f;ch=getchar();&#125; while(ch&gt;='0'&amp;&amp;ch&lt;='9')&#123;ret=ret*10+ch-'0';ch=getchar();&#125; return ret*f;&#125;inline int QP(int a,int b)&#123; int ret=1,w=a; while(b) &#123; if(b&amp;1) ret=(LL)ret*w%TT; w=(LL)w*w%TT;b&gt;&gt;=1; &#125; return ret;&#125;inline void Inc(int&amp; x,int y)&#123;x=(x+y&gt;=TT?x+y-TT:x+y);&#125;int main()&#123; n=read();m=read();ifn=1; for(int i=1;i&lt;=n;i++) ifn=(LL)ifn*i%TT; ifn=QP(ifn,TT-2); for(int i=1;i&lt;=n;i++) lnk[i]|=1&lt;&lt;(i-1); for(int i=1;i&lt;=m;i++) &#123; int a=read(),b=read(); lnk[a]|=(1&lt;&lt;(b-1)); lnk[b]|=(1&lt;&lt;(a-1)); &#125; for(int i=0;i&lt;=20;i++) &#123; for(int j=0;j&lt;=i;j++) &#123; if(j==0) A[i][j]=1; else A[i][j]=(A[i-1][j]+(LL)A[i-1][j-1]*j)%TT; &#125; &#125; for(int i=1;i&lt;(1&lt;&lt;n);i++) cnt[i]=cnt[i&gt;&gt;1]+(i&amp;1); F[0][0]=vis[0][0]=1; for(int i=0;i&lt;n;i++) &#123; for(int S=0;S&lt;(1&lt;&lt;n);S++) &#123; for(int j=1;j&lt;=n;j++) &#123; if(vis[S][i]&amp;&amp;!(S&amp;(1&lt;&lt;(j-1)))) &#123; Inc(F[S|lnk[j]][i+1],(LL)F[S][i]*A[n-cnt[S]-1][cnt[lnk[j]-(lnk[j]&amp;S)]-1]%TT); vis[S|lnk[j]][i+1]=true; if(i+1&gt;mx) mx=i+1; &#125; &#125; &#125; &#125; ans=(LL)F[(1&lt;&lt;n)-1][mx]*ifn%TT; printf("%d\n",ans); return 0;&#125; 随机游走题解题目中要求经过$S$中所有点的期望步数，即$E(max(S))$，并不好搞，考虑到数据范围非常小，可以使用MinMax容斥，即$E(\max(S))=\sum_{T\subseteq S{}}(-1)^{|T|+1}E(\min(T))$，所以问题就转化为了求从起点出发，经过$T$中任意一个节点的期望步数。 首先可以暴力枚举集合$T$，然后考虑一个树形DP： $F_i$表示从节点$i$出发，经过集合$T$中任意一个节点的期望步数，比较显然的转移是： 若$i\notin T$: F[i]=1+\frac{1}{deg[i]}\sum_{(i,j)\in E}{F[j]} $i\in T$ F[i]=0考虑第一种情况，这个式子不是很好看，考虑分离儿子与父亲的情况分别考虑。 设$F[i]=K[i]\cdot F[fa[i]]+B[i]$，那么就有： F[i]=1+\frac{1}{deg[i]}(F[fa[i]]+\sum_{j\in son_i}{F[j]})\\ F[i]=1+\frac{1}{deg[i]}(F[fa[i]]+\sum_{j\in son_i}{K[j]\cdot F[i]+B[j]})\\ F[i]=1+\frac{1}{deg[i]}(F[fa[i]]+F[i]\cdot \sum_{j\in son_i}{K[j]}+\sum_{j\in son_i}{B[j]})\\ F[i]=1+\frac{1}{deg[i]}(F[fa[i]]+F[i]\cdot Sum{K[i]}+SumB[i])\\ deg[i]\cdot F[i]=deg[i]+F[fa[i]]+F[i]\cdot Sum{K[i]}+SumB[i]\\ (deg[i]-SumK[i])\cdot F[i]=F[fa[i]]+deg[i]+SumB[i]\\ F[i]=\frac{1}{deg[i]-SumK[i]}F[fa[i]]+\frac{deg[i]+SumB[i]}{deg[i]-SumK[i]}其中$SumK[i]$表示$\sum_{j\in son[i]}{K[j]}$，$SumB[i]$同理。 所以就有： K[i]=\frac{1}{deg[i]-SumK[i]}\\ B[i]=\frac{deg[i]+SumB[i]}{deg[i]-SumK[i]}这两个数的取值与$i$的父节点无关，只与子节点有关。 对于第二中情况，显然有$K[i]=B[i]=F[i]=0$。 所以就可以通过一趟$DFS$来求出每个节点的$K[i]$与$B[i]$。 对根节点$x$，因为没有父亲，所以就有$F[x]=B[x]$。 所以我们就可以求出所有集合$T$的期望，以及他们对答案的贡献。 但是由于询问数量很多，不能每次都暴力枚举子集。 不难发现，对于一个集合$T$，他是否会对$S$产生贡献以及贡献的大小只取决$T$是不是$S$的子集以及$T$本身。 所以我们可以先预处理出所有$2^n$个子集的贡献，然后就可以通过高维前缀和来快速统计每一个询问的答案了。 时间复杂度$O(n\cdot 2^n)$。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#include&lt;cstdio&gt;#include&lt;cstring&gt;using namespace std;typedef long long LL;const int maxn=20,TT=998244353;int n,Q,x,tot,lnk[maxn],son[maxn*2],nxt[maxn*2],deg[maxn],K[maxn],B[maxn],SK[maxn],SB[maxn],G[(1&lt;&lt;18)+5],cnt[(1&lt;&lt;18)+5];inline int read()&#123; int ret=0,f=1;char ch=getchar(); while(ch&lt;'0'||ch&gt;'9')&#123;if(ch=='-')f=-f;ch=getchar();&#125; while(ch&gt;='0'&amp;&amp;ch&lt;='9')&#123;ret=ret*10+ch-'0';ch=getchar();&#125; return ret*f;&#125;inline int QP(int a,int b)&#123; int ret=1,w=a; while(b) &#123; if(b&amp;1) ret=(LL)ret*w%TT; w=(LL)w*w%TT;b&gt;&gt;=1; &#125; return ret;&#125;inline void add_e(int x,int y)&#123;tot++;deg[y]++;son[tot]=y;nxt[tot]=lnk[x];lnk[x]=tot;&#125;void DFS(int now,int fa,int S)&#123; for(int i=lnk[now];i;i=nxt[i]) &#123; if(son[i]!=fa) &#123; DFS(son[i],now,S); SK[now]=(SK[now]+K[son[i]])%TT; SB[now]=(SB[now]+B[son[i]])%TT; &#125; &#125; if((1&lt;&lt;(now-1))&amp;S) K[now]=B[now]=0; else &#123; K[now]=QP((deg[now]-SK[now]+TT)%TT,TT-2); B[now]=((LL)SB[now]+deg[now])*K[now]%TT; &#125;&#125;int main()&#123; n=read();Q=read();x=read(); for(int i=1;i&lt;n;i++) &#123; int a=read(),b=read(); add_e(a,b);add_e(b,a); &#125; for(int i=0;i&lt;(1&lt;&lt;n);i++) &#123; memset(K,0,sizeof(K));memset(SK,0,sizeof(SK)); memset(B,0,sizeof(B));memset(SB,0,sizeof(SB)); DFS(x,0,i);cnt[i]=cnt[i&gt;&gt;1]+(i&amp;1); G[i]=(((cnt[i]&amp;1)?1:-1)*B[x]+TT)%TT; &#125; for(int i=0;i&lt;n;i++) for(int j=0;j&lt;(1&lt;&lt;n);j++) if(j&amp;(1&lt;&lt;i)) G[j]=(G[j]+G[j-(1&lt;&lt;i)])%TT; while(Q--) &#123; int k=read(),S=0; while(k--) S+=1&lt;&lt;(read()-1); printf("%d\n",G[S]); &#125; return 0;&#125; 猎人杀题解对于这一道题，一个比较麻烦的问题就是当死了猎人之后，每个猎人的中枪概率会发生改变。 不妨对问题进行这样的转化： 当猎人中枪之后，他的尸体还在，并且在下一次开枪的时候，他的尸体仍然有机会被打中，打中的概率不变。如果一次开枪打中了一具尸体，那么就继续开枪，直到打到活人为止。 不难发现，这样转化问题之后，问题的答案并没有改变，而且此时每次猎人中枪的概率没变。 并且直接计算$1$号猎人最后死亡的概率并不容易，考虑容斥： ans=1+\sum_{T\subseteq \lbrace2,3,\cdots n\rbrace}{(-1)^{|T|}P(T中的猎人都在1之后死)}考虑如何计算一个集合内的所有猎人都在$1$号猎人之后死的概率。 令$S=\sum{i=1}^{n}w_i$，$W_T=\sum{i\in T}W_i$，那么就有： P=\sum_{i=1}^{+\infty}{\frac{W_1}{S}\cdot(1-\frac{W_T+W_1}{S})^{i-1}}\\=\frac{W_1}{S}\sum_{i=0}^{+\infty}{(1-\frac{W_T+W_1}{S})^i}\\=\frac{W_1}{S}\cdot\frac{1}{1-(1-\frac{W_T+W_1}{S})}\\=\frac{W_1}{W_1+W_T}所以，集合$T$对答案的贡献只与$W_T$和$|T|$有关。 但是数据范围非常大，直接背包肯定是不行的，考虑生成函数： F(x)=\prod_{i=2}^{n}{(1-x^{W_i})}那么就有 ans=1+\sum_{i=1}^{S-W1}{[x^i]F(x)\cdot\frac{W_1}{W_1+i}}那个生成函数直接用NTT或者FFT然后分治计算一下就好了，时间复杂度$O(n\log^2n)$。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;typedef long long LL;const int maxn=100005,TT=998244353;int n,w[maxn],r[262160],ans,S;inline int read()&#123; int ret=0,f=1;char ch=getchar(); while(ch&lt;'0'||ch&gt;'9')&#123;if(ch=='-')f=-f;ch=getchar();&#125; while(ch&gt;='0'&amp;&amp;ch&lt;='9')&#123;ret=ret*10+ch-'0';ch=getchar();&#125; return ret*f;&#125;inline int QP(int a,int b)&#123; int ret=1,w=a; while(b) &#123; if(b&amp;1) ret=(LL)ret*w%TT; w=(LL)w*w%TT;b&gt;&gt;=1; &#125; return ret;&#125;struct Polynomial&#123; int n;int* A; Polynomial(const Polynomial&amp; b)&#123;n=b.n;A=new int[n+5];memcpy(A,b.A,4*(n+5));&#125; Polynomial(int l=262160)&#123;n=l;A=new int[l+5];memset(A,0,(l+5)*sizeof(int));&#125; ~Polynomial()&#123;delete A;&#125;&#125;TA,TB;inline void NTT(Polynomial&amp; F,int limit,int typ)&#123; for(int i=0;i&lt;limit;i++) if(i&lt;r[i]) swap(F.A[i],F.A[r[i]]); for(int mid=1;mid&lt;limit;mid&lt;&lt;=1) &#123; int gn=QP(3,(TT-1)/(mid&lt;&lt;1)); if(typ&lt;0) gn=QP(gn,TT-2); for(int j=0;j&lt;limit;j+=(mid&lt;&lt;1)) &#123; int g=1; for(int k=0;k&lt;mid;k++,g=(LL)g*gn%TT) &#123; int x=F.A[j+k],y=(LL)g*F.A[j+k+mid]%TT; F.A[j+k]=(x+y)%TT; F.A[j+k+mid]=(x-y+TT)%TT; &#125; &#125; &#125; if(typ&lt;0) &#123; int inv=QP(limit,TT-2); for(int i=0;i&lt;limit;i++) F.A[i]=(LL)F.A[i]*inv%TT; &#125;&#125;inline Polynomial Calc(int L,int R)&#123; if(L==R) &#123; Polynomial C(w[L]); C.A[0]=1;C.A[w[L]]=TT-1; return C; &#125; int M=(L+R)&gt;&gt;1; Polynomial A=Calc(L,M),B=Calc(M+1,R); int limit=1,l=0; while(limit&lt;=A.n+B.n)&#123;limit&lt;&lt;=1;l++;&#125; for(int i=0;i&lt;limit;i++) r[i]=(r[i&gt;&gt;1]&gt;&gt;1)|((i&amp;1)&lt;&lt;(l-1)); TA.n=A.n;TB.n=B.n;Polynomial C(limit); for(int i=0;i&lt;limit;i++) TA.A[i]=TB.A[i]=0; for(int i=0;i&lt;=A.n;i++) TA.A[i]=A.A[i]; for(int i=0;i&lt;=B.n;i++) TB.A[i]=B.A[i]; NTT(TA,limit,1);NTT(TB,limit,1); for(int i=0;i&lt;limit;i++) C.A[i]=(LL)TA.A[i]*TB.A[i]%TT; NTT(C,limit,-1); C.n=A.n+B.n; return C;&#125;int main()&#123; n=read(); for(int i=1;i&lt;=n;i++)&#123;w[i]=read();if(i&gt;1) S+=w[i];&#125; Polynomial res=Calc(2,n);ans=1; for(int i=1;i&lt;=S;i++) ans=(ans+TT+(LL)res.A[i]*w[1]%TT*QP(i+w[1],TT-2)%TT)%TT; printf("%d\n",ans); return 0;&#125; 斗地主神仙题，蒟蒻我太菜了，做不来。]]></content>
      <categories>
        <category>PKUWC</category>
      </categories>
      <tags>
        <tag>PKUWC</tag>
        <tag>PKUWC2018</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「CSP2019」游记]]></title>
    <url>%2F2019%2F11%2F17%2F%E3%80%8CCSP2019%E3%80%8D%E6%B8%B8%E8%AE%B0-Diary%2F</url>
    <content type="text"><![CDATA[蒟蒻的又一次爆炸。 Day0-2019.11.15昨天晚上回了趟家收拾东西，今天早上来到机房后先把昨天没写完的一道主席树板子题写了。由于我比较菜，一开始WA了，调了好一会儿才过。 今天大家都把自己的电脑带来了，我本来想找个谁的本子拆着玩一下，结果余智超同意了，表示他自己也正打算拆一下他的小米笔记本Pro，于是… 中午12:00左右，坐上大巴车出发，和陈浩杰坐在一起。哥哥路上还在手机上玩了几把狼人杀。 下午四点多到了目的地，我们入住了“范艺术酒店”，和哥哥陈浩杰在一个房间2503。 晚饭在酒店边上的一家叫做百佳旺的快餐店吃饭，吃完饭会酒店之后好不容易才凑齐了一群人，到闪总房间2431听闪总吹牛皮，还是挺休闲的，玩了两局之后便回到了自己的房间。稍微看了一下板子，还和哥哥一起看奇葩说。 挺早就睡了，差不多21:30就把灯熄了，养足精神明天考试。 Day1-2019.11.16今天是CSP2019-S2的一试。 起床之后在洛谷打了个卡，结果是中吉（kkk骗人）。 早上在酒店二楼吃了早饭，东西比较少，一般吧。 吃完之后在楼下集中的时候还是有一点紧张的，又看了几眼板子。 然后就乘车来到了学车中学，排队进入了“负一层教室”（和网上说的一样，在地下停车场用笔记本电脑考试），根据示意图，只有地上设了6个移动厕所。 进入考场之后，还是有点小紧张的，看到了徐瀚文大佬坐在不远的地方，左右两边看上去都是初中生，完了要被各路神仙吊打了。 解压密码是”认真思考“？？？解压过程还是比较顺利的，一次就成功了。 打开了试卷，真的有点紧张了。 在慌张中，我发现T1还是比较水的，分类讨论一下然后递归处理即可。但是我比较菜，挂了几次，而且数据范围比较大，必须要开unsigned long long，而且即使开了也要小心不要溢出，还是有点坑的。 T2是个大模拟，在DFS的过程中开个栈模拟一下即可，回溯的时候撤销操作即可。 写完之后测大样例，WA了，发现是读优写挂了（雾）。 然后最大的样例也过了。 保险起见，对拍了一下，发现一拍就停。调了一下发现有个地方写错了，而且这个错误很容易导致WA，可见大样例有多水。 然后就拍不停了，感觉没什么大问题了。还有两个多小时，去搞T3。 先是思考了很久，没有一点想法。 后来想到可以考虑按照删边顺序建拓扑图，保证无环即可，写了很久，写完差不多考试已经结束了，来不及调试，只好交了10分的大暴力，感觉自己好菜。 出了考场，碰到蓝指导，随口问了他一句是不是AK了，没想到他好像挺生气的，推了我一把。 集中之后问了问大家，才知道T3大家的得分情况都不理想，据说ZYY花了3个小时才AK，难度可想而知。而且T2由于各种各样的原因，也有很多人炸了。 Day1预计得分100+100+10=210。 下午和同学开黑，比较休闲。 晚上和同学交流的时候突然发现T1有个地方写错了，应该是1ull&lt;&lt;n而不是1llu&lt;&lt;n，不知道Linux下会不会CE，突然慌了起来。于是打开了Ubuntu试了一下，好像没有大问题，但是还是有点不安。 晚上还和哥哥看了一会儿奇葩说。 今天睡得迟了一些，不过还是挺早的。 Day2-2019.11.17今天是二试。 早上打卡，还是中吉，完了没救了。 今天感觉就没昨天紧张了。 今天的解压密码是“抓紧时间”？？？还是一次就解压出来了。 看了下T1，感觉有点恐怖，想了好一会儿，只想到了$O(n^3m)$的写法，84分。样例很快就过了，感觉这种题的样例应该不会太水，而且好像也不太好给出很水的样例，就没多管了， 感觉想不出正解了，为了防止爆零，或者重现去年的惨状，为了保险起见只好先写后面的暴力。 T2先写了个$O(n^3)$的暴力，36分，样例轻松过。 T3部分分挺多的，花了挺多时间，骗到了75分，样例也过了。 然后距离考试结束只剩下了一个小时左右。 回头去看T1，又想了一会儿，发现我是真的菜，很容易就优化到了$O(n^2m)$，差不多能过了。 本来还想搞下T2的，估计是个斜率优化或者决策单调性的DP，但是来不及了，只好拍了一下T1，希望能稳住。 Day2预计得分100+36+75=211。两天的预计得分竟是如此的接近。分数太低了，感觉要凉凉。 考试结束后交流了一下，蓝指导切了T3，徐瀚文切了T2，还有几个人T2写了$O(n)$的但是没有写高精度。Day2感觉好多人分数都比我高，感觉自己好菜。冬令营不知道有没有机会，估计是没有了，这回是真的要退役了。 酒店边上吃了午饭就坐车回来了，才想起来这两天发的蛋糕和水果什么的都没有吃，矿泉水还有好几瓶没喝，就原封不动地带回了家。]]></content>
      <categories>
        <category>游记</category>
      </categories>
      <tags>
        <tag>CSP</tag>
        <tag>2019</tag>
        <tag>CSP2019</tag>
        <tag>游记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「TJOI2019」唱、跳、rap和篮球]]></title>
    <url>%2F2019%2F10%2F25%2F%E3%80%8CTJOI2019%E3%80%8D%E5%94%B1%E3%80%81%E8%B7%B3%E3%80%81rap%E5%92%8C%E7%AF%AE%E7%90%83-Solution%2F</url>
    <content type="text"><![CDATA[鲲鲲来啦！ 传送门洛谷P5339 BZOJ5510 题解比较好玩的一个数数题。 考虑如何计算有连续4个位置的同学依次喜欢唱、跳、rap、篮球的情况的数量。 首先可以枚举这种四元组的数量，设有$i$个四元组。 那么这些四元组的出现位置的方案数就为$\tbinom{n-3i}{i}$。 证明： 首先这些四元组显然是两两不交的。 考虑一排点，共有有$n-3i$个，选择$i$个点将它们展开成一个四元组，那么展开之后一共有$n$个点，刚好对应一种出现位置的方案，一共有$\binom{n-3i}{i}$种选择方法。 证毕。 除了四元组之外，考虑其他位置上的同学怎么安排。 如果随便排的话，可能会再次产生四元组，考虑通过容斥把多算的减掉。 所以含有四元组的方案数为： \sum_{i=1}^{\min(a,b,c,d)}{(-1)^{i+1}\cdot\tbinom{n-3i}{i}\cdot[剩下位置的方案数]}考虑剩下位置的方案数怎么算，设喜欢唱、跳、rap、篮球的人分别取了$e,f,g,h$个$(e\leq a-i,f\leq b-i,g\leq c-i,h\leq d-i)$，那么方案数就是： \sum \frac{(n-4i)!}{e!f!g!h!}=(n-4i)!\sum{\frac{1}{e!}\cdot\frac{1}{f!}\cdot\frac{1}{g!}\cdot\frac{1}{h!}\cdot[e+f+g+h=n-4i]}所以就可以构四个多项式，其中第一个为： \frac{1}{1!}\cdot x^1+\frac{1}{2!}\cdot x^2+\cdots \frac{1}{(a-i)!}\cdot x^{a-i}剩下三个多项式同理。然后把四个多项式用NTT卷乘起来，$x^{n-4i}$项的系数就是我们所要求的剩下位置的方案数。 由于要求的是不包含任意一个四元组的方案数，所以最后的答案为： \sum_{i=0}^{\min(a,b,c,d)}{(-1)^{i}\cdot\tbinom{n-3i}{i}\cdot[剩下位置的方案数]}时间复杂度$O(n^2\log n)$。 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;typedef long long LL;const int maxn=1005,maxl=2050,TT=998244353;int n,a,b,c,d,fac[maxn],inv[maxn],r[maxl],ans,A[maxl],B[maxl],C[maxl],D[maxl],E[maxl];inline int QP(int a,int b)&#123; int ret=1,w=a; while(b) &#123; if(b&amp;1) ret=(LL)ret*w%TT; w=(LL)w*w%TT;b&gt;&gt;=1; &#125; return ret;&#125;inline void NTT(int* A,int limit,int typ)&#123; for(int i=0;i&lt;limit;i++) if(i&lt;r[i]) swap(A[i],A[r[i]]); for(int mid=1;mid&lt;limit;mid&lt;&lt;=1) &#123; int gn=QP(3,(TT-1)/(mid&lt;&lt;1)); if(typ&lt;0) gn=QP(gn,TT-2); for(int j=0;j&lt;limit;j+=mid&lt;&lt;1) &#123; int g=1; for(int k=0;k&lt;mid;k++,g=(LL)g*gn%TT) &#123; int x=A[j+k],y=(LL)g*A[j+k+mid]%TT; A[j+k]=(x+y)%TT; A[j+k+mid]=(x-y+TT)%TT; &#125; &#125; &#125; if(typ&lt;0) &#123; int inv=QP(limit,TT-2); for(int i=0;i&lt;limit;i++) A[i]=(LL)A[i]*inv%TT; &#125;&#125;inline int Com(int n,int m)&#123;return (LL)fac[n]*inv[m]%TT*inv[n-m]%TT;&#125;inline void Solve()&#123; fac[0]=inv[0]=1; for(int i=1;i&lt;=1000;i++) &#123; fac[i]=(LL)fac[i-1]*i%TT; inv[i]=QP(fac[i],TT-2); &#125; int mg=min(min(min(a,b),min(c,d)),n/4); for(int i=0;i&lt;=mg;i++) &#123; memset(A,0,sizeof(A));memset(B,0,sizeof(B));memset(C,0,sizeof(C));memset(D,0,sizeof(D)); for(int j=0;j&lt;=a-i;j++) A[j]=inv[j]; for(int j=0;j&lt;=b-i;j++) B[j]=inv[j]; for(int j=0;j&lt;=c-i;j++) C[j]=inv[j]; for(int j=0;j&lt;=d-i;j++) D[j]=inv[j]; int limit=1,l=0; while(limit&lt;=a+b+c+d-4*i)&#123;limit&lt;&lt;=1;l++;&#125; for(int j=0;j&lt;limit;j++) r[j]=(r[j&gt;&gt;1]&gt;&gt;1)|((j&amp;1)&lt;&lt;(l-1)); NTT(A,limit,1);NTT(B,limit,1);NTT(C,limit,1);NTT(D,limit,1); for(int j=0;j&lt;limit;j++) E[j]=(LL)A[j]*B[j]%TT*C[j]%TT*D[j]%TT; NTT(E,limit,-1); ans=(ans+(LL)QP(-1,i)*Com(n-3*i,i)*fac[n-4*i]%TT*E[n-4*i]%TT+TT)%TT; &#125;&#125;int main()&#123; scanf("%d%d%d%d%d",&amp;n,&amp;a,&amp;b,&amp;c,&amp;d); Solve(); printf("%d\n",ans); return 0;&#125;]]></content>
      <categories>
        <category>组合数学</category>
      </categories>
      <tags>
        <tag>NTT</tag>
        <tag>卷积</tag>
        <tag>数数</tag>
        <tag>组合数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「AH2017/HNOI2017」礼物]]></title>
    <url>%2F2019%2F10%2F21%2F%E3%80%8CAH2017HNOI2017%E3%80%8D%E7%A4%BC%E7%89%A9-Solution%2F</url>
    <content type="text"><![CDATA[一个经典套路。 传送门洛谷P3723 BZOJ4827 题解首先来看下题目里的式子： \sum_{i=1}^{n}{(x_i-y_i+c)^2}=\sum_{i=1}^{n}{x_i^2+y_i^2+c^2-2x_iy_i+2cx_i-2cy_i}其中$\sum x_i^2+y_i^2$为定值，$\sum c^2+2cx_i-2cy_i-2x_iy_i$在确定了$c$的值之后也是定值，并且c的值非常小可以暴枚，所以只需要考虑$\sum x_iy_i$。 由于是一个环，按照套路，可以先将$x_i$复制一遍。 设$C_i$为旋转了$i$个单位后$\sum x_iy_i$的值，有： C_i=\sum_{j=1}^{n}{x_{i+j}y_j}这个式子不是很好看，于是我们把$y$（$x$也行）倒过来，那么就有： C_i=\sum_{j=1}^{n}{x_{i+j}y_{n-j+1}}然后不难发现，$x$与$y$下标之和为$n+i+1$的数将被乘起来然后对$C_i$造成贡献，所此时以$C_i$就等于多项式$x_1\cdot x+x_2\cdot x^2+\cdots x_n\cdot x^n$与$y_1\cdot x+y_2\cdot x^2+\cdots y_n\cdot x^n$卷积卷起来之后$x^{i+n+1}$项的系数。 然后NTT求个卷积然后取个最小值就行了。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;typedef long long LL;const int maxn=50005,TT=998244353;int n,m,r[maxn&lt;&lt;3],X[maxn],Y[maxn],A[maxn&lt;&lt;3],B[maxn&lt;&lt;3],C[maxn&lt;&lt;3],ans=2e9;inline int read()&#123; int ret=0,f=1;char ch=getchar(); while(ch&lt;'0'||ch&gt;'9')&#123;if(ch=='-')f=-f;ch=getchar();&#125; while(ch&gt;='0'&amp;&amp;ch&lt;='9')&#123;ret=ret*10+ch-'0';ch=getchar();&#125; return ret*f;&#125;inline int QP(int a,int b)&#123; int ret=1,w=a; while(b) &#123; if(b&amp;1) ret=(LL)ret*w%TT; w=(LL)w*w%TT;b&gt;&gt;=1; &#125; return ret;&#125;inline void NTT(int* A,int limit,int typ)&#123; for(int i=0;i&lt;limit;i++) if(i&lt;r[i]) swap(A[i],A[r[i]]); for(int mid=1;mid&lt;limit;mid&lt;&lt;=1) &#123; int gn=QP(3,(TT-1)/(mid&lt;&lt;1)); if(typ&lt;0) gn=QP(gn,TT-2); for(int j=0;j&lt;limit;j+=mid&lt;&lt;1) &#123; int g=1; for(int k=0;k&lt;mid;k++,g=(LL)g*gn%TT) &#123; int x=A[j+k],y=(LL)g*A[j+k+mid]%TT; A[j+k]=(x+y)%TT; A[j+k+mid]=(x-y+TT)%TT; &#125; &#125; &#125; if(typ&lt;0) &#123; int inv=QP(limit,TT-2); for(int i=0;i&lt;limit;i++) A[i]=(LL)A[i]*inv%TT; &#125;&#125;inline int Calc(int c)&#123;int ret=0;for(int i=1;i&lt;=n;i++)ret+=X[i]*X[i]+Y[i]*Y[i]+c*c+2*X[i]*c-2*Y[i]*c;return ret;&#125;inline void Solve()&#123; for(int i=1;i&lt;=n;i++) A[i]=A[i+n]=X[i]; for(int i=1;i&lt;=n;i++) B[i]=Y[i]; reverse(A+1,A+1+n*2); int limit=1,l=0; while(limit&lt;=n+n+m)&#123;limit&lt;&lt;=1;l++;&#125; for(int i=0;i&lt;limit;i++) r[i]=(r[i&gt;&gt;1]&gt;&gt;1)|((i&amp;1)&lt;&lt;(l-1)); NTT(A,limit,1); NTT(B,limit,1); for(int i=0;i&lt;limit;i++) C[i]=(LL)A[i]*B[i]%TT; NTT(C,limit,-1); for(int c=-m;c&lt;=m;c++) if(Calc(c)&lt;ans) ans=Calc(c); int tep=0; for(int i=1;i&lt;=n;i++) if(C[n+i]&gt;tep) tep=C[n+i]; ans-=2*tep;&#125;int main()&#123; n=read();m=read(); for(int i=1;i&lt;=n;i++) X[i]=read(); for(int i=1;i&lt;=n;i++) Y[i]=read(); Solve(); printf("%d\n",ans); return 0;&#125;]]></content>
      <categories>
        <category>卷积</category>
      </categories>
      <tags>
        <tag>NTT</tag>
        <tag>卷积</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「洛谷P2000」拯救世界]]></title>
    <url>%2F2019%2F10%2F13%2F%E3%80%8C%E6%B4%9B%E8%B0%B7P2000%E3%80%8D%E6%8B%AF%E6%95%91%E4%B8%96%E7%95%8C-Solution%2F</url>
    <content type="text"><![CDATA[kkk牛逼！ 传送门洛谷P2000 题解生成函数裸题。 依次来看召唤每一位大神所需的每种石头的情况： 金神石的块数必须是6的倍数：$1+x^6+x^{12}+\dots=\frac{1}{1-x^6}$ 木神石最多用9块：$1+x+x^2+\dots+x^9=\frac{1-x^{10}}{1-x}$ 水神石最多用5块：$1+x+x^2+\dots+x^5=\frac{1-x^6}{1-x}$ 火神石的块数必须是4的倍数：$1+x^4+x^8+\dots=\frac{1}{1-x^4}$ 土神石最多用7块：$1+x+x^2+\dots+x^7=\frac{1-x^8}{1-x}$ 金神石的块数必须是2的倍数：$1+x^2+x^4+\dots=\frac{1}{1-x^2}$ 木神石最多用1块：$1+x=\frac{1-x^2}{1-x}$ 水神石的块数必须是8的倍数：$1+x^8+x^{16}+\dots=\frac{1}{1-x^8}$ 火神石的块数必须是10的倍数：$1+x^{10}+x^{20}+\dots=\frac{1}{1-x^{10}}$ 土神石最多用3块：$1+x+x^2+x^3=\frac{1-x^4}{1-x}$ 然后把它们全都乘起来，就有： \frac{1}{1-x^6}\cdot \frac{1-x^{10}}{1-x} \cdot \frac{1-x^6}{1-x} \cdot \frac{1}{1-x^4} \cdot \frac{1-x^8}{1-x} \cdot \frac{1}{1-x^2} \cdot \frac{1-x^2}{1-x} \cdot \frac{1}{1-x^8} \cdot \frac{1}{1-x^{10}} \cdot \frac{1-x^4}{1-x}\\ =(\frac{1}{1-x})^5然后再把这个式子展开，就是： (1+x+x^2+x^3+\dots)^5答案就是上面这个多项式$x^n$项前面的系数。 通过隔板法可以求出答案为$\tbinom{n+5-1}{5-1}=\frac{n\cdot (n+1) \cdot(n+2)\cdot(n+3)}{24}$。 由于数据范围很大，所以上NTT来优化高精度乘法即可。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;typedef long long LL;const int TT=998244353;int r[263000];char n[100005];inline int read()&#123; int ret=0,f=1;char ch=getchar(); while(ch&lt;'0'||ch&gt;'9')&#123;if(ch=='-')f=-f;ch=getchar();&#125; while(ch&gt;='0'&amp;&amp;ch&lt;='9')&#123;ret=ret*10+ch-'0';ch=getchar();&#125; return ret*f;&#125;inline int QP(int a,int b)&#123; int ret=1,w=a; while(b) &#123; if(b&amp;1) ret=(LL)ret*w%TT; w=(LL)w*w%TT;b&gt;&gt;=1; &#125; return ret;&#125;inline void NTT(int* A,int limit,int type)&#123; for(int i=0;i&lt;limit;i++) if(i&lt;r[i]) swap(A[i],A[r[i]]); for(int mid=1;mid&lt;limit;mid&lt;&lt;=1) &#123; int gn=QP(3,(TT-1)/(mid&lt;&lt;1)); if(type&lt;0) gn=QP(gn,TT-2); for(int j=0;j&lt;limit;j+=mid&lt;&lt;1) &#123; int g=1; for(int k=0;k&lt;mid;k++,g=(LL)g*gn%TT) &#123; int x=A[j+k],y=(LL)g*A[j+k+mid]%TT; A[j+k]=(x+y)%TT; A[j+k+mid]=(x-y+TT)%TT; &#125; &#125; &#125; if(type&lt;0) &#123; int inv=QP(limit,TT-2); for(int i=0;i&lt;=limit;i++) A[i]=(LL)A[i]*inv%TT; &#125;&#125;struct BigInteger&#123; int len,a[263000]; BigInteger()&#123;len=0;memset(a,0,sizeof(a));&#125; BigInteger(char* S) &#123; len=0;memset(a,0,sizeof(a)); int n=strlen(S+1); reverse(S+1,S+1+n); len=(n+1)/2; for(int i=1;i&lt;=n;i++) S[i]-='0'; for(int i=1;i&lt;=len;i++) a[i]=S[i*2-1]+S[i*2]*10; &#125; BigInteger operator * (BigInteger b) &#123; BigInteger a=*this,c; c.len=a.len+b.len; int limit=1,l=0; while(limit&lt;=c.len)&#123;limit&lt;&lt;=1;l++;&#125; for(int i=0;i&lt;limit;i++) r[i]=(r[i&gt;&gt;1]&gt;&gt;1)|((i&amp;1)&lt;&lt;(l-1)); NTT(a.a+1,limit,1); NTT(b.a+1,limit,1); for(int i=1;i&lt;=limit;i++) c.a[i]=(LL)a.a[i]*b.a[i]%TT; NTT(c.a+1,limit,-1); for(int i=1;i&lt;=c.len;i++) &#123; c.a[i+1]+=c.a[i]/100; c.a[i]%=100; &#125; if(!c.a[c.len]) c.len--; return c; &#125; void operator /= (int b) &#123; for(int i=len;i;i--) &#123; a[i-1]+=(a[i]%b)*100; a[i]/=b; &#125; a[0]=0; if(!a[len]) len--; &#125; inline void Inc() &#123; a[1]++; for(int i=1;i&lt;=len;i++) &#123; if(a[i]&lt;100) break; a[i+1]+=a[i]/100; a[i]%=100; &#125; if(a[len+1]) len++; &#125; void Print() &#123; printf("%d",a[len]); for(int i=len-1;i&gt;0;i--) printf("%02d",a[i]); putchar('\n'); &#125;&#125;A,B,C,D,ans;int main()&#123; scanf("%s",n+1); A=n;A.Inc(); B=A;B.Inc(); C=B;C.Inc(); D=C;C.Inc(); ans=A*B*C*D; ans/=24; ans.Print(); return 0;&#125;]]></content>
      <categories>
        <category>生成函数</category>
      </categories>
      <tags>
        <tag>NTT</tag>
        <tag>高精度</tag>
        <tag>生成函数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「十二省联考2019」异或粽子]]></title>
    <url>%2F2019%2F08%2F16%2F%E3%80%8C%E5%8D%81%E4%BA%8C%E7%9C%81%E8%81%94%E8%80%832019%E3%80%8D%E5%BC%82%E6%88%96%E7%B2%BD%E5%AD%90-Solution%2F</url>
    <content type="text"><![CDATA[粽子真好吃qwq。 传送门洛谷P5283 BZOJ5495 题解这题还是比较套路的吧。 令$S_i=a_1⊕a_2⊕\cdots⊕a_i$。 则$Al⊕A{l+1}⊕\cdots⊕Ar=S_r⊕S{l-1}$。 首先，对于每一个$r$，找到与$Sr$异或值最大的$S{l-1}$并把它们扔进一个堆里。 然后重复下面的步骤$K$次： 取出堆顶的元素； 更新堆顶元素所对应的$Sr$在删去当前与它异或值最大的$S{l-1}$后与它异或值最大的数； 将更新过后的最大数重新丢进堆里； 可以通过可持久化Trie来完成这个维护的过程。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127#include&lt;queue&gt;#include&lt;cstdio&gt;using namespace std;typedef long long LL;const int maxn=500005,maxk=200005;int n,K,idx[maxn],cnt[maxn];LL A[maxn],S[maxn],ans,Pow[35];inline char nc()&#123; static const int S=1048576;static char buf[S],*L,*R; return L==R&amp;&amp;(R=(L=buf)+fread(buf,1,S,stdin),L==R)?EOF:*L++;&#125;inline LL read()&#123; LL ret=0,f=1;char ch=nc(); while(ch&lt;'0'||ch&gt;'9')&#123;if(ch=='-')f=-f;ch=nc();&#125; while(ch&gt;='0'&amp;&amp;ch&lt;='9')&#123;ret=ret*10+ch-'0';ch=nc();&#125; return ret*f;&#125;struct PersistentTrie&#123; int cnt,tot,R[maxn+maxk]; struct Node&#123;int siz,son[2];&#125;Tree[maxn*33+maxk*33]; inline int NewNode()&#123;return ++tot;&#125; inline int NewTree()&#123;return ++cnt;&#125; inline void Insert(LL num) &#123; int pre=R[cnt],rt=R[NewTree()]=NewNode(); for(int i=31;i&gt;=0;i--) &#123; Tree[rt]=Tree[pre]; Tree[rt].siz++; if(num&amp;Pow[i]) &#123; Tree[rt].son[1]=NewNode(); rt=Tree[rt].son[1];pre=Tree[pre].son[1]; &#125; else &#123; Tree[rt].son[0]=NewNode(); rt=Tree[rt].son[0];pre=Tree[pre].son[0]; &#125; &#125; Tree[rt]=Tree[pre]; Tree[rt].siz++; &#125; inline void Del(LL num,int pre) &#123; int rt=R[NewTree()]=NewNode();pre=R[pre]; for(int i=31;i&gt;=0;i--) &#123; Tree[rt]=Tree[pre]; Tree[rt].siz--; if(num&amp;Pow[i]) &#123; Tree[rt].son[1]=NewNode(); rt=Tree[rt].son[1];pre=Tree[pre].son[1]; &#125; else &#123; Tree[rt].son[0]=NewNode(); rt=Tree[rt].son[0];pre=Tree[pre].son[0]; &#125; &#125; Tree[rt]=Tree[pre]; Tree[rt].siz--; &#125; inline LL QueryMax(LL num,int rt) &#123; LL ret=0; for(int i=31;i&gt;=0;i--) &#123; int nxt=!(bool)(num&amp;Pow[i]); if(Tree[Tree[rt].son[nxt]].siz) &#123; rt=Tree[rt].son[nxt]; if(nxt) ret+=Pow[i]; &#125; else &#123; rt=Tree[rt].son[!nxt]; if(!nxt) ret+=Pow[i]; &#125; &#125; return ret; &#125;&#125;PT;struct Ele&#123; int pos;LL num,sum; bool operator &lt; (const Ele&amp; b)const&#123;return sum&lt;b.sum;&#125;&#125;tep;inline void Solve()&#123; priority_queue&lt;Ele&gt; H; for(int i=1;i&lt;=n;i++) &#123; S[i]=S[i-1]^A[i]; PT.Insert(S[i-1]); idx[i]=PT.cnt; tep.pos=i; tep.num=PT.QueryMax(S[i],PT.R[idx[i]]); tep.sum=tep.num^S[i]; H.push(tep); &#125; while(K--) &#123; tep=H.top();H.pop(); ans+=tep.sum;cnt[tep.pos]++; if(cnt[tep.pos]&lt;tep.pos) &#123; PT.Del(tep.num,idx[tep.pos]); idx[tep.pos]=PT.cnt; tep.num=PT.QueryMax(S[tep.pos],PT.R[idx[tep.pos]]); tep.sum=tep.num^S[tep.pos]; H.push(tep); &#125; &#125;&#125;int main()&#123; n=read();K=read();Pow[0]=1; for(int i=1;i&lt;=n;i++) A[i]=read(); for(int i=1;i&lt;=31;i++) Pow[i]=Pow[i-1]*2; Solve(); printf("%lld\n",ans); return 0;&#125;]]></content>
      <categories>
        <category>可持久化Trie</category>
      </categories>
      <tags>
        <tag>可持久化</tag>
        <tag>Trie</tag>
        <tag>可持久化Trie</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「WC2013」糖果公园]]></title>
    <url>%2F2019%2F08%2F15%2F%E3%80%8CWC2013%E3%80%8D%E7%B3%96%E6%9E%9C%E5%85%AC%E5%9B%AD-Solution%2F</url>
    <content type="text"><![CDATA[吃个糖果还这么多事情。 传送门洛谷P4074 BZOJ3052 题解树上带修莫队的板子题，以前一直没写。 树上莫队的话就需要先对树进行分块，王室联邦分块即可。 移动端点的时候可以先把路径存下来，然后再按顺序移动。 块大小取$n^{\frac{2}{3}}$时比较优。 其他照常写就好了，注意常数。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;typedef long long LL;const int maxn=100005;int n,m,q,c,tot,lnk[maxn],son[maxn*2],nxt[maxn*2],dep[maxn],fa[maxn],W[maxn],V[maxn],C[maxn],S,cnt,Area[maxn],top,stk[maxn],hsh[maxn],pa[maxn];LL ans[maxn],now;bool vis[maxn];struct FastIO&#123; static const int S=1048576; char buf[S],*L,*R;int stk[20],Top; ~FastIO()&#123;clear();&#125; inline char nc()&#123;return L==R&amp;&amp;(R=(L=buf)+fread(buf,1,S,stdin),L==R)?EOF:*L++;&#125; inline void clear()&#123;fwrite(buf,1,Top,stdout);Top=0;&#125; inline void pc(char ch)&#123;Top==S&amp;&amp;(clear(),0);buf[Top++]=ch;&#125; FastIO&amp; operator &gt;&gt; (int&amp; ret) &#123; ret=0;int f=1;char ch=nc(); while(ch&lt;'0'||ch&gt;'9')&#123;if(ch=='-')f=-f;ch=nc();&#125; while(ch&gt;='0'&amp;&amp;ch&lt;='9')&#123;ret=ret*10+ch-'0';ch=nc();&#125; ret*=f;return *this; &#125; FastIO&amp; operator &lt;&lt; (LL x) &#123; if(x&lt;0)&#123;pc('-');x=-x;&#125; do&#123;stk[++stk[0]]=x%10;x/=10;&#125;while(x); while(stk[0]) pc('0'+stk[stk[0]--]); return *this; &#125; FastIO&amp; operator &lt;&lt; (char ch)&#123;pc(ch);return *this;&#125;&#125;fin,fout;struct Query&#123; int L,R,t,id; bool operator &lt; (const Query&amp; b)const&#123;return Area[L]&lt;Area[b.L]||(Area[L]==Area[b.L]&amp;&amp;Area[R]&lt;Area[b.R])||(Area[L]==Area[b.L]&amp;&amp;Area[R]==Area[b.R]&amp;&amp;t&lt;b.t);&#125;&#125;Q[maxn];struct Change&#123;int t,x,y,lst;&#125;CK[maxn];inline void add_e(int x,int y)&#123;tot++;son[tot]=y;nxt[tot]=lnk[x];lnk[x]=tot;&#125;void DFS(int now)&#123; int lst=top;stk[++top]=now;dep[now]=dep[fa[now]]+1; for(int i=lnk[now];i;i=nxt[i]) &#123; if(son[i]==fa[now]) continue; fa[son[i]]=now;DFS(son[i]); if(top-lst&gt;=S) &#123; cnt++; while(top!=lst)&#123;Area[stk[top]]=cnt;top--;&#125; &#125; &#125;&#125;inline void Inc(int x)&#123;hsh[x]++;now+=(LL)V[x]*W[hsh[x]];&#125;inline void Dec(int x)&#123;now-=(LL)V[x]*W[hsh[x]];hsh[x]--;&#125;inline void Init()&#123; static int tep[maxn]; DFS(1);q-=c;sort(Q+1,Q+1+q); if(top)&#123;cnt++;while(top)&#123;Area[stk[top]]=cnt;top--;&#125;&#125; memcpy(tep,C,sizeof(C)); for(int i=1;i&lt;=c;i++) &#123; CK[i].lst=tep[CK[i].x]; tep[CK[i].x]=CK[i].y; &#125;&#125;inline void GetDist(int u,int v)&#123; static int stk[maxn],top; pa[0]=top=0;pa[++pa[0]]=u;stk[++top]=v; while(u!=v) &#123; if(dep[u]&gt;=dep[v])&#123;u=fa[u];pa[++pa[0]]=u;&#125; else&#123;v=fa[v];stk[++top]=v;&#125; &#125; for(int i=top-1;i;i--) pa[++pa[0]]=stk[i];&#125;inline void Solve()&#123; int L=1,R=1,t=0;vis[1]=true;Inc(C[1]); for(int i=1;i&lt;=q;i++) &#123; if(L!=Q[i].L) &#123; GetDist(L,Q[i].L); for(int j=1;j&lt;pa[0];j++) &#123; if(vis[pa[j+1]])&#123;Dec(C[pa[j]]);vis[pa[j]]=false;&#125; else&#123;Inc(C[pa[j+1]]);vis[pa[j+1]]=true;&#125; &#125; L=Q[i].L; &#125; if(R!=Q[i].R) &#123; GetDist(R,Q[i].R); for(int j=1;j&lt;pa[0];j++) &#123; if(vis[pa[j+1]])&#123;Dec(C[pa[j]]);vis[pa[j]]=false;&#125; else&#123;Inc(C[pa[j+1]]);vis[pa[j+1]]=true;&#125; &#125; R=Q[i].R; &#125; while(t&lt;c&amp;&amp;CK[t+1].t&lt;Q[i].t) &#123; t++; if(vis[CK[t].x]) Dec(CK[t].lst); C[CK[t].x]=CK[t].y; if(vis[CK[t].x]) Inc(CK[t].y); &#125; while(CK[t].t&gt;Q[i].t) &#123; if(vis[CK[t].x]) Dec(CK[t].y); C[CK[t].x]=CK[t].lst; if(vis[CK[t].x]) Inc(CK[t].lst); t--; &#125; ans[Q[i].id]=now; &#125;&#125;int main()&#123; fin&gt;&gt;n&gt;&gt;m&gt;&gt;q;S=pow(n,2.0/3)+1e-10; for(int i=1;i&lt;=m;i++) fin&gt;&gt;V[i]; for(int i=1;i&lt;=n;i++) fin&gt;&gt;W[i]; for(int i=1;i&lt;n;i++) &#123; int a,b;fin&gt;&gt;a&gt;&gt;b; add_e(a,b);add_e(b,a); &#125; for(int i=1;i&lt;=n;i++) fin&gt;&gt;C[i]; for(int i=1;i&lt;=q;i++) &#123; int opt;fin&gt;&gt;opt; if(opt)&#123;fin&gt;&gt;Q[i-c].L&gt;&gt;Q[i-c].R;Q[i-c].id=i-c;Q[i-c].t=i;&#125; else&#123;c++;fin&gt;&gt;CK[c].x&gt;&gt;CK[c].y;CK[c].t=i;&#125; &#125; Init();Solve(); for(int i=1;i&lt;=q;i++) fout&lt;&lt;ans[i]&lt;&lt;'\n'; return 0;&#125;]]></content>
      <categories>
        <category>树上带修莫队</category>
      </categories>
      <tags>
        <tag>莫队</tag>
        <tag>树上莫队</tag>
        <tag>带修莫队</tag>
        <tag>树上带修莫队</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「HNOI2013」游走]]></title>
    <url>%2F2019%2F08%2F09%2F%E3%80%8CHNOI2013%E3%80%8D%E6%B8%B8%E8%B5%B0-Solution%2F</url>
    <content type="text"><![CDATA[期望什么的最不会了qwq。 传送门洛谷P3232 BZOJ3143 题解首先先考虑如何求一个点的期望经过次数，不难发现有： E(i)=\sum_{(i,j)\in E}{\frac{E(j)}{deg[j]}}注意节点$1$和节点$n$要特殊考虑。 可以用高斯消元法求解出每个点的期望经过次数，从而计算出每条边的期望经过次数。 将边的期望经过次数由大到小排序，依次编号为$1-M$然后计算出总和即可。 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;const int maxn=505;int n,m,tot,lnk[maxn],son[maxn*maxn],nxt[maxn*maxn],deg[maxn];double A[maxn][maxn],ans,cnt[maxn*maxn];inline int read()&#123; int ret=0,f=1;char ch=getchar(); while(ch&lt;'0'||ch&gt;'9')&#123;if(ch=='-')f=-f;ch=getchar();&#125; while(ch&gt;='0'&amp;&amp;ch&lt;='9')&#123;ret=ret*10+ch-'0';ch=getchar();&#125; return ret*f;&#125;inline void add_e(int x,int y)&#123;tot++;son[tot]=y;deg[y]++;nxt[tot]=lnk[x];lnk[x]=tot;&#125;inline double ABS(double x)&#123;return x&lt;0?-x:x;&#125;inline void Gauss()&#123; for(int i=1;i&lt;n;i++) &#123; for(int j=i+1;j&lt;=n;j++) &#123; double t=(double)-A[j][i]/A[i][i]; for(int k=i;k&lt;=n+1;k++) A[j][k]+=t*A[i][k]; &#125; &#125; for(int i=n;i;i--) &#123; for(int j=i+1;j&lt;=n;j++) A[i][n+1]-=A[i][j]*A[j][n+1]; A[i][n+1]/=A[i][i]; &#125;&#125;inline void Solve()&#123; for(int i=1;i&lt;n;i++) for(int j=lnk[i];j;j=nxt[j]) cnt[(j+1)&gt;&gt;1]+=A[i][n+1]/deg[i]; sort(cnt+1,cnt+1+m); for(int i=1;i&lt;=m;i++) ans+=cnt[i]*(m-i+1);&#125;int main()&#123; n=read();m=read(); for(int i=1;i&lt;=n;i++) A[i][i]=-1; A[n][n+1]=1;A[1][n+1]=-1; for(int i=1;i&lt;=m;i++) &#123; int a=read(),b=read(); add_e(a,b);add_e(b,a); &#125; for(int i=1;i&lt;n;i++) for(int j=lnk[i];j;j=nxt[j]) A[son[j]][i]=(double)1/deg[i]; Gauss(); Solve(); printf("%.3lf\n",ans); return 0;&#125;]]></content>
      <categories>
        <category>高斯消元</category>
      </categories>
      <tags>
        <tag>概率</tag>
        <tag>期望</tag>
        <tag>高斯消元</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「慈溪中学」暑假集训游记]]></title>
    <url>%2F2019%2F08%2F05%2F%E3%80%8C%E6%85%88%E6%BA%AA%E4%B8%AD%E5%AD%A6%E3%80%8D%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E6%B8%B8%E8%AE%B0-Diary%2F</url>
    <content type="text"><![CDATA[换个地方被吊打。 Day1-2019.08.05今天出发去慈溪中学，准备参加集训。 早上家里起床之后，先收拾了东西，然后写了会儿文化课作业，前几天都没怎么写过，一看时间，慈溪回来之后估计差不多就开学了，焚化课作业得赶紧写完（不过好像并没有多少）。 早上9:40准时到了机房，大家差不多都已经来了，机房里显得有些热闹。 过了一会儿就坐上大巴车出发了，由于堵车，只好先开到龙游在上高速。 在车上和神仙鲁永卓坐在一起。 中午12:00左右，到了金华服务区，大家下去吃饭，下车的时候老叶说了一句：“12:15之前要回到车上，大家都不要拖。” 下去吃了一碗小馄饨，10块钱，血亏，然后去了小超市买了点零食，小贵。 快到时间了，准备上车，但是司机还没有来，只好先在边上等。 上车之后，老叶还没有来。小叶先点了下名，发现只有老叶一个人迟到了（真香）。 下午三点多才到，到了之后先把行李放在寝室楼的大厅里，因为楼上还有人没有搬走，所以先去机房坐了会儿。 看了下机子，美帝良心想的一体机，i3-6100，海星。就是系统是win7。 尝试鼓捣了一下怎么开WTG，但是没有成功。 16:50，可以去寝室了。和陈潇然、黄霖、蓝天朗分在了一个寝室。不知道为什么选我当寝室长，闪总当的话，只要吼一声就没人敢讲话了。抛硬币决定了床铺位，结果闪总上铺。 寝室的布局和衢二略有不同，总体上比衢二好，就是洗澡得到楼下的大浴室。浴室里用隔板隔出了许多小隔间，就是小隔间里没有地方放衣服，得自己带塑料袋。 晚饭在食堂吃盒饭，老师讲了一下一些事项，说以后的早饭是两个包子+牛奶+鸡蛋。闪总：“这哪里够吃哒？”，“包子怎么能按个吃，不应该是按笼吃的吗？”老师只好说再加一个。 晚上没有去机房，在寝室里和一堆人一起玩狼人杀（20圈警告）。 晚上21:30就熄灯了，比较早。 感觉闪总翻个身整个床就会狠狠地摇两下。 颓废的一天结束了。 Day2-2019.08.06在慈溪中学集训的第一天。 早上5:30起床补焚化课作业，做什么语文的摘抄，直接拿了本教辅抄。 同寝室的蓝天朗5点钟不到就起床了，跑到阳台上看什么有限群论基础的小黄书。 7:00不到就和大家出去了。在校园里逛了逛，慈溪中学真的挺大的。 食堂7:30才开门，咕到7:40才有早饭吃。 所谓牛奶只是一小盒酸奶而已。但是包子是真的大，两个肉包一个菜包，蒟蒻我吃了一个肉包就饱了，剩下的想给闪总，但是闪总也不要了。 然后去机房，今天换了一个机房，美帝良心想的台式机，还是i3-6100，尝试开WTG，居然成功了，但是被老师拔了。 早上听神仙讲课，讲斜率优化和决策单调性，基本上还是可以听懂的。 但是因为空调没有效果，机房里太热，老师只好让大家先出去，等空调好了再进来，耽搁了好多时间。 11:30去食堂吃盒饭。 下午模拟赛。 T2是个裸的字典树，做过原题，我还以题看错了，再三确认过题目没看错，半个多小时码好代码并对拍，还是比较轻松的。 然后搞T1和T3，但是写了暴力之后就搞不来了，预计分数只有160。 16:30考完之后还莫得吃饭，又在校园里逛了一下。 晚饭同样盒饭。 回去之后看了成绩，160，没毛病。 晚上继续讲课，把早上没讲完的讲了，然后自己做了一下一道斜率优化的题目：[JSOI2011]柠檬，但是因为我太菜了，最后没有调出来。 回寝室之后，老叶来了一下，说我考号写错了，还只考了几十分。后来想想，应该是座位坐错了，然后和边上的人考号搞错了，血亏。 Day3-2019.08.07集训第二天。 早上依旧早起补作业。 后来吃过早饭之后还去了一下5号楼，那里有自动贩卖机，买了瓶饮料。 早上听讲课，讲什么树上信息维护，基本能听懂。 下午考试。 看完题目之后，感觉T3非常可做。T3就是每次给你一个长度为32字符串，问你之前有没有出现过这个字符串。但是内存只给了2MB，按照一般写法拿来双哈希+map肯定MLE。但是时限很宽松，6s，所以我直接重开文件然后先模小一点的数哈希然后分组开邻接表处理再模大质数做到双哈希，这样就基本上不可能卡掉了。 然后尝试对拍，写了个双哈希+map，结果小数据拍不停，n一上到300000左右就挂。后来查了半天，才发现是用来对拍的双哈希不小心写挂了，实际效果和单哈希一样，WA是因为哈希撞车了。 最后内存大概控制在了1.94MB，开O2的话跑得还是挺快的，就是希望内存不要炸，好像不同操作系统下空跑程序的内存不同。 然后这题前前后后一共搞了两个半小时，T1和T2随便写了一下就交卷了。 晚上看了下成绩，发现T3 WA了一个点。一看数据，n后面漏了一个换行，改掉就过了。 今天总分150。 晚上听了讲课，知道了T3应该是一个叫做什么布隆过滤器的玄学算法。实测空间必须开到顶到天才能过，正确率堪忧，还没我的重开文件分组哈希好用。 T2是一个比较简单的数学题，但是我实在是太菜了，而且考场上也没多少时间去试去想，就GG了。最后推出来是一个很简单的式子。 晚上回寝室之后，还和闪总他们玩了一盘20圈。 晚上闪总还和蓝天朗争论，说了好多句比如“那是因为你菜”、“那你是傻逼”之类的话，不过手机收了，没录下来，可惜了。 Day4-2019.08.08早上依旧5:30左右起床补焚化课作业。 今天早上讲概率和期望相关，我这方面学得很差，正好补补。 下午考试。T1一眼看去比较可做，但是想了很多个贪心都被自己叉掉了，最后还是写了边上鲁永杰神仙的贪心。 T2不怎么会做，于是就写了个$O(n^2)$的然后优了一道，实测随机数据下跑得很快，但是如果给个过度有序的序列的话直接GG。 T3写了个预计60分的暴力，不管了。 评测结果还没有出看到，出题人先把大家全部交到一个教室讲题。先讲了T3，因为出题人认为T3最水。出题人先讲了我上去讲60分怎么做，我讲了一下做法，小赖的时候瞄了一眼T1、T2，发现竟然都过了，数据太水了。 然后讲T1，是上个月CC月赛的原题，标算是把$O(n^3)$的暴力DP通过斜率优化搞到$O(n^2)$。出题人还让我上去分享了一下错误的做法，我顺便还给了一组hack数据。 这次是三个学校在一起讲题，绝大部分上台分享的学生都是衢二的，突然感觉自己学校好强，只有我一个人这么菜。 晚上又是玩20全，但是被小叶打断了。 Day5-2019.08.09早上又是早起补焚化课，终于把语文作业敷衍完了。这个时候窗外下了几滴雨。然后又是一群人围在一起玩20圈。 早上讲课讲搜索，讲到一半老师突然说要我们衢州和义务的去搬一下寝室，搬到了5-402，顺便和陈指导换了一下铺位，前后一共折腾了很久，这个时候风已经挺大了。 回去继续听讲课，出题人竟然把课讲完了。 下午是考试。T1题面里说是莫比乌斯反演，我先尝试推了一下，但是我太菜了。后来写了暴力，试了下$n=2000,m=2000$这组数据，发现$ans=4000000=nm$，我以为是巧合，又试了几组，发现都有$ans=nm%p$，我又怀疑是不是暴力写挂了，检查过确定没挂后，对拍了一下，竟然拍不停？？？我*。后面两题写了暴力之后干脆弃疗打CC。 考试结束之后，老师又突然宣布说明后天台风要来，而且风力很大，让我们所有衢州和义务的人住到酒店去，不能留在学校，这样万一出了事故慈溪中学就没有责任了。 准备去吃饭，吃饭的时候发现雨伞杆都弯了，应该是刚才风吹的。吃过饭回寝室收拾好东西之后就和大家一起上车去宾馆，到了一个什么“恒元广场酒店”。这次和鲁永卓在一个房间。一楼大堂有一个小饮水机，按不同的按钮可以出冰水、苏打水和常温水。喝了一点苏打水，喝起来和快乐水是一个感觉。 刚才上车的时候，看小叶一手轻松，就不太对了，果然小叶没有把大家的手机拿过来。那这两天又没机子又没砖，难受死了，我宁可在学校里被各路神仙吊打，这该死的台风。 由于房间分布比较乱，大家想找到彼此都不容易，终于凑够了人，大家记了一下彼此的房间号后便聚在闪总的房间玩20圈，哥哥陈浩杰也一起参与了。 回房间之后写了会儿作业，洗了澡就睡了。没设备也干不了啥。 Day6-2019.08.10早上起来之后，看了下外面，风的确挺大的。外面的树一直在摇，而且已经有两棵树被风挂倒在地上。 7:00吃早饭，感觉海星。回了下自己房间后8:30去会议室听课。早上楼持恒讲数位DP和状压DP，有好几道题做过。中途下课的时候和蓝天朗被阿了，不过一点感觉都没有。 中午吃盒饭，顺便来了几局20圈。 下午13:30，法老将网络流，还是能听懂的。 晚上又是聚集在闪总的房间玩20圈。中途哥哥陈浩杰和刘迅也来了，哥哥参与了，刘迅在边上看。这局我是狼人，不知道怎么的第一回合就把哥哥杀了。感觉自己犯下了滔天大罪。 然后回房间洗衣服，后来和鲁永卓一起出题。明天早上就能回去了，说是有两场考试。 Day7-2019.08.11昨晚睡觉迟了一些，今天起床也晚了一些。早上7:00吃早饭，吃好之后回房间检查了一下，确保能嫖的东西都嫖了。顺便去了一下YBX的房间，本来想看看他们嫖干净没有，结果发现他们才刚起。 8:30出发走路回学校，还是有点远的，走了挺久的。路上听陈指导说他和闪指导昨晚看相亲节目，还看到一个人很像廖XX。 到了学校直接去机房考试，没有回寝室。考BZT出的题，只考了两个多小时。T3是个分块，写掉了，T1、T2只写了暴力和一些部分分。预计140。 下午继续考试，T1写了一个十分暴力的DP，反正复杂度能过。T2我感觉还是比较可做的，开了很多bitset瞎搞。T3写不来交暴力。 考完之后和同学讨论了一下，发现T1枚举的范围太小了，于是要GG。T2问了一圈没人做法和我一样。感觉要凉。 晚上先是法老讲题，我看了一下成绩，T1 70分，还好没炸完，T2过了，T3 30分。 讲题的时候发现徐本周T2做法和我一样。T3做法很多，团子也上去讲了一种。 然后是BZT讲题，听说很多人不知道是什么原因T3挂掉了。我没看到成绩，感觉要凉凉。T1、T2是两个DP。这套卷子比较毒瘤，所以一群人想阿BZT。 然后先是打了一下CC，然后和大家一起打CF。CC月赛马上就要结束了，为了不掉分，干脆就不交了。CF的前3题还是比较好过的，T2不小心WA了一发，D题三个前缀和一搞即可。不知道结束之后前面会不会有题WA。 最后没什么时间了，就回寝了。 Day8-2019.08.12早上去机房先看了一眼CF，昨天的4题都过了。又看了一下E，和昨天一样感觉很可做，但是昨天听徐本周却说要开什么平衡树，我搞不明白为什么，按照自己的想法做，结果就过了。 然后法老讲网络流。 中午在食堂吃饭，慈溪中学基本上开学了。食堂里菜价较贵而且差价较大，一个荤菜要6~8块钱。吃饭后去小卖部买快乐水，￥2.7，挺便宜的。 下午考试。T1一开始想到应该可以二分+贪心，但是一看数据范围很小就感觉很假，但是对拍了很久并没有出问题。后面做不来，打暴力。 考完后发现T2是个傻逼题，我暴力还写挂了，于是只有150，完了因为要被老叶踢掉了。 听法老讲完之后感觉今天试卷很简单，陈指导都AK了，我是真的菜。 Day9-2019.08.13今天早上楼持恒讲构造题。 下午模拟赛，T1比较简单，写好+对拍一共用了一个多小时。T2、T3做不来，写暴力。 楼持恒和楼家宁先跑了，晚上BZT讲题。然后发现T3是个傻逼题，我还是做不来。T2最高80分，好像题面锅了。今天只有190，T3暴力写挂了。 Day10-2019.08.14今天早上周亦然讲树形DP、仙人掌和数值积分。 下午考试，T1写了个$O(n^2)$的记搜。T2写了个2-SAT。都拍过了。应该没有什么问题。 T3是个限制条件比较多的数论，一个不小心就这个数没有逆元那个数又没有逆元。只写了暴力，预计220。 晚上讲题看到自己236，最后一题无解比较多，骗到好多分。T3是个exBSGS。讲完之后发现这题卡常，弄了好一会儿才在没有开__int128的前提下过了。 Day11-2019.08.15今天早上讲交互题，比较有趣。然后又讲了几道DP。 下午考试，T1想了一会儿之后写了一个二分+贪心，感觉这种题以前在ZS那里做的比较多。 T2是个数学题，建模之后发现是个K维偏序问题，K最大可以到20，当场崩溃。当模数$p&gt;100$时只有1~3维，直接上CDQ，不知道能不能骗到分。 T3来不及写了，交暴力。 最后只有170，我可真菜。 晚上讲完题自己订正，T2之前建的模型并没有错，只是当维数变大的时候每一位的数值会变小，所以直接高维前缀和即可。之前不会这个东西，学了一下，感觉不是很难。 T3的话用线段树维护转移矩阵即可。 Day12-2019.08.16今天早上按照昨天和室友的约定，5:00准时起床打双扣。闪总一下子起不来，就到隔壁叫了陈队长。 早上讲课，讲了生成函数与Pólya计数，没听懂多少。 下午考试，T1的题目名是“明天是个好日子”，模数被改成了19260817。一开始想找规律，有个规律看起来挺对的，但是数字一大就WA，只好交暴力。 T2维护括号序列，弄个线段树再套个二分即可，两个log。 T3不会，写大暴力。 最后得分161。 晚上讲题再订正，发现T1的那个规律是对的，暴力写挂了，于是用假的数据把自己叉掉了，血亏。T2过了，T3只需要发现序列长度非常小，是log级的之后然后开个堆搞一下就行了。 Day13-2019.08.17今天是个好日子！ 早上起来先收拾东西打扫寝室，然后把东西全带去了机房隔壁教室。 早上将插头DP和一些杂题，能挺懂一些。 由于今天下午要回衢州了，所以考试10:30就开始了。 今天考试是ACM赛制，好玩。 A题给你两个小数点后还有九位的小数让你求出取模后的结果。直接上double炸精度，于是开了个long long。这题做的有点慢了，不过好在1A。 然后做G题，由于重边没判好，WA了3发，血亏。 然后做I题，求S到T的最短路，路径的长度定义为进过的边权的OR和。直接从高位开始考虑，并查集判断连通性。写到一半去吃饭，本来不想去吃的，但是卡里还有和鲁永杰、陈队长一起充的钱，不花掉血亏，吃饭之后马上去小店买了些东西把钱刷光。 回来继续写I题，写完直接交，运气挺好，1A。 然后做B，5个属性分别排序之后模拟贪心，运气可以，又1A。 然后做D，一个数位DP，还是比较水的，直接记搜，一开始样例没过，调过之后又1A，感觉今天欧气慢慢。 然后又在剩下的几道题中看了看，感觉交互题H很可做。就是让你猜一个长度为$n$的01串，只会在你全猜对或者刚好对了一般的时候返回信息，否则只会返回0。我感性理解了一下觉得随机生成一个随机序列恰好猜中一半的概率还是挺大的。实测几十次就能猜中。然后就好搞了。交了两次才过，第一次是因为不太会玩交互然后出了一个什么奇奇怪怪的错误。 一共AC了6题，今天比较欧，法师很少，最后就躺上rank1了？？？ 然后就带上东西上了大巴车回家。上了高速之后没开多久就堵住了，好像前面有事故。不过还好堵得时间不是很长。 中途在东阳服务区停了车下去吃饭，和鲁永杰、陈队长一起吃了中午在小店里买的汉堡和饼干什么的，不用在服务区大出血了。 晚上快到20:00才到衢州，看到二中大门口已经装修好了，还挺漂亮。在慈溪中学十二天的被吊打生活这么快就结束了。]]></content>
      <categories>
        <category>游记</category>
      </categories>
      <tags>
        <tag>游记</tag>
        <tag>慈溪中学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「CF452F」Permutation]]></title>
    <url>%2F2019%2F08%2F02%2F%E3%80%8CCF452F%E3%80%8DPermutation-Solution%2F</url>
    <content type="text"><![CDATA[等差数列？再见！ 传送门洛谷 CF452F 题解对于一个三元组$A_i,A_j,A_k(i&lt;j&lt;k)$，如果它们构成等差数列，当且仅当有$A_k-A_j=A_j-A_i$。 考虑枚举中间的$j$，如果再枚举一个数$x$，如果$x$与$A_$存在并且在原排列中$A_j$的不同侧，那么就构成了一个等差的子序列。 所以可以再维护一个01序列，第$i$位上为0表示数字$i$在原序列中的位置小于$j$，否则大于$j$。 如果原序列中不存在三元等差数列，那么这个01序列应该是以$A_j$为中心左右对称的（可能有一端会多出来一截，忽略即可）。 每次$j$变化时，01序列上只有一个位置发生了变化，线段树维护一个正反的哈希值即可。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;typedef long long LL;const int maxn=300005,TT=1000000007;int n,Pow[maxn];bool ans;inline int read()&#123; int ret=0,f=1;char ch=getchar(); while(ch&lt;'0'||ch&gt;'9')&#123;if(ch=='-')f=-f;ch=getchar();&#125; while(ch&gt;='0'&amp;&amp;ch&lt;='9')&#123;ret=ret*10+ch-'0';ch=getchar();&#125; return ret*f;&#125;struct SegmentTree&#123; struct Node&#123;int Hash1,Hash2,len;&#125;Tree[maxn*4]; inline Node Merge(const Node&amp; a,const Node&amp; b)&#123;return (Node)&#123;(int)((LL)a.Hash1*Pow[b.len]%TT+b.Hash1)%TT,(int)((LL)b.Hash2*Pow[a.len]%TT+a.Hash2)%TT,a.len+b.len&#125;;&#125; inline void PushUp(int rt)&#123;Tree[rt]=Merge(Tree[rt*2],Tree[rt*2+1]);&#125; void Build(int L=1,int R=n,int rt=1) &#123; if(L==R)&#123;Tree[rt].len=1;return;&#125; int M=(L+R)&gt;&gt;1; Build(L,M,rt*2); Build(M+1,R,rt*2+1); PushUp(rt); &#125; void UpdatePoint(int P,int L=1,int R=n,int rt=1) &#123; if(L==R)&#123;Tree[rt].Hash1=Tree[rt].Hash2=1;return;&#125; int M=(L+R)&gt;&gt;1; if(P&lt;=M) UpdatePoint(P,L,M,rt*2); if(M&lt;P) UpdatePoint(P,M+1,R,rt*2+1); PushUp(rt); &#125; Node RangeQuery(int LL,int RR,int L=1,int R=n,int rt=1) &#123; if(LL&lt;=L&amp;&amp;R&lt;=RR) return Tree[rt]; int M=(L+R)&gt;&gt;1;Node ret=(Node)&#123;0,0,0&#125;; if(LL&lt;=M) ret=RangeQuery(LL,RR,L,M,rt*2); if(M&lt;RR) ret=Merge(ret,RangeQuery(LL,RR,M+1,R,rt*2+1)); return ret; &#125;&#125;ST;int main()&#123; n=read();Pow[0]=1; for(int i=1;i&lt;=n;i++) Pow[i]=Pow[i-1]*2%TT; ST.Build(); for(int i=1;i&lt;=n;i++) &#123; int Pi=read(),len=min(n-Pi+1,Pi); ST.UpdatePoint(Pi); if(ST.RangeQuery(Pi-len+1,Pi).Hash1!=ST.RangeQuery(Pi,Pi+len-1).Hash2)&#123;ans=true;break;&#125; &#125; printf("%s\n",ans?"YES":"NO"); return 0;&#125;]]></content>
      <categories>
        <category>线段树</category>
      </categories>
      <tags>
        <tag>哈希</tag>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Ynoi2019模拟赛」Yuno loves sqrt technology III]]></title>
    <url>%2F2019%2F08%2F02%2F%E3%80%8CYnoi2019%E6%A8%A1%E6%8B%9F%E8%B5%9B%E3%80%8DYuno-loves-sqrt-technology-III-Solution%2F</url>
    <content type="text"><![CDATA[sqrt technology？ 传送门洛谷P5048 题解题目名字告诉你应该用分块。 首先可以$O(n\sqrt{n})$地预处理出块与块之间的众数的出现次数。 然后对于每一种数字，开一个vector，存下每次出现的位置。 并记录下每个位置的数字在vector中的下标。 询问的时候，中间完整的几块直接调用预处理出的出现次数，把这个出现次数作为答案的初值。 然后考虑两边不完整的块该如何处理。 设询问的区间为$[L,R]$，先考虑左侧不完整的块，设$pos[i][j]$表示数字$i$第$j$次出现时在原序列中的位置。$vec[i]$表示第$i$个位置上的数字在$pos$数组中的第二个下标，如果满足$pos[A[i]][vec[i]+ans]&lt;=R$，那么说明当前的答案偏小了，执行$ans++$。右侧同样处理。 总时间复杂度仍为$O(n\sqrt{n})$。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102#include&lt;map&gt;#include&lt;cmath&gt;#include&lt;vector&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;const int maxn=500005;int n,m,S,A[maxn],B[maxn],cnt[710][710],hsh[maxn],Area[maxn],vec[maxn],ans;vector&lt;int&gt; pos[maxn];struct FastIO&#123; static const int S=1048576; char buf[S],*L,*R;int stk[20],Top; ~FastIO()&#123;clear();&#125; inline char nc()&#123;return L==R&amp;&amp;(R=(L=buf)+fread(buf,1,S,stdin),L==R)?EOF:*L++;&#125; inline void clear()&#123;fwrite(buf,1,Top,stdout);Top=0;&#125; inline void pc(char ch)&#123;Top==S&amp;&amp;(clear(),0);buf[Top++]=ch;&#125; template&lt;typename _Tp&gt; FastIO&amp; operator &gt;&gt; (_Tp&amp; ret) &#123; ret=0;int f=1;char ch=nc(); while(ch&lt;'0'||ch&gt;'9')&#123;if(ch=='-')f=-f;ch=nc();&#125; while(ch&gt;='0'&amp;&amp;ch&lt;='9')&#123;ret=ret*10+ch-'0';ch=nc();&#125; ret*=f;return *this; &#125; FastIO&amp; operator &lt;&lt; (int x) &#123; if(x&lt;0)&#123;pc('-');x=-x;&#125; do&#123;stk[++stk[0]]=x%10;x/=10;&#125;while(x); while(stk[0]) pc('0'+stk[stk[0]--]); return *this; &#125; FastIO&amp; operator &lt;&lt; (char ch)&#123;pc(ch);return *this;&#125;&#125;fin,fout;inline void Discretization()&#123; map&lt;int,int&gt; hsh; for(int i=1;i&lt;=n;i++) B[i]=A[i]; sort(B+1,B+1+n); int len=unique(B+1,B+1+n)-B-1; for(int i=1;i&lt;=len;i++) hsh[B[i]]=i; for(int i=1;i&lt;=len;i++) pos[i].push_back(0); for(int i=1;i&lt;=n;i++) A[i]=hsh[A[i]];&#125;inline void Init()&#123; for(int i=1;i&lt;=n;i++) Area[i]=(i-1)/S+1; for(int i=1;i&lt;=Area[n];i++) &#123; int now=0; for(int j=i;j&lt;=Area[n];j++) &#123; for(int k=(j-1)*S+1;Area[k]==j;k++) &#123; hsh[A[k]]++; if(hsh[A[k]]&gt;now) now=hsh[A[k]]; &#125; cnt[i][j]=now; &#125; memset(hsh,0,sizeof(hsh)); &#125; for(int i=1;i&lt;=n;i++) &#123; pos[A[i]].push_back(i); vec[i]=pos[A[i]].size()-1; &#125;&#125;inline int Solve(int L,int R)&#123; int ret=cnt[Area[L]+1][Area[R]-1]; if(Area[R]-Area[L]&lt;=1) &#123; for(int i=L;i&lt;=R;i++) &#123; hsh[A[i]]++; if(hsh[A[i]]&gt;ret) ret=hsh[A[i]]; &#125; for(int i=L;i&lt;=R;i++) hsh[A[i]]=0; return ret; &#125; for(int i=L;Area[i]==Area[L];i++) while(vec[i]+ret&lt;(int)pos[A[i]].size()&amp;&amp;pos[A[i]][vec[i]+ret]&lt;=R) ret++; for(int i=R;Area[i]==Area[R];i--) while(vec[i]-ret&gt;0&amp;&amp;pos[A[i]][vec[i]-ret]&gt;=L) ret++; return ret;&#125;int main()&#123; fin&gt;&gt;n&gt;&gt;m;S=sqrt(n)+1e-10; for(int i=1;i&lt;=n;i++) fin&gt;&gt;A[i]; Discretization(); Init(); while(m--) &#123; int L,R;fin&gt;&gt;L&gt;&gt;R; ans=Solve(L^ans,R^ans); fout&lt;&lt;ans&lt;&lt;'\n'; &#125; return 0;&#125;]]></content>
      <categories>
        <category>分块</category>
      </categories>
      <tags>
        <tag>分块</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Violet」天使玩偶/SJY摆棋子]]></title>
    <url>%2F2019%2F07%2F29%2F%E3%80%8CViolet%E3%80%8D%E5%A4%A9%E4%BD%BF%E7%8E%A9%E5%81%B6%20SJY%E6%91%86%E6%A3%8B%E5%AD%90-Solution%2F</url>
    <content type="text"><![CDATA[卡常CDQ？难受！ 传送门洛谷P4169 BZOJ2716 题解首先，如果没有计算距离的式子里没有绝对值的话，那么就可以把每个玩偶的权值定为X+Y，然后对于每一次询问，找一个满足要求且权值最大的即可。这个可以通过CDQ分治实现。 由于有绝对值，所以需要拆分成四种情况来考虑。 然后常数就上天了。 适当卡常就能过了。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;const int maxn=1000005,inf=0x3F3F3F3F;int n,m,q,ans[500005],len,Tree[maxn],MX,MY;struct FastIO&#123; static const int S=16777216; char buf[S],*L,*R;int stk[20],Top; ~FastIO()&#123;clear();&#125; inline char nc()&#123;return L==R&amp;&amp;(R=(L=buf)+fread(buf,1,S,stdin),L==R)?EOF:*L++;&#125; inline void clear()&#123;fwrite(buf,1,Top,stdout);Top=0;&#125; inline void pc(char ch)&#123;Top==S&amp;&amp;(clear(),0);buf[Top++]=ch;&#125; FastIO&amp; operator &gt;&gt; (int&amp; ret) &#123; ret=0;int f=1;char ch=nc(); while(ch&lt;'0'||ch&gt;'9')&#123;if(ch=='-')f=-f;ch=nc();&#125; while(ch&gt;='0'&amp;&amp;ch&lt;='9')&#123;ret=ret*10+ch-'0';ch=nc();&#125; return *this; &#125; FastIO&amp; operator &lt;&lt; (int x) &#123; if(x&lt;0)&#123;pc('-');x=-x;&#125; do&#123;stk[++stk[0]]=x%10;x/=10;&#125;while(x); while(stk[0]) pc('0'+stk[stk[0]--]); return *this; &#125; FastIO&amp; operator &lt;&lt; (char ch)&#123;pc(ch);return *this;&#125;&#125;fin,fout;inline void Update(int pos,int val)&#123;while(pos&lt;=1000000)&#123;if(val&gt;Tree[pos]) Tree[pos]=val;pos+=pos&amp;-pos;&#125;&#125;inline int Query(int pos)&#123;int ret=-inf;while(pos&gt;0)&#123;if(Tree[pos]&gt;ret) ret=Tree[pos];pos-=pos&amp;-pos;&#125;return ret;&#125;inline void Build()&#123;for(int i=0;i&lt;=1000000;i++) Tree[i]=-inf;&#125;inline void Del(int pos)&#123;while(pos&lt;=1000000)&#123;Tree[pos]=-inf;pos+=pos&amp;-pos;&#125;&#125;struct Command&#123;int t,X,Y,typ,W,id;&#125;A[maxn],B[maxn],C[maxn];inline bool cmp1(const Command&amp; a,const Command&amp; b)&#123;return a.t&lt;b.t;&#125;inline bool cmp2(const Command&amp; a,const Command&amp; b)&#123;return a.X&lt;b.X||(a.X==b.X&amp;&amp;a.t&lt;b.t);&#125;void CDQ(int L,int R)&#123; if(L==R) return; register int M=(L+R)&gt;&gt;1,mid=A[M].t; CDQ(L,M);CDQ(M+1,R); merge(A+L,A+M+1,A+M+1,A+R+1,B+1,cmp2); memcpy(A+L,B+1,(R-L+1)*sizeof(Command)); for(register int i=L;i&lt;=R;i++) &#123; if(A[i].t&lt;=mid&amp;&amp;A[i].typ==1) Update(A[i].Y,A[i].X+A[i].Y); else if(A[i].t&gt;mid&amp;&amp;A[i].typ==2) A[i].W=min(A[i].W,A[i].X+A[i].Y-Query(A[i].Y)); &#125; for(register int i=L;i&lt;=R;i++) if(A[i].t&lt;=mid&amp;&amp;A[i].typ==1) Del(A[i].Y);&#125;inline void Init()&#123; int XM=0,YM=0;len=0; for(register int i=1;i&lt;=n+m;i++) if(C[i].typ==2)&#123;if(C[i].X&gt;XM) XM=C[i].X;if(C[i].Y&gt;YM) YM=C[i].Y;&#125; for(register int i=1;i&lt;=n+m;i++) if(C[i].X&lt;=XM&amp;&amp;C[i].Y&lt;=YM) A[++len]=C[i]; sort(A+1,A+1+len,cmp1);&#125;inline void Update()&#123;for(int i=1;i&lt;=len;i++) if(A[i].W&lt;ans[A[i].id]) ans[A[i].id]=A[i].W;&#125;inline void Solve()&#123; memset(ans,63,sizeof(ans)); memcpy(C,A,sizeof(Command)*(n+m+3)); Init();CDQ(1,len);Update(); for(register int i=1;i&lt;=n+m;i++) C[i].X=MX-C[i].X; Init();CDQ(1,len);Update(); for(register int i=1;i&lt;=n+m;i++) C[i].Y=MY-C[i].Y; Init();CDQ(1,len);Update(); for(register int i=1;i&lt;=n+m;i++) C[i].X=MX-C[i].X; Init();CDQ(1,len);Update();&#125;int main()&#123; fin&gt;&gt;n&gt;&gt;m; for(register int i=1;i&lt;=n;i++) &#123; fin&gt;&gt;A[i].X&gt;&gt;A[i].Y; A[i].X++;A[i].Y++; A[i].typ=1;A[i].t=i; if(A[i].X&gt;MX) MX=A[i].X; if(A[i].Y&gt;MY) MY=A[i].Y; &#125; for(register int i=n+1;i&lt;=m+n;i++) &#123; fin&gt;&gt;A[i].typ&gt;&gt;A[i].X&gt;&gt;A[i].Y;A[i].t=i; A[i].X++;A[i].Y++; if(A[i].X&gt;MX) MX=A[i].X; if(A[i].Y&gt;MY) MY=A[i].Y; if(A[i].typ==2)&#123;A[i].id=++q;A[i].W=inf;&#125; &#125; MX++;MY++; Build(); Solve(); for(int i=1;i&lt;=q;i++) fout&lt;&lt;ans[i]&lt;&lt;'\n'; return 0;&#125;]]></content>
      <categories>
        <category>CDQ分治</category>
      </categories>
      <tags>
        <tag>CDQ分治</tag>
        <tag>树状数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「AHOI2013」连通图]]></title>
    <url>%2F2019%2F07%2F27%2F%E3%80%8CAHOI2013%E3%80%8D%E8%BF%9E%E9%80%9A%E5%9B%BE-Solution%2F</url>
    <content type="text"><![CDATA[随机？哈希？ 传送门洛谷P5227 BZOJ3237 题解首先，按照套路，先随便求出原图的一棵生成树。 对于每一条非树边，我们给他随机rand一个随机数作为哈希值。 对于每一条树边，定义它的哈希值为所有覆盖它的非树边的哈希值的异或和。 对于一个边的集合，定义它的哈希值为它所包含的所有边的哈希值的异或和。 对于任意一个给定的删边集合，如果存在一个全部由树边构成的子集的哈希值等于某一个全部由非树边构成的子集的哈希值，那么删了该集合中所有边之后，原图不连通。由于给定的删边集合很小，暴力枚举子集即可。 为了保证正确性，采取双哈希会比较合适。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;algorithm&gt;using namespace std;typedef unsigned long long ULL;const int maxn=100005,maxm=200005;int n,m,Q,tot,lnk[maxn],son[maxn*2],nxt[maxn*2],id[maxn*2],fa[maxn];struct FastIO&#123; static const int S=131072; char buf[S],*L,*R;int Top; ~FastIO()&#123;clear();&#125; inline char nc()&#123;return L==R&amp;&amp;(R=(L=buf)+fread(buf,1,S,stdin),L==R)?EOF:*L++;&#125; inline void clear()&#123;fwrite(buf,1,Top,stdout);Top=0;&#125; inline void pc(char ch)&#123;Top==S&amp;&amp;(clear(),0);buf[Top++]=ch;&#125; FastIO&amp; operator &gt;&gt; (int&amp; ret) &#123; ret=0;int f=1;char ch=nc(); while(ch&lt;'0'||ch&gt;'9')&#123;if(ch=='-')f=-f;ch=nc();&#125; while(ch&gt;='0'&amp;&amp;ch&lt;='9')&#123;ret=ret*10+ch-'0';ch=nc();&#125; return *this; &#125; FastIO&amp; operator &lt;&lt; (char ch)&#123;pc(ch);return *this;&#125; FastIO&amp; operator &lt;&lt; (const char* S)&#123;for(int i=0;S[i];i++) pc(S[i]);return *this;&#125;&#125;fin,fout;struct Hash&#123; ULL V1,V2; Hash(ULL a=0,ULL b=0):V1(a),V2(b)&#123;&#125; inline void Init() &#123; V1=(ULL)rand()*rand()*rand()*rand()*rand(); V2=(ULL)rand()*rand()*rand()*rand()*rand(); &#125; Hash operator ^ (const Hash&amp; b)const&#123;return (Hash)&#123;V1^b.V1,V2^b.V2&#125;;&#125; bool operator == (const Hash&amp; b)const&#123;return V1==b.V1&amp;&amp;V2==b.V2;&#125;&#125;F[maxn];struct Edge&#123;int u,v;bool used;Hash w;&#125;E[maxm];inline void add_e(int x,int y,int z)&#123;tot++;son[tot]=y;id[tot]=z;nxt[tot]=lnk[x];lnk[x]=tot;&#125;inline int getfa(int x)&#123;return fa[x]==x?x:fa[x]=getfa(fa[x]);&#125;void Calc(int now,int fa)&#123; for(int i=lnk[now];i;i=nxt[i]) &#123; if(son[i]!=fa) &#123; Calc(son[i],now); F[now]=F[now]^F[son[i]]; E[id[i]].w=F[son[i]]; &#125; &#125;&#125;inline void Build()&#123; for(int i=1;i&lt;=n;i++) fa[i]=i; for(int i=1;i&lt;=m;i++) &#123; if(getfa(E[i].u)!=getfa(E[i].v)) &#123; fa[fa[E[i].u]]=fa[E[i].v]; E[i].used=true; add_e(E[i].u,E[i].v,i); add_e(E[i].v,E[i].u,i); &#125; &#125; for(int i=1;i&lt;=m;i++) &#123; if(!E[i].used) &#123; E[i].w.Init(); F[E[i].u]=F[E[i].u]^E[i].w; F[E[i].v]=F[E[i].v]^E[i].w; &#125; &#125; Calc(1,0);&#125;int main()&#123; srand(20020222); fin&gt;&gt;n&gt;&gt;m; for(int i=1;i&lt;=m;i++) fin&gt;&gt;E[i].u&gt;&gt;E[i].v; Build(); fin&gt;&gt;Q; while(Q--) &#123; int c,S[6]=&#123;0&#125;;bool con=true; fin&gt;&gt;c; for(int i=1;i&lt;=c;i++) fin&gt;&gt;S[i]; for(int i=1;i&lt;(1&lt;&lt;c)&amp;&amp;con;i++) &#123; Hash nw,tw; for(int j=1;j&lt;=c;j++) if((i&amp;(1&lt;&lt;(j-1)))&amp;&amp;!E[S[j]].used) nw=nw^E[S[j]].w; for(int j=1;j&lt;=c;j++) if((i&amp;(1&lt;&lt;(j-1)))&amp;&amp;E[S[j]].used) tw=tw^E[S[j]].w; if(nw==tw) con=false; &#125; fout&lt;&lt;(con?"Connected":"Disconnected")&lt;&lt;'\n'; &#125; return 0;&#125;]]></content>
      <categories>
        <category>哈希</category>
      </categories>
      <tags>
        <tag>随机</tag>
        <tag>哈希</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Gty」Gty的二逼妹子序列]]></title>
    <url>%2F2019%2F07%2F26%2F%E3%80%8CGty%E3%80%8DGty%E7%9A%84%E4%BA%8C%E9%80%BC%E5%A6%B9%E5%AD%90%E5%BA%8F%E5%88%97-Solution%2F</url>
    <content type="text"><![CDATA[莫队？分块？两个一起来。 传送门洛谷P4867 题解看到这种题目，很显然，是一个莫队。 但是这道题的每一个询问有两个限制区间。 所以，还需要再来一个分块来统计答案。 然后就好了，注意常数即可。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;const int maxn=100005,maxm=1000005;int n,m,S,A[maxn],Area[maxn],ans[maxm],cnt[400],hsh[maxn];struct FastIO&#123; static const int S=131072; char buf[S],*L,*R;int stk[20],Top; ~FastIO()&#123;clear();&#125; inline char nc()&#123;return L==R&amp;&amp;(R=(L=buf)+fread(buf,1,S,stdin),L==R)?EOF:*L++;&#125; inline void clear()&#123;fwrite(buf,1,Top,stdout);Top=0;&#125; inline void pc(char ch)&#123;Top==S&amp;&amp;(clear(),0);buf[Top++]=ch;&#125; FastIO&amp; operator &gt;&gt; (int&amp; ret) &#123; ret=0;int f=1;char ch=nc(); while(ch&lt;'0'||ch&gt;'9')&#123;if(ch=='-')f=-f;ch=nc();&#125; while(ch&gt;='0'&amp;&amp;ch&lt;='9')&#123;ret=ret*10+ch-'0';ch=nc();&#125; return *this; &#125; FastIO&amp; operator &lt;&lt; (int x) &#123; if(x&lt;0)&#123;pc('-');x=-x;&#125; do&#123;stk[++stk[0]]=x%10;x/=10;&#125;while(x); while(stk[0]) pc('0'+stk[stk[0]--]); return *this; &#125; FastIO&amp; operator &lt;&lt; (char ch)&#123;pc(ch);return *this;&#125;&#125;fin,fout;struct Query&#123; int L,R,a,b,id; bool operator &lt; (const Query&amp; b)const&#123;return Area[L]&lt;Area[b.L]||(Area[L]==Area[b.L]&amp;&amp;((Area[L]&amp;1)?R&lt;b.R:R&gt;b.R));&#125;&#125;Q[maxm];inline void inc(int x)&#123;if(!hsh[x]++) cnt[Area[x]]++;&#125;inline void dec(int x)&#123;if(!--hsh[x]) cnt[Area[x]]--;&#125;inline int Calc(int L,int R)&#123; int ret=0; if(Area[R]-Area[L]&lt;=1) &#123; for(int i=L;i&lt;=R;i++) if(hsh[i]) ret++; return ret; &#125; for(int i=L;Area[i]==Area[L];i++) if(hsh[i]) ret++; for(int i=Area[L]+1;i&lt;Area[R];i++) ret+=cnt[i]; for(int i=R;Area[i]==Area[R];i--) if(hsh[i]) ret++; return ret;&#125;inline void Solve()&#123; int L=1,R=0; for(int i=1;i&lt;=m;i++) &#123; while(R&lt;Q[i].R) inc(A[++R]); while(L&gt;Q[i].L) inc(A[--L]); while(R&gt;Q[i].R) dec(A[R--]); while(L&lt;Q[i].L) dec(A[L++]); ans[Q[i].id]=Calc(Q[i].a,Q[i].b); &#125;&#125;int main()&#123; fin&gt;&gt;n&gt;&gt;m;S=sqrt(n)+1e-10; for(int i=1;i&lt;=n;i++) fin&gt;&gt;A[i]; for(int i=1;i&lt;=n;i++) Area[i]=(i-1)/S+1; for(int i=1;i&lt;=m;i++) &#123; fin&gt;&gt;Q[i].L&gt;&gt;Q[i].R&gt;&gt;Q[i].a&gt;&gt;Q[i].b; Q[i].id=i; &#125; sort(Q+1,Q+1+m); Solve(); for(int i=1;i&lt;=m;i++) fout&lt;&lt;ans[i]&lt;&lt;'\n'; return 0;&#125;]]></content>
      <categories>
        <category>莫队</category>
      </categories>
      <tags>
        <tag>莫队</tag>
        <tag>分块</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「CF280D」k-Maximum Subsequence Sum]]></title>
    <url>%2F2019%2F07%2F10%2F%E3%80%8CCF280D%E3%80%8Dk-Maximum-Subsequence-Sum-Solution%2F</url>
    <content type="text"><![CDATA[啥？线段树？还费用流？ 传送门洛谷 CF280D 题解首先可以考虑一个贪心，每次取询问区间内权值和最大的子段，然后把这个子段标记上，该次询问中不能再取。 但是这个想法并不对，比如序列$3,-1,3$，可以取至多2个子段。由于第一次会取权值最大的子段$[1,3]$，然后就没有子段可以取了。而实际上取$[1,1]$和$[3,3]$的话答案会更优。 然后不难联想到，在求最大流的时候，我们通过建反向弧的方式来保证了正确性。 所以对于这题，可以在取了一个子段之后，将改子段取反，之后还能再取，来保证正确性。 而取反和取最大值的操作都可以通过线段树来维护。 时间复杂度$O(n\log n+mk\log n)$。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;const int maxn=100005;int n,Q,A[maxn];inline int read()&#123; int ret=0,f=1;char ch=getchar(); while(ch&lt;'0'||ch&gt;'9')&#123;if(ch=='-')f=-f;ch=getchar();&#125; while(ch&gt;='0'&amp;&amp;ch&lt;='9')&#123;ret=ret*10+ch-'0';ch=getchar();&#125; return ret*f;&#125;struct Range&#123; int L,R,Sum; inline bool operator &lt; (const Range&amp; b)const&#123;return Sum&lt;b.Sum;&#125; inline Range operator + (const Range&amp; b)const&#123;return (Range)&#123;L,b.R,Sum+b.Sum&#125;;&#125;&#125;Ra[25];struct SegmentTree&#123; struct Node&#123;Range Lmax,Rmax,Max,Lmin,Rmin,Min,All;bool Tag;&#125;Tree[maxn*4]; inline void Merge(Node&amp; a,Node b,Node c) &#123; a.All=b.All+c.All; a.Lmin=min(b.Lmin,b.All+c.Lmin);a.Rmin=min(c.Rmin,b.Rmin+c.All); a.Lmax=max(b.Lmax,b.All+c.Lmax);a.Rmax=max(c.Rmax,b.Rmax+c.All); a.Max=max(max(b.Max,c.Max),b.Rmax+c.Lmax);a.Min=min(min(b.Min,c.Min),b.Rmin+c.Lmin); &#125; inline void PushUp(int rt)&#123;Merge(Tree[rt],Tree[rt*2],Tree[rt*2+1]);&#125; inline void Reverse(int rt) &#123; Tree[rt].Lmin.Sum*=-1;Tree[rt].Lmax.Sum*=-1; Tree[rt].Rmin.Sum*=-1;Tree[rt].Rmax.Sum*=-1; Tree[rt].Min.Sum*=-1;Tree[rt].Max.Sum*=-1;Tree[rt].All.Sum*=-1; swap(Tree[rt].Min,Tree[rt].Max);swap(Tree[rt].Lmax,Tree[rt].Lmin);swap(Tree[rt].Rmax,Tree[rt].Rmin); &#125; inline void PushDown(int rt) &#123; if(Tree[rt].Tag) &#123; Reverse(rt*2);Reverse(rt*2+1); Tree[rt*2].Tag^=1;Tree[rt*2+1].Tag^=1;Tree[rt].Tag^=1; &#125; &#125; inline void Build(int L=1,int R=n,int rt=1) &#123; if(L==R)&#123;Tree[rt].All=Tree[rt].Lmax=Tree[rt].Lmin=Tree[rt].Max=Tree[rt].Min=Tree[rt].Rmax=Tree[rt].Rmin=(Range)&#123;L,R,A[L]&#125;;return;&#125; int M=(L+R)&gt;&gt;1; Build(L,M,rt*2); Build(M+1,R,rt*2+1); PushUp(rt); &#125; inline void UpdatePoint(int P,int V,int L=1,int R=n,int rt=1) &#123; if(L==R)&#123;Tree[rt].All.Sum=Tree[rt].Lmax.Sum=Tree[rt].Lmin.Sum=Tree[rt].Max.Sum=Tree[rt].Min.Sum=Tree[rt].Rmax.Sum=Tree[rt].Rmin.Sum=V;return;&#125; int M=(L+R)&gt;&gt;1;PushDown(rt); if(P&lt;=M) UpdatePoint(P,V,L,M,rt*2); if(M&lt;P) UpdatePoint(P,V,M+1,R,rt*2+1); PushUp(rt); &#125; inline Node QueryMax(int LL,int RR,int L=1,int R=n,int rt=1) &#123; if(LL&lt;=L&amp;&amp;R&lt;=RR) return Tree[rt]; int M=(L+R)&gt;&gt;1;Node ret;PushDown(rt); if(LL&lt;=M) ret=QueryMax(LL,RR,L,M,rt*2); if(M&lt;RR) &#123; if(LL&gt;M) ret=QueryMax(LL,RR,M+1,R,rt*2+1); else Merge(ret,ret,QueryMax(LL,RR,M+1,R,rt*2+1)); &#125; return ret; &#125; inline void UpdateRange(int LL,int RR,int L=1,int R=n,int rt=1) &#123; if(LL&lt;=L&amp;&amp;R&lt;=RR)&#123;Reverse(rt);Tree[rt].Tag^=1;return;&#125; int M=(L+R)&gt;&gt;1;PushDown(rt); if(LL&lt;=M) UpdateRange(LL,RR,L,M,rt*2); if(M&lt;RR) UpdateRange(LL,RR,M+1,R,rt*2+1); PushUp(rt); &#125;&#125;S;int main()&#123; n=read(); for(int i=1;i&lt;=n;i++) A[i]=read(); Q=read();S.Build(); while(Q--) &#123; if(read()==0) &#123; int P=read(),V=read(); S.UpdatePoint(P,V); &#125; else &#123; int L=read(),R=read(),K=read(),cnt,ans=0; for(cnt=0;cnt&lt;K;cnt++) &#123; SegmentTree::Node tep=S.QueryMax(L,R); if(tep.Max.Sum&lt;=0) break; ans+=tep.Max.Sum; S.UpdateRange(tep.Max.L,tep.Max.R); Ra[cnt]=tep.Max; &#125; for(int i=0;i&lt;cnt;i++) S.UpdateRange(Ra[i].L,Ra[i].R); printf("%d\n",ans); &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>线段树模拟最大费用流</category>
      </categories>
      <tags>
        <tag>线段树</tag>
        <tag>费用流</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「洛谷P4212/BZOJ3632」外太空旅行]]></title>
    <url>%2F2019%2F07%2F09%2F%E3%80%8C%E6%B4%9B%E8%B0%B7P4212%20BZOJ3632%E3%80%8D%E5%A4%96%E5%A4%AA%E7%A9%BA%E6%97%85%E8%A1%8C-Solution%2F</url>
    <content type="text"><![CDATA[啥？NPC问题？模拟退火！！！ 传送门洛谷P4212 BZOJ3632 题解题目很明确就是要你求一个最大团。 但是最大团问题是一个NPC问题。 所以直接上模拟退火！ 先随机生成一个长度为$n$的排列，然后从前往后遍历，如果枚举到的点可以加入到当前的图中就加入。每次检验的复杂度为$O(n^2)$。每次退火的时候就随机交换排列的两个位置即可。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;algorithm&gt;using namespace std;const int maxn=505;const double delta=0.995;int n,m,P[maxn],ans;bool E[maxn][maxn];inline int Calc()&#123; static bool vis[maxn]; int ret=1;vis[P[1]]=true; for(int i=2;i&lt;=n;i++) &#123; bool flg=true; for(int j=1;j&lt;i;j++) if(vis[P[j]]&amp;&amp;!E[P[i]][P[j]]) &#123;flg=false;break;&#125; ret+=flg;vis[P[i]]=flg; &#125; if(ret&gt;ans) ans=ret; return ret;&#125;inline void SA(double T)&#123; random_shuffle(P+1,P+1+n); int cur=Calc(); while(T&gt;1e-3) &#123; int a=rand()%n+1,b=rand()%n+1; while(a==b)&#123;a=rand()%n+1;b=rand()%n+1;&#125; swap(P[a],P[b]); int ret=Calc(); if(ret&gt;cur) cur=ret; else if(exp((ret-cur)/T)&lt;(double)rand()/RAND_MAX) swap(P[a],P[b]); else cur=ret; T*=delta; &#125;&#125;int main()&#123; srand(20050413); scanf("%d",&amp;n); int a,b; while(scanf("%d%d",&amp;a,&amp;b)==2) E[a][b]=E[b][a]=true; for(int i=1;i&lt;=n;i++) P[i]=i; for(int i=1;i&lt;=100;i++) SA((20020222+20050413+20040302)*6.4); printf("%d\n",ans); return 0;&#125;]]></content>
      <categories>
        <category>模拟退火</category>
      </categories>
      <tags>
        <tag>随机算法</tag>
        <tag>模拟退火</tag>
        <tag>最大团</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「ZJOI2007」矩阵游戏]]></title>
    <url>%2F2019%2F07%2F07%2F%E3%80%8CZJOI2007%E3%80%8D%E7%9F%A9%E9%98%B5%E6%B8%B8%E6%88%8F-Solution%2F</url>
    <content type="text"><![CDATA[啥？又是二分图？ 传送门洛谷P1129 BZOJ1059 题解对于这一题，可以把矩阵的每一行建一个点，矩阵的每一列建一个点。对于一个黑色格子，在它所在的行和列之间建边，这样就建出了一个二分图。 对于一个交换行或者交换列的操作，就相当于在图中交换两个点的编号。 当主对角线上的格子全部为黑色时，对应到图中就相当于每一行所对应的点都与和他编号相同的列对应的点之间有连边。 不难发现，当且仅当图中存在完美匹配时，可以达到可以达到目标状态。 所以直接上匈牙利算法求二分图最大匹配即可。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include&lt;cstdio&gt;#include&lt;cstring&gt;using namespace std;const int maxn=205;int T,n,tot,lnk[maxn],son[maxn*maxn],nxt[maxn*maxn],cp[maxn],ans;bool vis[maxn];inline int read()&#123; int ret=0,f=1;char ch=getchar(); while(ch&lt;'0'||ch&gt;'9')&#123;if(ch=='-')f=-f;ch=getchar();&#125; while(ch&gt;='0'&amp;&amp;ch&lt;='9')&#123;ret=ret*10+ch-'0';ch=getchar();&#125; return ret*f;&#125;inline void add_e(int x,int y)&#123;tot++;son[tot]=y;nxt[tot]=lnk[x];lnk[x]=tot;&#125;bool Hungary(int now)&#123; for(int i=lnk[now];i;i=nxt[i]) &#123; if(!vis[son[i]]) &#123; vis[son[i]]=true; if(!cp[son[i]]||Hungary(cp[son[i]])) &#123; cp[son[i]]=now; return true; &#125; &#125; &#125; return false;&#125;int main()&#123; T=read(); while(T--) &#123; n=read();memset(lnk,0,sizeof(lnk));memset(cp,0,sizeof(cp));tot=ans=0; for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=n;j++) if(read()) add_e(i,j); for(int i=1;i&lt;=n;i++) &#123; memset(vis,0,sizeof(vis)); if(Hungary(i)) ans++; &#125; printf("%s\n",ans==n?"Yes":"No"); &#125; return 0;&#125;]]></content>
      <categories>
        <category>二分图匹配</category>
      </categories>
      <tags>
        <tag>二分图匹配</tag>
        <tag>匈牙利算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「绍兴一中」暑假集训游记]]></title>
    <url>%2F2019%2F07%2F04%2F%E3%80%8C%E7%BB%8D%E5%85%B4%E4%B8%80%E4%B8%AD%E3%80%8D%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E6%B8%B8%E8%AE%B0-Diary%2F</url>
    <content type="text"><![CDATA[又一次来到了绍兴一中旅游。 Day1-2019.07.04还没有正式放假，早上仍旧是在学校上焚化课。 中午在机房集中了一下，下午1点就出发了。 本该在衢州西上高速，但是没想到高速入口封了，上不去。 只好到龙游再上。 中途就在诸暨服务区停了一下，也没买啥，。 过了几个小时，下了高速进入绍兴市内，不知从车上的哪里掉下来一块铁片，司机徐师傅还停车下去检查了一圈。 下午5点过到了住所。我们住在浙江越秀外国语学院的“酒店管理学院”，和去年住的是同一个地方。其实进去之后和一般的宾馆也没什么区别。 我和神仙陈乐扬被分到了同一个房间，房号是8617。和去年一样，每天房间里都有两瓶冰露可以嫖。 进了房间之后感觉好像和去年是同一个房间，不过也可能差了一两个号码。 下午5:30的时候下楼到酒店1楼去吃晚饭，30块钱一份，有点小贵。 吃完晚饭之后回到房间，开始“部署基地”，把带来的装备全摊开了。房间里有一个电视，居然还有日本频道。 这次吸取了上一次的教训，自己带齐了鼠标垫、网线、HDMI线等。但是忘记带路由器了 傍晚6:30的时候按照老师的要求下楼到操场上去准备跑步，但是由于此时天上正好飘下来了几滴雨，所以就不用跑了。 但是闪总黄霖在吃过晚饭之后就已近跑完了，貌似血亏。 19:00电梯口开会。 晚上就自己在房间里写题。 Day2-2019.07.05正式在绍一参加集训的第一天。 早上起床之后到楼下的米兰餐厅吃自助早饭。 还是和去年一样。 感觉海星，就是每样食物的供应量都有点少。 吧台里有个小姐姐，长得还行，奉先让我偷拍一张，但是由于距离有点远，没有拍到满意的。 由于去年来过，对绍一熟一点，给大家带了个路，然而差点带到坑里去。 早上是NOI模拟赛。 看了半天T1，一点想法都没有。 然后写了个暴力，发现过不了样例，才发现题意看错了。 重新理解了题意之后发现连暴力都写不来了。T1再见。 然后做T2。 T2的部分分比较多，前40分只要先推一下式子，发现$X=0$时$\frac{b_i}{a_i}$小的应该排在前面。然后搜索一下哪些放在前面，剩下的放后面即可。 另外还有$20$分的特殊数据的分可以嫖。 然后看到数据范围比较小，又才搞到$60$分，不甘心，又写了个模拟退火。发现正确率有点低，也就懒得去调参了。卡了下时就不管了。 T3是一个求最小生成树的题。由于前面浪费的时间有点多，留给这题的时间就不多了。就写了个$30$分的纯暴力。 然后就没有然后了。 中午12:30去绍一食堂吃饭，由于是第一餐，食堂里没有零钱找，只好强行凑整。 吃完饭回机房订正题目。看到了自己惨不忍睹的成绩。 T2模拟退火多骗到10分，一共70分。 T3由于数组开小，直接爆零QwQ。 隔壁余智旺暴力大法师竟然还过了。 一看题解，T1果然是个神仙题。 T2是个DP，但是后来发现模拟退火稍微调一调参竟然能过。 T3是在BFS来模拟Kruskal或者Prim算法求解最小生成树的过程。 下午14:30听巨佬王展鹏讲题。 讲的实在有点快，T1压根没挺懂。 T2和T3因为之前看过题解，还是勉强能挺懂一些。 想念黄臻祺的第一天。 4:10下课，4:40去食堂吃饭，感觉好咸啊QwQ。 回来的路上去了趟小店，买了袋泡面真香。 会宾馆之后和昨天一样，18:30下去跑步，不过今天没有下雨。 19:00又是电梯口开会。 然后一天就这样又要结束了。 Day3-2019.07.06正式在绍一参加集训的第二天。 今天有国赛的模拟赛也有联赛的模拟赛，昨天老师已经统计过意愿了。 蒟蒻我还是参加了国赛的模拟赛，准备再次被各路神仙吊打。 今天的题是周队长找的。 考试途中试题出了$n$次锅。回想起去年，考试的时候也经常出锅，也许这是绍兴特色吧。 今天三道题全都是捆绑测试，不好骗分。 T1的内存限制压得很紧。想了半天连能多骗点分的想法都没有。只好写了个预计能拿$45$分暴力，造了一下数据，发现跑的贼慢。稍微调试了一下发现输出需要两三秒。一看输出文件竟然有好几兆。一开始考虑到输入文件会很大但是忘记考虑输出了。赶紧写了个输出优化，然后跑的就够快了。 T2的题面有点长，题意比较复杂，感觉不是很可做。想了半天之后一点想法也没有。只好去打T3的暴力。 T3也没有细想，想当然地就打了一些部分分，也不知道是对是错。 然后再回头来看T2。想了一下，写了个大暴力。由于题意比较复杂，暴力也挺长的。写完一看，128行…我真的没有故意控制行数。 由于之前浪费的时间有点多，到最后写暴力没多长时间了。过了大样例之后就直接交了卷。 然后又是去绍一食堂吃饭。 吃完回来，发现国赛的模拟赛还没有评测好。就先看了一眼联赛的模拟赛成绩，没想到试卷这么难。后面爆零的一大堆，一算平均分只有二十多分。像是硬生生把NOIP出成了NOI Plus。 过了一会儿国赛模拟赛的成绩也出来了，又看到了自己惨不忍睹的分数。 T1还好，45分，与预期相符。 T2的大暴力写挂了，爆零。 T3本地一评还有8分，但是出于一些不明原因，交上去就爆零了。 想想自己也真是的，明明这么菜，还要出来混，不是找虐么。 下午14:30，周队长给大家讲题。 感觉周队长讲的还是不怎么能挺懂。周队长有点脾气有点暴躁，T2比较难，周队长还直接劝我们不要挣扎了。感觉自己弱到爆了。 想念黄臻祺的第二天。 下午放学回来，按照昨天小叶老师的要求，哥哥陈浩杰走在前面，我和姜华锦殿后。把一群人带回酒店。 下午16:50，去所在的大学食堂吃饭。由于陈浩杰把时间搞错了，和大家说成了17:40，所以大家都没按时下楼集合。我下楼之后就和哥哥在一起打电话叫人，还有一些人打不通。 来了有一些人了，哥哥让我先带队去食堂，他等后面的人。 然后我就带着一群人去了食堂。 路过了图书馆，感觉看起来好漂亮。 食堂里可以用现金支付宝饭卡。我选择了支付宝，还便宜了￥0.1血赚。 坐下去吃饭的额时候感觉这个大学食堂的桌椅和绍一是同款。 吃回来之后又回房间，然后18:30的时候和哥哥去查房点名。 本来今天老师不在，是不用跑步的。但是查完房哥哥说他减肥，要下去跑步锻炼身体。真巧，我也正打算减肥。于是就和哥哥一起下去跑了两圈。 晚上还和哥哥一起打牛客网的普及组比赛，哥哥做了一个多小时，四题都写了，感觉要AK了。我回房间之后用了5分钟写了T1。过了几分钟，成绩出来一看，我和预期相符，100分。看了一眼哥哥，只有80分，全都挂掉了。弄得哥哥说他都想投河自尽了。 晚上10点过，和哥哥再一次去查房。查了一圈没找到余智旺在哪儿。去问了一下和他同房的小威，说不知道。又找了一圈，还是找不到。直接给余智旺打了个电话，他说他在自己房间啊！第三次过去看，还真的是。原来他就在厕所里。说小威骗子，小威一脸无辜地说他动作这么轻怎么听得见啊。 Day4-2019.07.07今天是周日，绍一不集训，放假。我们一帮人就按照小叶老师的要求一整天待在自己的房间里，早上在HHHOJ上打了一场比赛。 今天的比赛是隔壁义乌中学的张家奇出的。 开始之后，我大概看了一遍。感觉今天全是套路。T1就是一个裸的树形DP求点覆盖的方案数。T2就是一个分数规划，直接二分答案然后套树形DP去验证即可。T3的话应该是个点分。这下好，今天要输不AK，多半是要掉分。 T1很快就写好了，T2的树形DP有点难搞，要套上背包来求最优选择方案。由于我实在是太菜了，到后面越写越烦，连样例都过不了。 T2搞了半天，时间已经不多了，但是我还是不甘心就又写了一会儿，还是没搞出来。 T3我本来想着应该是点分，但是复杂度怎么算都不对。只好先写个点分过掉40分再说。 搞了半天，一看时间，发现看错时间了，只考3个小时，已近结束了，我还一道题没交，血亏。 中午吃饭，点了份外卖，吃了一碗“锡纸花甲粉丝”。有点小贵，不过海星。但是下午感觉肚子有点不舒服，不知和这外卖有没有关联。 下午题目还没开放，自己先做了一会儿别的题。水了一道网络流和一道二分图匹配的题。 晚上和哥哥去大学食堂吃饭。 试题开放之后，我自己先交了一发，只有140分QwQ。 晚上自己订正试题。问张家奇要了标程之后，看了一会儿做掉了T2。然后知道了因为$a_i\leq 2$所以只要对路径的长度分奇偶性讨论即可，然后树形DP，其实挺简单的。但是我还是太菜了，没有想到。 哥哥教会张洋鸣T3之后，张洋鸣很兴奋，以为我还不会（因为我之前问过哥哥怎么做），想要给我讲一下。哥哥就把我叫了过去，听张洋鸣讲T3。因为我已经知道怎么做了，张洋鸣讲的时候我忍不住插了嘴，哥哥批评我演技欠佳。 Day5-2019.07.08今天是周一，绍一集训又是NOI模拟赛。 T1是一道字符串题，一开始就想到了可能有70分的写法，但是为了保险先写了20分的大暴力。 然后写了可能有70分的DP。 写完之后尝试着对拍，但是因为我太菜了，DP和暴力都写挂了。按照题意应该从每一个字符串中选择一个连续的子串，但是我的暴力和DP忘记判了。 改掉错误之后，拍不停了。 我尝试着算了一下DP的时间复杂度，感觉比较玄学，不知道能不能卡掉。 T1基本上也就只能这样了，然后看T2。 T2是个数学题，不怎么会做。想了一会儿之后写了一个$O(n\sqrt{n})$的暴力。预计能有18分。 然后看T3。T3的题面乍一看有点难懂，想了好久之后才看出来题目里要求的是若干个点构成的凸包的面积。 然后就按照普通写法求出了凸包上的点，然后用向量叉积求出了多边形的面积。预计得分10分。 中午去绍一食堂吃饭，由于没有零钱又被强行凑整，买了一杯果汁。吃完饭之后喝不下了，就送给黄霖了。黄霖说不嫖白不嫖。 吃完饭回去发现自己T1爆零了，后面两题与预计分数一致。 评了一下别人的T1，发现基本上都爆零。只有余智旺有40分。一问才知道余智旺看错题面，将子串看成了子序列。我一听就也改了下自己的程序，改完之后就有70分了。看来是数据和标程出锅了。 看了一下对面联赛的练习题，随便弄了一道“【SDOI2015】排序”做了一下。 下午14:30，照例讲题。今天讲课的大佬我并不认识。 回去之后先写完了那道联赛题，然后感觉T1可能稍微可做一些。努力去看标称，大概能看懂一些了。 放学之后回宾馆，晚上点了外卖，吃什么荷叶饭，感觉海星，还是有点小贵。 饭吃得有点晚了。刚吃完饭，下去跑步，慢跑了两圈。 晚上去找哥哥陈浩杰，又看了一会儿T1，基本上把T1的标程看懂了，也知道了为什么标程挂了。标程的DP状态中没有关于是否连续的信息，所以求成了子序列的方案数。可是我改不来QwQ。 和陈浩杰同房的张洋鸣在做POJ上的一道搜索题，以前我和哥哥做过。他写挂了，一开始哥哥坚持让他自己查错，到后来我也有些不耐烦了，便去帮他看了看。一开始先排查了一个明显的错误，就是他回溯的时候没有将状态复原。但是改掉之后还是WA。我只是看到了他判断是否达到目标状态的方式比较奇特，但是第一眼没有看出问题来。哥哥也来看了一下，我才发现他判断是否达到目标状态的方式存在漏洞，改掉就AC了。 Day6-2019.07.09今天在绍一集训，早上又是NOI模拟赛。 T1是先给一个长度为$n$的字符串，然后让你构造$n$个长度为$n$的与原串最短编辑距离分别为$1$~$n$的字典序最小的字符串。数据范围很小，$n$最大25。 我并没有什么想法，但是看到对于$30\%$的数据，有$n\leq 5$，于是我就先写$O(26^n)$地枚举字符串，然后$O(n^2)$地通过DP来计算枚举出的串与原串的最短编辑距离。预计能得$30$分。 T2是说有很多种硬币，面值为$1,m,m^2,m^3,\cdots$。每种有无限个。问凑出面值$x$有多少种方案。 一开始我先写了个DFS，跑的贼慢，连分都没有。 然后我考虑开始优化，我尝试着倒序枚举硬币面值，效率高了一些，但是仍然没有分。 又想了很久，由于我实在是太菜了，并不知道还能如何优化。最小的点$x$的上限也要$10^6$。 后来才想到，按照类似背包的方法来统计方案数，能优化到$O(n\log n)$。预计得分25分。 T3又是一个期望题，并不会做，再见。 考到快结束的时候，干脆弃疗了，打开洛谷做联赛的练习题。 考完试，去食堂吃饭。同样今天也被强行凑整，多买了一杯奶茶。今天努力尝试着把它喝完了，没让黄霖嫖。 回去又看到了自己寥寥无几的分数，只有55分。不过还好没有写挂。 看了下T1的题解，好像并不难。想过之后便把代码写了，很短。感觉就是普及组出这种题也不过分。但我就是不会做，我好菜啊。 下午14:30，周队长讲课。 讲到T3的时候，周队长讲了一个$O(n^6)$的做法，但是跑像开挂一样地快，比$O(n^5)$的还要快。然后还讲了用斯特林数相关知识来优化，还直接说不会的同学可以选择弃疗。 讲完课之后先写了一道NOIP的练习题，不知是哪里挂了，交上去分很少。边上的陈潇然大佬之前看了一下我的代码，并没有发现问题。当他自己写的时候，突然想起来好像我有个地方写挂了。我仔细一看，是个傻逼错误。改掉之后再交就AC了。我直呼我是多么的菜，边上的陈潇然听了就说了一声：“这么菜还切题！”被大佬嘲讽了，不开心。 放学之后回宾馆，过了一会儿和哥哥几个人去学校食堂吃饭。回来的时候还没什么雨，去吃饭的时候雨就挺大的了。陈乐扬和张洋鸣还坐电梯会房间去拿雨伞，我就白嫖他们的伞了。 路上我觉得有点冷，但是哥哥不觉得冷。我嘴欠说了一句：“哥哥你比我们多了一件衣服呢！”（指那层脂肪）哥哥说他要把我头拧下来刷我的脸去买饮料。 晚上又写了道联赛的练习题，是VK Cup2012的题。 是一个搜索题，需要加很多剪枝。做到最后实在有一个毒瘤点跑不过去，干脆就直接特判掉算了。 Day7-2019.07.10今天绍一集训没有NOI模拟赛，老师给我们留了一天时间自己做练习巩固。 早上把昨天NOIP模拟赛的T2写掉了，是个线段树模拟最大费用流的题。代码有点长，要维护的信息一大堆。写完之后看了下昨天的成绩，发现很多人在昨天的数据下T2都过了。点开一看，基本上都是暴力DP，这数据也忒水了吧。 昨天T2写到一半，先去听了一会儿联赛的讲课。和去年相比，今年能听懂的东西多了一些，有些题目甚至还挺水。 回来之后又做了一道搜索题，直接开个map然后Meet in the Middle折半搜索即可，还是比较简单的。 中午11:30，绍一的董老师让我们参加国赛难度的集训的同学先去吃饭，说今天让我们排前面、吃新鲜的… 在食堂，哥哥陈浩杰掉了10块钱，还说这是他第3次掉了。之前两次都已经捡回来了。吃完饭之后我走了一圈找到了掉的10块钱，把它还给了陈浩杰。哥哥说不花掉下次还要掉的，然后就去买了两瓶牛奶，送了一瓶给我。结果找回来的5块钱和他自己的另一张5块钱又一起掉了。 下午看了下今天联赛的作业题，有一题是在一个无向图中求两点间最短路。但是边权非常大，不过都是2的整数次幂。于是用个线段树来表示一条路劲的边权和。由于每次进行加操作只会修改一个点的位置和一个连续的区间，所以可持久化搞一下就好了。 但是代码量实在有点大，光写代码就花了很久，而且一直调试到放学也没有调出来。 放学的时候哥哥在我背后叫我，我还以为是黄霖，哥哥因为我以为他是黄霖而生了我的气QwQ。 放学会宾馆路上买了包泡面，会宾馆之后就泡了当晚饭吃了，懒得去食堂了。 然后继续对拍调试，终于拍出一个会挂的点了。然后依次删边，将原数据删成了边数最小并且会WA的状态，然后开始调试。但是调试了半天还是没看出什么问题。 18:30，今天的这时候没有下雨，下去跑了两圈。 回来继续调试，又调了很久，终于找到问题了，哈希值在向上合并时计算有误。赶紧改掉，再交一发，才过了。 今天下午的时候用手机录到了几个黄霖的吼叫声，于是我就用这几个素材和Angelina的伴奏做了一首1分钟的鬼畜。作死拷给黄霖听，腿差点没掉。 Day8-2019-07.11早上是模拟赛。 T1让你求在所有的某种图中两点之间的最短路的k次方之和。我没啥想法，按照最笨的方法写了个10分的大暴力。 T2让你在无向图中求所有有序的能从第一个点走到第二个点的点对中两点编号的异或值的第$K$大。 尝试着去写了一下$O(n^2\log n)$的暴力，自己造了一下40分的极限数据，发现自己的程序要跑两秒多，时限是1秒。我先尝试着把DFS换成了BFS，略快了0.2秒左右。然后尝试着自己手写排序而不调用STL的排序，结果发现更慢…观察了一下数据范围之后发现排序对象的权值很小，于是干脆就直接拿来计数排序，省掉一只log，将时间压到了1s以内。预计得分40分。 T3在衢二的省选模拟赛中考过，但是我没有想起来。一看题面，我连暴力都写不来。只好写了个模拟退火来骗骗分，也不期望有分了。 暴力打完，偏分代码写完，然后弃疗去做联赛的练习题。 考完去吃饭，路上看到王展鹏大佬和他的同学讨论得可起劲了。 中午还是吃了一荤一素，不知为啥之前都是8块钱，今天就10块了。 回去看了下成绩，最后一题骗到了10分，前面和预期一致。看了下哥哥陈浩杰，他T3有30分。改了下随机的次数就能有七八十分了。他好像写的基本上是正解。 先做了道线段树合并的题，之前没有写过，今天写了一下。 14:30，去听周队长讲课。 T3的正解和之前在衢二考试的时候的解法一直，就是先随机映射然后检验正确性。随机个几百次几千次正确率就很高了。 然后又去做NOIP的练习题。有一道多次询问树上信息的题需要按照深度为版本，按照DFS序为下标来建主席树维护信息。 放学的时候哥哥说血型不同的人招蚊子的程度也不同，我不相信，不小心说了哥哥一句糟老头子。因为昨天我以为哥哥是黄霖，他还怀恨在心，今天一说就更加了。 回酒店又写了一会这题，然后和哥哥一起去大学的食堂吃饭。 吃完饭回来继续写，18:30准时下楼跑步。 跑完步回来继续写，又写了一会儿才过。 晚上给昨天黄霖的鬼畜配上了视频顺便发到了B站上，腿又差点没了。 Day9-2019-07-12早上还是NOI模拟赛。 T1和T2都不怎么会写，后来直接写了10分的最笨最笨的大暴力。然后T1稍微写了一些常数优化，比如循环展开，企图多骗点分。前两题预计得分20分。考试的时候还看到边上的陈潇然在写T2 30分的二分解法。 然后开始搞T3。看到T3的数据范围有个限制，就是图的结构与树十分接近，于是我干脆就先给原先的图分层，然后上模拟退火来瞎搞骗分，还过了下发的大样例（然而样例非常的水）。 看了下边上的陈潇然，T3把基环树的情况也搞掉了。太强了。 边上的姜正考试的时候在桌上趴了一会儿，但是很不巧的是被董老师看到了。 考试结束交卷的时候，我看到数据已经放出来了。于是我就先把数据下了下来把自己的T3评了一道，发现有65分。不知道最后评出来有几分，毕竟评测机的性能比较差，而我又是卡时的，可能跑不出答案来。 中午仍旧在绍一食堂吃饭。刚出教学楼的时候有一点点雨。走到一半的时候雨越下越大，把自己淋湿了。今天食堂阿姨依然尝试着要强行凑整，被我拒绝了。 回去之后成绩还没出来，我又把自己的T1和T2评了一下，只有20分，与预期相符。 过了一会儿，成绩出来了，T3只有45分。这评测机也忒差了点吧。 下午14:30讲题，董老师说这是最后一场NOI模拟赛了，过几天就是NOI2019了。明天就要和大家一起参加NOIP模拟赛了。最近天天被一群人吊打，明天换一群人吊打下我 讲课的时候有大佬说T3直接选取离节点1最近的30个点作为起点来刷答案，然后就AC了。这数据也太水了吧！随便造个数据就能把这个乱搞做法卡掉。早知道这样能AC我就不写模拟退火了QwQ。 下午自己做题。看到一道NOIP的练习题，要用替罪羊树和线段树。蒟蒻我替罪羊树已经很久没有写过了，赶紧打了个板子压压惊。 放学之后，和黄霖、姜正、陈潇然和余智旺去学校边上的兰州拉面吃饭，吃完后还到边上的小店买了棒冰吃。黄霖买了根叫什么双黄蛋的棒冰，比较新奇，但是要5块钱一根。闪总吃了之后感觉在普通的奶油棒冰中的甜味中又有点咸，就像往牛奶糊里加了咸鸭蛋那种感觉，总之血亏。 晚上回来之后写了那道线段树加替罪羊树的题，然后又到哥哥房间里写了一会儿焚化课作业，顺便请教了哥哥几个问题。 回来之后把黄霖的鬼畜视频重新修了一下，然后渲染成1080p的分辨率，最后重新压制了一遍。把B站上的视频更新了一下。 Day10-2019.07.13今天是在绍一集训的最后一天了。 早上从宾馆到学校的路上，因为正下着雨，所以地面很湿，走在路上的时候边上还开过来一辆车，溅了我一身。 早上是NOIP的模拟赛。 T1让你维护一个无向图，每次可以加入一条带权边，或者询问两点之间是否存在长度为偶数的路径。 一开始没什么想法，然后在草稿纸上随便画了几个图，发现了一些性质，后来发现只要对奇数边和偶数边分别处理，然后弄个并查集维护一下就好了。 写完之后有点慌，怕想法有问题，赶紧写了个暴力拍了一下，还好没拍出问题来。 T2是一个数学题。 没什么想法，写了个10分的大暴力。 T3直接搜索可以拿40分，还是比较好写的。蒟蒻我觉得后面两题就这么写暴力不太好，于是就又双叒叕写了个模拟退火。自己拍了一下，$K=4$的时候正确率还是挺高的，不知道后面的数据怎么样。 考完之后去吃饭。今天得去二楼食堂，去年去过，有个大叔我映象挺深的，但是今天没有看到，只看到了一个去年见过的小哥。 回去之后看成绩，还没有出来。自己下载了数据之后评测了一下，T3有50分，但是由于评测机比较差，不知道交上去会怎样。 成绩出来，T3有50分。应该是今天早上洗过脸的原因吧。 其他题的分数与预期相符，所以只有可怜的160分，被虐惨了。 下午13:30去听讲课，令我感动是竟然难得有这样的一天下午的讲题能全部听懂。 回去便把T2和T3给订正掉了，感觉还是比较简单的（至少和NOI模拟赛的难度相比），代码都很短。但是我实在是太菜了，想不到啊。 正当我订正题目的时候，刚才讲题的人突然走进来，说有人想出了T3的$O(n^2\log n)$的写法，把标程的$O(n^3)$摁在了地上。让我们过去听，但是我并没有听懂。 回来之后继续订正题目，放学之前都订正完了。 订正完离放学还有一段时间，我想到明天要走了，而这里的电脑又没有开还原卡，我怕还有哪个OJ的账号没有退掉然后被机惨，干脆把浏览器卸掉在装了一遍。 然后把这几天的考试数据检查整理了一下，顺便整理了一下第一天来的时候从电脑里偷的资料。才想起来去年偷的资料还没怎么看过。 然后就回宾馆了。 晚上点了份外卖，小哥没有准时送达，差评。 不过今天的外卖相较于前几天来说还是比较便宜实惠的。 晚上还是自己写题。 Day11-2019.07.14今天该回家了。 早上还是准时起床，然后和哥哥下去吃早饭。 早上人比较少，好多人都还没起床。 今天早上从吧台拿了一小杯冲咖啡用的牛奶，自己加了点红茶泡了杯奶茶，感觉海星。 然后上楼回房间自己写题。 快九点的时候收拾了下东西，然后打开了房间里的一个柜子，里面满是手纸和抽纸（前几天每天早上就把前一天没用完的纸藏柜子里，收拾房间的阿姨来了之后看到纸没了会放新的），白嫖真开心。 9:30，下楼集合，退房。10:00，上了大巴车。 过了好久，车还是没有开，说是坏了。 快12:00的时候，来了一辆新的车，我们便换了辆车回衢州。 13:00，到了诸暨服务区，买了桶泡面吃，要7块钱，血亏。 回来的路上，我打了一下洛谷的月赛。看了下前三题，感觉都挺水的。 T3让你求一个序列所有子区间的逆序对数量之和。我稍微想了一下，感觉就弄了个树状数组搞一下就可以了。写完之后交了一发，只有70分。后来一算才发现long long都炸了，赶紧开了个int128压压惊。于是T3便过了。 然后再回头写T1，T1是个大模拟，还是挺水的。 再写T2，看到题之后我第一个想到的写法就是弄个双向链表再搞个线段树来解决，还是比较好些的，写完马上交就1A了。不知道有没有更简单的写法。 刚想看T4，已经到衢州了，便懒得看了。拎上行李回家。]]></content>
      <categories>
        <category>游记</category>
      </categories>
      <tags>
        <tag>游记</tag>
        <tag>绍兴一中</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「NOI2017」游戏]]></title>
    <url>%2F2019%2F07%2F01%2F%E3%80%8CNOI2017%E3%80%8D%E6%B8%B8%E6%88%8F-Solution%2F</url>
    <content type="text"><![CDATA[2-SAT裸题？有点难写qwq。 传送门洛谷P3825 BZOJ4945 题解如果只有a、b、c三种地图，由于只有两种赛车选择，所以是裸的2-SAT问题。 但是有x地图。 不过数量并不多，最多只有$8$张。 所以可以暴力枚举这$d$张x地图用什么车，然后再套2-SAT。时间复杂度为$O((n+m)*3^d)$。 这样复杂度太高了，并不容易过。 然后不难发现，对于一张地图，不选A和不选B这两种方案中其实已近包含了所有可能。 所以复杂度就可以降到$O((n+m)*2^d)$，可以过了。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136#include&lt;cstdio&gt;#include&lt;cctype&gt;#include&lt;cstdlib&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;const int maxn=100005,maxm=200005;int n,d,m,len,X[10],tot,lnk[maxn],son[maxm],nxt[maxm],idx,top,cnt,dfn[maxn],low[maxn],stack[maxn],id[maxn];bool vis[maxn];char S[maxn];inline int read()&#123; int ret=0,f=1;char ch=getchar(); while(ch&lt;'0'||ch&gt;'9')&#123;if(ch=='-')f=-f;ch=getchar();&#125; while(ch&gt;='0'&amp;&amp;ch&lt;='9')&#123;ret=ret*10+ch-'0';ch=getchar();&#125; return ret*f;&#125;inline char GetChar()&#123; char ch=getchar(); while(!isalpha(ch)) ch=getchar(); return ch;&#125;inline void add_e(int x,int y)&#123;tot++;son[tot]=y;nxt[tot]=lnk[x];lnk[x]=tot;&#125;inline void del(int x)&#123;lnk[x]=nxt[tot];nxt[tot]=0;son[tot]=0;tot--;&#125;inline void NoSolution()&#123;printf("-1");exit(0);&#125;struct Claim&#123; int i,j;char hi,hj; bool operator &lt; (const Claim&amp; b)const&#123;return (S[i]!='x'&amp;&amp;S[j]!='x')&lt;(S[b.i]!='x'&amp;&amp;S[b.j]!='x');&#125;&#125;C[maxn],T[maxn];inline int GetID(int x,char Car)&#123; int flg=0; for(char i='A';i&lt;='C';i++) &#123; if(i==Car) return x+flg*n; if(S[x]!=i+'a'-'A') flg=1; &#125;&#125;inline void PutChar(int x,int id)&#123; for(char i='A';i&lt;='C';i++) &#123; if(S[x]!=i+'a'-'A') &#123; if(!id)&#123;putchar(i);return;&#125; id--; &#125; &#125;&#125;inline char GetAn(int x,char Car)&#123;for(int i='A';i&lt;='C';i++)if(i+'a'-'A'!=S[x]&amp;&amp;i!=Car)return i;&#125; inline int Pair(int x)&#123;return x&gt;n?x-n:x+n;&#125;void Tarjan(int now)&#123; dfn[now]=low[now]=++idx; vis[now]=true;stack[++top]=now; for(int i=lnk[now];i;i=nxt[i]) &#123; if(!dfn[son[i]]) &#123; Tarjan(son[i]); if(low[son[i]]&lt;low[now]) low[now]=low[son[i]]; &#125; else if(vis[son[i]]&amp;&amp;dfn[son[i]]&lt;low[now]) low[now]=dfn[son[i]]; &#125; if(dfn[now]==low[now]) &#123; cnt++; do &#123; id[stack[top]]=cnt; vis[stack[top]]=false;top--; &#125;while(stack[top+1]!=now); &#125;&#125;inline void Solve()&#123; int leng=len; for(int i=1,j=1;i&lt;=leng&amp;&amp;j&lt;=len;i++,j++) &#123; C[i]=T[j]; if((C[i].i==C[i].j&amp;&amp;C[i].hi==C[i].hj)||(S[C[i].i]==C[i].hi+'a'-'A'))&#123;i--;leng--;continue;&#125; if(S[C[i].j]==C[i].hj+'a'-'A')&#123;C[i].j=C[i].i;C[i].hj=GetAn(C[i].i,C[i].hi);&#125; &#125; idx=cnt=0;memset(dfn,0,sizeof(dfn));memset(low,0,sizeof(low)); for(int i=1;i&lt;=leng;i++) &#123; add_e(GetID(C[i].i,C[i].hi),GetID(C[i].j,C[i].hj)); add_e(Pair(GetID(C[i].j,C[i].hj)),Pair(GetID(C[i].i,C[i].hi))); &#125; for(int i=1;i&lt;=2*n;i++) if(!dfn[i]) Tarjan(i); for(int i=1;i&lt;=n;i++) &#123; if(id[i]==id[i+n]) &#123; for(int j=leng;j;j--) &#123;del(Pair(GetID(C[j].j,C[j].hj)));del(GetID(C[j].i,C[j].hi));&#125; return; &#125; &#125; for(int i=1;i&lt;=n;i++) PutChar(i,id[i]&gt;id[i+n]); exit(0);&#125;void DFS(int step)&#123; if(step&gt;d)&#123;Solve();return;&#125; S[X[step]]='a';DFS(step+1); S[X[step]]='b';DFS(step+1);&#125;int main()&#123; n=read();read(); for(int i=1;i&lt;=n;i++) &#123; S[i]=GetChar(); if(S[i]=='x') X[++d]=i; &#125; m=read(); for(int i=1;i&lt;=m;i++) &#123; C[i].i=read();C[i].hi=GetChar(); C[i].j=read();C[i].hj=GetChar(); if((C[i].i==C[i].j&amp;&amp;C[i].hi==C[i].hj)||(S[C[i].i]==C[i].hi+'a'-'A'))&#123;i--;m--;continue;&#125; if(S[C[i].j]==C[i].hj+'a'-'A')&#123;C[i].j=C[i].i;C[i].hj=GetAn(C[i].i,C[i].hi);&#125; &#125; sort(C+1,C+1+m); while(S[C[len+1].i]=='x'||S[C[len+1].j]=='x') len++; for(int i=len+1;i&lt;=m;i++) &#123; add_e(GetID(C[i].i,C[i].hi),GetID(C[i].j,C[i].hj)); add_e(Pair(GetID(C[i].j,C[i].hj)),Pair(GetID(C[i].i,C[i].hi))); &#125; memcpy(T,C,sizeof(Claim)*(len+1)); DFS(1); NoSolution(); return 0;&#125;]]></content>
      <categories>
        <category>2-SAT</category>
      </categories>
      <tags>
        <tag>Tarjan</tag>
        <tag>2-SAT</tag>
        <tag>爆搜</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「HAOI2010」软件安装]]></title>
    <url>%2F2019%2F06%2F24%2F%E3%80%8CHAOI2010%E3%80%8D%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85-Solution%2F</url>
    <content type="text"><![CDATA[Tarjan种了树并背着包爬树？什么鬼qwq。 传送门洛谷P2515 BZOJ2427 题解对于这题，如果直接按照软件之间的依赖关系建图的话，将会建出来一棵基环树森林，并不好搞。 然后不难发现，对于一个环上的软件，要么全部安装，要么全部不装。 所以就可以愉快地缩点了。 缩完点之后，原图就变成了一片森林。 为了方便，可以再新建一个超级根，把所有根都连到超级根上。 然后树形DP，爬到树上背个包即可。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475#include&lt;cstdio&gt;using namespace std;const int maxn=105,maxm=505;int n,m,top,idx,cnt,dfn[maxn],low[maxn],stack[maxn],id[maxn],F[maxn][maxm],deg[maxn];bool vis[maxn],C[maxn][maxn];inline int read()&#123; int ret=0,f=1;char ch=getchar(); while(ch&lt;'0'||ch&gt;'9')&#123;if(ch=='-')f=-f;ch=getchar();&#125; while(ch&gt;='0'&amp;&amp;ch&lt;='9')&#123;ret=ret*10+ch-'0';ch=getchar();&#125; return ret*f;&#125;struct Graph&#123; int tot,lnk[maxn],son[maxn*2],nxt[maxn*2],w[maxn],v[maxn]; inline void add_e(int x,int y)&#123;tot++;son[tot]=y;nxt[tot]=lnk[x];lnk[x]=tot;&#125;&#125;G1,G2;void Tarjan(int now,const Graph&amp; G)&#123; dfn[now]=low[now]=++idx; vis[now]=true;stack[++top]=now; for(int i=G.lnk[now];i;i=G.nxt[i]) &#123; if(!dfn[G.son[i]]) &#123; Tarjan(G.son[i],G); if(low[G.son[i]]&lt;low[now]) low[now]=low[G.son[i]]; &#125; else if(vis[G.son[i]]&amp;&amp;dfn[G.son[i]]&lt;low[now]) low[now]=dfn[G.son[i]]; &#125; if(dfn[now]==low[now]) &#123; cnt++; do &#123; id[stack[top]]=cnt; G2.w[cnt]+=G1.w[stack[top]]; G2.v[cnt]+=G1.v[stack[top]]; vis[stack[top]]=false;top--; &#125;while(stack[top+1]!=now); &#125;&#125;void DFS(int now,const Graph&amp; G)&#123; if(G.w[now]&gt;m) return; for(int i=G.lnk[now];i;i=G.nxt[i]) &#123; DFS(G.son[i],G); for(int j=m-G.w[now];j;j--) for(int k=1;k&lt;=j;k++) if(F[now][j-k]+F[G.son[i]][k]&gt;F[now][j]) F[now][j]=F[now][j-k]+F[G.son[i]][k]; &#125; for(int i=m;i&gt;=G.w[now];i--) F[now][i]=F[now][i-G.w[now]]+G.v[now]; for(int i=0;i&lt;G.w[now];i++) F[now][i]=0;&#125;int main()&#123; n=read();m=read(); for(int i=1;i&lt;=n;i++) G1.w[i]=read(); for(int i=1;i&lt;=n;i++) G1.v[i]=read(); for(int i=1;i&lt;=n;i++) &#123; int Di=read(); if(Di) G1.add_e(Di,i); &#125; for(int i=1;i&lt;=n;i++) if(!dfn[i]) Tarjan(i,G1); for(int i=1;i&lt;=n;i++) for(int j=G1.lnk[i];j;j=G1.nxt[j]) if(id[i]!=id[G1.son[j]]&amp;&amp;!C[id[i]][id[G1.son[j]]]) &#123;G2.add_e(id[i],id[G1.son[j]]);C[id[i]][id[G1.son[j]]]=true;deg[id[G1.son[j]]]++;&#125; for(int i=1;i&lt;=cnt;i++) if(deg[i]==0) G2.add_e(cnt+1,i); DFS(cnt+1,G2); printf("%d\n",F[cnt+1][m]); return 0;&#125;]]></content>
      <categories>
        <category>树形DP</category>
      </categories>
      <tags>
        <tag>Tarjan</tag>
        <tag>缩点</tag>
        <tag>树形DP</tag>
        <tag>背包</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「IOI2008」Island]]></title>
    <url>%2F2019%2F06%2F08%2F%E3%80%8CIOI2008%E3%80%8DIsland-Solution%2F</url>
    <content type="text"><![CDATA[他出题人要是敢砍掉一条边然后保证连通，我就敢做！ 传送门洛谷P4381 BZOJ1791 题解题意：给定一个基环树森林，求直径和。 首先，随便拎一棵基环树出来，然后找到环。 考虑在环上DP。 先对于环上每一个节点的子树，来一遍DFS，求出从根到最深节点的距离以及子树直径。 按照环上DP的套路，先破环为链，然后复制一遍。 然后就可以DP了，但是直接暴力DP是$O(n^2)$的，所以开个单调队列优化一下即可。 恶心的是这题还卡常，自带大常数的蒟蒻我卡了好久才过。 每棵基环树的直径最后要和每个子树的直径取个max。 对于每一棵基环树分别处理即可。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112#include&lt;cstdio&gt;#include&lt;cstring&gt;typedef long long LL;using namespace std;const int maxn=1000005;int n,tot=1,lnk[maxn],son[maxn*2],w[maxn*2],nxt[maxn*2],deg[maxn],C[maxn],rt,que[maxn*2];LL dep[maxn*2],sum,ans,S[maxn*2],D[maxn];bool vis[maxn],cir[maxn];inline char nc()&#123; static const int S=1048576;static char buf[S],*L,*R; return L==R&amp;&amp;(R=(L=buf)+fread(buf,1,S,stdin),L==R)?EOF:*L++;&#125;inline int read()&#123; int ret=0,f=1;char ch=nc(); while(ch&lt;'0'||ch&gt;'9')&#123;if(ch=='-')f=-f;ch=nc();&#125; while(ch&gt;='0'&amp;&amp;ch&lt;='9')&#123;ret=ret*10+ch-'0';ch=nc();&#125; return ret*f;&#125;inline void add_e(int x,int y,int z)&#123;tot++;son[tot]=y;w[tot]=z;nxt[tot]=lnk[x];lnk[x]=tot;&#125;inline void GetTree(int x)&#123; int hed=0,til=1; que[1]=x;vis[x]=true; while(hed!=til) &#123; hed++;C[++C[0]]=que[hed]; for(int i=lnk[que[hed]];i;i=nxt[i]) &#123; if(!vis[son[i]]) &#123; vis[son[i]]=true; que[++til]=son[i]; &#125; &#125; &#125;&#125;void Toposort()&#123; int hed=0,til=0; for(int i=1;i&lt;=C[0];i++) if(deg[C[i]]==1) que[++til]=C[i]; while(hed!=til) &#123; hed++;cir[que[hed]]=false; for(int i=lnk[que[hed]];i;i=nxt[i]) &#123; if(deg[son[i]]) &#123; if(D[son[i]]&lt;D[que[hed]]+w[i]) D[son[i]]=D[que[hed]]+w[i]; deg[son[i]]--; deg[que[hed]]--; if(deg[son[i]]==1) que[++til]=son[i]; &#125; &#125; &#125; int p=0,lst=0,len=0; for(int i=1;i&lt;=C[0];i++) if(cir[C[i]])&#123;p=C[i];len++;&#125; C[0]=len; for(int i=1;i&lt;=C[0];i++) for(int j=lnk[p];j;j=nxt[j]) if((j^1)!=lst&amp;&amp;cir[son[j]]) &#123;C[i]=p;lst=j;p=son[j];S[i+1]=S[i+1+C[0]]=w[j];break;&#125; for(int i=1;i&lt;=C[0]*2;i++) S[i]+=S[i-1];&#125;void GetD(int now,int fa,LL dist)&#123; if(dist&gt;sum)&#123;sum=dist;rt=now;&#125; for(int i=lnk[now];i;i=nxt[i]) if(son[i]!=fa&amp;&amp;!cir[son[i]]) GetD(son[i],now,dist+w[i]);&#125;inline LL Solve(int x)&#123; LL ret=0,tep;C[0]=0; GetTree(x); Toposort(); for(int i=1;i&lt;=C[0];i++) &#123; dep[i+C[0]]=dep[i]=D[C[i]]; cir[C[i]]=false;rt=C[i]; sum=0;GetD(C[i],0,0); sum=0;GetD(rt,0,0); cir[C[i]]=true; if(sum&gt;ret) ret=sum; &#125; int hed=0,til=0; for(int i=1;i&lt;=C[0]*2;i++) &#123; while(hed&lt;til&amp;&amp;i-que[hed]&gt;=C[0]) hed++; tep=dep[i]+dep[que[hed]]+S[i]-S[que[hed]]; if(tep&gt;ret) ret=tep; while(hed&lt;til&amp;&amp;dep[i]-S[i]&gt;=dep[que[til]]-S[que[til]]) til--; que[++til]=i; &#125; return ret;&#125;int main()&#123; n=read();memset(cir,true,sizeof(cir)); for(int i=1;i&lt;=n;i++) &#123; int b=read(),l=read(); deg[i]++;deg[b]++; add_e(i,b,l);add_e(b,i,l); &#125; for(int i=1;i&lt;=n;i++) if(!vis[i]) ans+=Solve(i); printf("%lld\n",ans); return 0;&#125;]]></content>
      <categories>
        <category>基环树</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>基环树</tag>
        <tag>单调队列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「国家集训队」礼物]]></title>
    <url>%2F2019%2F06%2F05%2F%E3%80%8C%E5%9B%BD%E5%AE%B6%E9%9B%86%E8%AE%AD%E9%98%9F%E3%80%8D%E7%A4%BC%E7%89%A9-Solution%2F</url>
    <content type="text"><![CDATA[模数不是大质数，怎么办啊。 传送门洛谷P2183 BZOJ2142 题解首先，比较显然的是，当且仅当$\sum_{i=1}^{m}{w_i}&gt;n$时无解。 不妨设$w{m+1}=n-\sum{i=1}^{m}{w_i}$。 那么直接上公式，所以答案为 \frac{n!}{\prod_{i=1}^{m+1}w_i!}由于模数不是质数，所以直接将模数分解质因数，然后分别计算模每一项的值，然后用CRT搞到一起就行了，就是EXLUCS的流程。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394#include&lt;cstdio&gt;using namespace std;typedef long long LL;int pri[10000];LL sum,n,m,p,w[10];inline void make_p()&#123; static bool vis[100005]; vis[0]=vis[1]=true; for(int i=2;i&lt;=100000;i++) &#123; if(!vis[i]) pri[++pri[0]]=i; for(int j=1;j&lt;=pri[0]&amp;&amp;pri[j]*i&lt;=100000;j++) &#123; vis[pri[j]*i]=true; if(i%pri[j]==0) break; &#125; &#125;&#125;LL QP(LL a,LL b,LL TT)&#123; LL ret=1,w=a; while(b) &#123; if(b&amp;1) ret=ret*w%TT; w=w*w%TT;b&gt;&gt;=1; &#125; return ret;&#125;LL Exgcd(LL a,LL b,LL&amp; x,LL&amp; y)&#123; if(!b)&#123;x=1;y=0;return a;&#125; LL d=Exgcd(b,a%b,x,y); LL t=x;x=y;y=t-a/b*y; return d;&#125;LL inv(LL a,LL TT)&#123; LL X,Y,D=Exgcd(a,TT,X,Y); return (X%(TT/D)+(TT/D))%(TT/D);&#125;LL Fac(LL n,LL p,LL pk)&#123; if(n==0) return 1; LL ret1=1,ret2=1; for(int i=1;i&lt;=pk;i++) &#123; if(i%p!=0) ret1=ret1*i%pk; if(i%p!=0&amp;&amp;i&lt;=n%pk) ret2=ret2*i%pk; &#125; ret1=QP(ret1,n/pk,pk); return Fac(n/p,p,pk)*ret1%pk*ret2%pk;&#125;LL Count(LL n,LL p)&#123;LL ret=0;while(n)&#123;ret+=n/p;n/=p;&#125;return ret;&#125;LL Calc(LL n,LL m,LL p,LL pk)&#123; LL cnt1=Count(n,p),cnt2=0,ret=Fac(n,p,pk); for(int i=1;i&lt;=m;i++) cnt2+=Count(w[i],p); for(int i=1;i&lt;=m;i++) ret=ret*inv(Fac(w[i],p,pk),pk)%pk; ret=ret*QP(p,cnt1-cnt2,pk)%pk; return ret;&#125;LL ExLucas(LL n,LL m,LL TT)&#123; LL LCM=1,X=0,Y,Z,D; for(int i=1;i&lt;=pri[0];i++) &#123; if(TT%pri[i]==0) &#123; LL pk=1; while(TT%pri[i]==0)&#123;pk*=pri[i];TT/=pri[i];&#125; LL A=Calc(n,m,pri[i],pk); D=Exgcd(LCM,pk,Y,Z); Y*=(A-X)/D; X+=Y*LCM; LCM=LCM/D*pk; &#125; &#125; X=(X%LCM+LCM)%LCM; return X;&#125;int main()&#123; make_p(); scanf("%lld%lld%lld",&amp;p,&amp;n,&amp;m); for(int i=1;i&lt;=m;i++) &#123; scanf("%lld",&amp;w[i]); sum+=w[i]; &#125; if(sum&gt;n)&#123;printf("Impossible\n");return 0;&#125; w[++m]=n-sum; printf("%lld\n",ExLucas(n,m,p)); return 0;&#125;]]></content>
      <categories>
        <category>EXLUCAS</category>
      </categories>
      <tags>
        <tag>EXLUCAS</tag>
        <tag>CRT</tag>
        <tag>排列组合</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「GXOI/GZOI2019」旅行者]]></title>
    <url>%2F2019%2F06%2F03%2F%E3%80%8CGXOI%20GZOI2019%E3%80%8D%E6%97%85%E8%A1%8C%E8%80%85-Solution%2F</url>
    <content type="text"><![CDATA[随机算法多好啊。 传送门洛谷P5304 BZOJ5506 题解对于这题，一开始能比较容易地想到一个乱搞的做法： 将$k$个关键点随机分成两半，建立超级源点向其中一半的所有点建边权为$0$的边，再从另一半向超级汇点建边权为$0$的边。 然后用Dijkstra求出源点到汇点的最短路，取每次求解出最短路的最小值为答案。 这样一次求出最优解的概率为$\frac{1}{4}$。 但是如果我们重复以上操作20次，那么求出最优解的概率为$1-(\frac{3}{4})^{20}\approx99.7\%$。 这样AC的概率其实已近非常高了，如果能优化常数然后增大重复次数，那么AC的概率还可以进一步提高。 其实如果想到了上面乱搞的做法，离正解也很近了。 我们可以根据关键点编号在二进制中第$i$位上的数字来对这$k$个关键点进行分组，为$0$的分在一组，为$1$的分在另一组。然后按照上面的方式建图求最短路。 假设最优解中的起点为$u$，终点为$v$，那么它们编号在二进制中至少有一位不同，所以它们必定会在某一次分组中被分在了不同的组，从而求解出了答案。 时间复杂度$O(nlog^2n )$。 注意由于图是有向的，所以每枚举到二进制中的一位时应进行两次分组。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182#include&lt;queue&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;using namespace std;typedef long long LL;const int maxn=100005,maxm=500005;const LL inf=0x3F3F3F3F3F3F3F3FLL;int T,n,m,k,V[maxn];LL ans,dist[maxn];inline char nc()&#123; static const int S=131072;static char buf[S],*L,*R; return L==R&amp;&amp;(R=(L=buf)+fread(buf,1,S,stdin),L==R)?EOF:*L++;&#125;inline int read()&#123; int ret=0,f=1;char ch=nc(); while(ch&lt;'0'||ch&gt;'9')&#123;if(ch=='-')f=-f;ch=nc();&#125; while(ch&gt;='0'&amp;&amp;ch&lt;='9')&#123;ret=ret*10+ch-'0';ch=nc();&#125; return ret*f;&#125;struct Graph&#123; int tot,lnk[maxn],son[maxm],nxt[maxm],w[maxm]; inline void Clear()&#123;tot=0;memset(lnk,0,sizeof(lnk));&#125; inline void add_e(int x,int y,int z)&#123;tot++;son[tot]=y;w[tot]=z;nxt[tot]=lnk[x];lnk[x]=tot;&#125;&#125;G1,G2;struct Node&#123; int id;LL dis; bool operator &lt; (const Node&amp; b)const&#123;return dis&gt;b.dis;&#125;&#125;;inline void Dijkstra()&#123; memset(dist,63,sizeof(dist)); priority_queue&lt;Node&gt; que; que.push((Node)&#123;n+1,0&#125;); dist[n+1]=0; while(!que.empty()) &#123; Node QH=que.top();que.pop(); if(QH.id==n+2&amp;&amp;QH.dis&lt;ans) ans=QH.dis; if(QH.dis&gt;dist[QH.id]) continue; dist[QH.id]=QH.dis; for(int i=G2.lnk[QH.id];i;i=G2.nxt[i]) if(QH.dis+G2.w[i]&lt;dist[G2.son[i]]) que.push((Node)&#123;G2.son[i],QH.dis+G2.w[i]&#125;); &#125;&#125;int main()&#123; T=read(); while(T--) &#123; n=read();m=read();k=read();G1.Clear();G2.Clear();ans=inf; for(int i=1;i&lt;=m;i++) &#123; int a=read(),b=read(),c=read(); G1.add_e(a,b,c);G2.add_e(a,b,c); &#125; for(int i=1;i&lt;=k;i++) V[i]=read(); for(int i=0;(1&lt;&lt;i)&lt;=n;i++) &#123; G2.tot=G1.tot; memcpy(G2.lnk,G1.lnk,(n+3)*sizeof(int)); for(int j=1;j&lt;=k;j++) &#123; if(V[j]&amp;(1&lt;&lt;i)) G2.add_e(n+1,V[j],0); else G2.add_e(V[j],n+2,0); &#125; Dijkstra(); G2.tot=G1.tot; memcpy(G2.lnk,G1.lnk,(n+3)*sizeof(int)); for(int j=1;j&lt;=k;j++) &#123; if(V[j]&amp;(1&lt;&lt;i)) G2.add_e(V[j],n+2,0); else G2.add_e(n+1,V[j],0); &#125; Dijkstra(); &#125; printf("%lld\n",ans); &#125; return 0;&#125;]]></content>
      <categories>
        <category>最短路</category>
      </categories>
      <tags>
        <tag>最短路</tag>
        <tag>Dijkstra</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「NOI2018」屠龙勇士]]></title>
    <url>%2F2019%2F06%2F03%2F%E3%80%8CNOI2018%E3%80%8D%E5%B1%A0%E9%BE%99%E5%8B%87%E5%A3%AB-Solution%2F</url>
    <content type="text"><![CDATA[扩展中国剩余定理的裸题，但是好难写啊。 传送门洛谷P4774 BZOJ5418 题解首先，可以写个平衡树来维护每次面对巨龙时可选的剑，并事先构造出面对每一条巨龙时用的剑的攻击力。 写个毛线平衡树，调set多省事。 然后就是EXCRT的裸题了。 由于这题的数据范围卡的比较紧，一下子没注意某个地方就爆long long了，得龟速乘。 还有就是和EXCRT的裸题不一样的是，这题要求每一条巨龙的生命值小于等于0过，所以最后还需要再扫一趟检查一遍。 细节还是比较多的，如果是蒟蒻我在现场的话，还真的不一定能AC。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273#include&lt;set&gt;#include&lt;cstdio&gt;using namespace std;typedef long long LL;const int maxn=100005;int T,n,m;LL A[maxn],P[maxn],K[maxn],ATK[maxn];multiset&lt;LL&gt; S;multiset&lt;LL&gt;::iterator p;inline LL read()&#123; LL ret=0,f=1;char ch=getchar(); while(ch&lt;'0'||ch&gt;'9')&#123;if(ch=='-')f=-f;ch=getchar();&#125; while(ch&gt;='0'&amp;&amp;ch&lt;='9')&#123;ret=ret*10+ch-'0';ch=getchar();&#125; return ret*f;&#125;LL Exgcd(LL a,LL b,LL&amp; x,LL&amp; y)&#123; if(!b)&#123;x=1;y=0;return a;&#125; LL d=Exgcd(b,a%b,x,y); LL t=x;x=y;y=t-a/b*y; return d;&#125;LL Multiply(LL x,LL y,LL TT)&#123; if(y&lt;0)&#123;x=-x;y=-y;&#125; LL ret=0,w=x; while(y) &#123; if(y&amp;1) ret=(ret+w)%TT; w=(w+w)%TT;y&gt;&gt;=1; &#125; return ret;&#125;inline void EXCRT()&#123; LL LCM=1,X=0,Y,Z,D,D2,E,F; for(int i=1;i&lt;=n;i++) &#123; D=Exgcd(ATK[i],P[i],Z,Y); if(A[i]%D)&#123;printf("%d\n",-1);return;&#125; Z=Multiply(Z,A[i]/D,P[i]/D); D2=Exgcd(LCM,P[i]/D,F,E); if((Z-X)%D2)&#123;printf("%d\n",-1);return;&#125; F=Multiply(F,(Z-X)/D2,P[i]/D/D2); X=X+Multiply(F,LCM,LCM/D2*(P[i]/D)); LCM=LCM/D2*(P[i]/D); X=(X%LCM+LCM)%LCM; &#125; for(int i=1;i&lt;=n;i++) if(X*ATK[i]&lt;A[i]) X+=(A[i]-X*ATK[i]+LCM*ATK[i]-1)/(LCM*ATK[i])*LCM; printf("%lld\n",X);&#125;int main()&#123; T=read(); while(T--) &#123; n=read();m=read();S.clear(); for(int i=1;i&lt;=n;i++) A[i]=read(); for(int i=1;i&lt;=n;i++) P[i]=read(); for(int i=1;i&lt;=n;i++) K[i]=read(); for(int i=1;i&lt;=m;i++) S.insert(read()); for(int i=1;i&lt;=n;i++) &#123; p=S.lower_bound(A[i]); if(*p==A[i])&#123;ATK[i]=*p;S.erase(p);&#125; else if(p!=S.begin())&#123;p--;ATK[i]=*p;S.erase(p);&#125; else&#123;ATK[i]=*S.begin();S.erase(S.begin());&#125; S.insert(K[i]); &#125; EXCRT(); &#125; return 0;&#125;]]></content>
      <categories>
        <category>EXCRT</category>
      </categories>
      <tags>
        <tag>平衡树</tag>
        <tag>set</tag>
        <tag>EXCRT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「SCOI2009」迷路]]></title>
    <url>%2F2019%2F06%2F01%2F%E3%80%8CSCOI2009%E3%80%8D%E8%BF%B7%E8%B7%AF-Solution%2F</url>
    <content type="text"><![CDATA[原来是矩乘！ 传送门洛谷P4159 BZOJ1297 题解先来考虑如果边权全都为$1$怎么处理。 设$G[i][j][k]$表示从$i$走到$j$，步数恰好为$k$的方案数。 不难推出转移方程： G[i][j][k]=\sum_{t=1}^{n}G[i][t][k-1]*G[t][j][1]而这正是一个矩阵乘法的式子。 令转移矩阵为$F$，其中$F[i][j]$表示从$i$一步走到$j$的方案数。如果$i,j$之间有边则$F[i][j]=1$，否则$F[i][j]=0$。 所以有答案矩阵$G_T=F^T$，矩阵快速幂即可。 还有就是由于原题中边权不一定为$1$，但是小于等于$9$。 所以可以暴力拆点，把每个点拆成$9$个点，然后就可以把所有边的边权转化为$1$了。 时间复杂度$O((9n)^3\log T)$。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include&lt;cstdio&gt;#include&lt;cstring&gt;using namespace std;const int maxn=100,TT=2009;int n,T;int GetC()&#123; char ch=getchar(); while(ch&lt;'0'||ch&gt;'9') ch=getchar(); return ch-'0';&#125;struct Matrix&#123; int n,m,a[maxn][maxn]; Matrix()&#123;n=m=0;memset(a,0,sizeof(a));&#125; Matrix operator * (const Matrix&amp; b) &#123; Matrix c; c.n=n;c.m=b.m; for(int i=1;i&lt;=c.n;i++) for(int j=1;j&lt;=c.m;j++) for(int k=1;k&lt;=m;k++) c.a[i][j]=(c.a[i][j]+a[i][k]*b.a[k][j])%TT; return c; &#125;&#125;F,G;Matrix QP(Matrix a,int b)&#123; Matrix ret=a,w=a;b--; while(b) &#123; if(b&amp;1) ret=ret*w; w=w*w;b&gt;&gt;=1; &#125; return ret;&#125;int main()&#123; scanf("%d%d",&amp;n,&amp;T); for(int i=1;i&lt;=n;i++) &#123; for(int j=1;j&lt;=n;j++) &#123; int C=GetC(); if(C!=0) F.a[(i-1)*9+1][(j-1)*9+C]=1; &#125; &#125; for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;9;j++) F.a[(i-1)*9+j+1][(i-1)*9+j]=1; F.n=F.m=n*9; G=QP(F,T); printf("%d\n",G.a[1][(n-1)*9+1]); return 0;&#125;]]></content>
      <categories>
        <category>矩阵乘法</category>
      </categories>
      <tags>
        <tag>矩阵乘法</tag>
        <tag>拆点</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「TJOI2017」城市]]></title>
    <url>%2F2019%2F05%2F28%2F%E3%80%8CTJOI2017%E3%80%8D%E5%9F%8E%E5%B8%82-Solution%2F</url>
    <content type="text"><![CDATA[正解复杂度为$O(n^2)$的题感觉越来越少了QwQ。 传送门洛谷P3761 BZOJ4890 题解首先比较显然的是断开的边一定是在直径上的。 所以可以枚举直径上断开的边，然后考虑怎样连边才能使之后的最远距离最小。 可以对断开边之后的两棵子树分别进行树形DP，求出每棵子树中与每个点距离最远的点的距离。 那么新连的边的两个端点必定为两棵子树中与该点的最远距离最小的点。 这样连边后的直径为两个端点的最远距离之和加上新连边的长度。 注意新的直径不能比两棵子树的直径小。 代码写的又臭又长QwQ。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;const int maxn=5005,inf=0x3F3F3F3F;int n,tot,lnk[maxn],son[maxn*2],w[maxn*2],nxt[maxn*2],idx,dfn[maxn],siz[maxn],sum,rt,Ver[maxn],E[maxn],u,v,ans,F[maxn][4];bool flg,vis[maxn*2];inline int read()&#123; int ret=0,f=1;char ch=getchar(); while(ch&lt;'0'||ch&gt;'9')&#123;if(ch=='-')f=-f;ch=getchar();&#125; while(ch&gt;='0'&amp;&amp;ch&lt;='9')&#123;ret=ret*10+ch-'0';ch=getchar();&#125; return ret*f;&#125;inline void add_e(int x,int y,int z)&#123;tot++;son[tot]=y;w[tot]=z;nxt[tot]=lnk[x];lnk[x]=tot;&#125;void DFS(int now,int fa,int dist)&#123; if(dist&gt;sum)&#123;sum=dist;rt=now;&#125; for(int i=lnk[now];i;i=nxt[i]) if(son[i]!=fa) DFS(son[i],now,dist+w[i]);&#125;void DFS2(int now,int fa)&#123; dfn[now]=++idx;siz[now]=1; if(!flg) Ver[++Ver[0]]=now; if(now==v)&#123;flg=true;return;&#125; for(int i=lnk[now];i;i=nxt[i]) &#123; if(son[i]!=fa) &#123; if(!flg) E[++E[0]]=i; DFS2(son[i],now); siz[now]+=siz[son[i]]; if(!flg) E[0]--; &#125; &#125; if(!flg) Ver[0]--;&#125;void DFS3(int now,int fa)&#123; for(int i=lnk[now];i;i=nxt[i]) &#123; if(son[i]!=fa&amp;&amp;!vis[i]) &#123; DFS3(son[i],now); if(F[son[i]][0]+w[i]&gt;=F[now][0]) &#123; F[now][2]=F[now][0]; F[now][3]=F[now][1]; F[now][0]=F[son[i]][0]+w[i]; F[now][1]=son[i]; &#125; else if(F[son[i]][0]+w[i]&gt;F[now][2]) &#123; F[now][2]=F[son[i]][0]+w[i]; F[now][3]=son[i]; &#125; if(F[son[i]][2]+w[i]&gt;F[now][2]&amp;&amp;son[i]!=F[now][1]) &#123; F[now][2]=F[son[i]][2]+w[i]; F[now][3]=son[i]; &#125; &#125; &#125;&#125;void DFS4(int now,int fa)&#123; for(int i=lnk[now];i;i=nxt[i]) &#123; if(son[i]!=fa&amp;&amp;!vis[i]) &#123; if(F[now][1]!=son[i]) &#123; if(F[now][0]+w[i]&gt;=F[son[i]][0]) &#123; F[son[i]][2]=F[son[i]][0]; F[son[i]][3]=F[son[i]][1]; F[son[i]][0]=F[now][0]+w[i]; F[son[i]][1]=now; &#125; else if(F[now][0]+w[i]&gt;F[son[i]][2]) &#123; F[son[i]][2]=F[now][0]+w[i]; F[son[i]][3]=now; &#125; &#125; if(F[now][3]!=son[i]&amp;&amp;F[now][2]+w[i]&gt;=F[son[i]][0]) &#123; F[son[i]][2]=F[son[i]][0]; F[son[i]][3]=F[son[i]][1]; F[son[i]][0]=F[now][2]+w[i]; F[son[i]][1]=now; &#125; else if(F[now][3]!=son[i]&amp;&amp;F[now][2]+w[i]&gt;=F[son[i]][2]) &#123; F[son[i]][2]=F[now][2]+w[i]; F[son[i]][3]=now; &#125; DFS4(son[i],now); &#125; &#125;&#125;inline void Solve()&#123; for(int i=1;i&lt;Ver[0];i++) &#123; vis[E[i]]=vis[(E[i]&amp;1)?E[i]+1:E[i]-1]=true; memset(F,0,sizeof(F)); DFS3(Ver[i],0);DFS3(Ver[i+1],0); DFS4(Ver[i],0);DFS4(Ver[i+1],0); int Max=0,Min1=inf,Min2=inf; for(int j=1;j&lt;=n;j++) &#123; if(dfn[Ver[i]]&lt;=dfn[j]&amp;&amp;dfn[j]&lt;=dfn[Ver[i]]+siz[Ver[i]]) Min1=min(Min1,F[j][0]); else Min2=min(Min2,F[j][0]); Max=max(Max,F[j][0]); &#125; if(max(Max,Min1+Min2+w[E[i]])&lt;ans) ans=max(Max,Min1+Min2+w[E[i]]); vis[E[i]]=vis[(E[i]&amp;1)?E[i]+1:E[i]-1]=false; &#125;&#125;int main()&#123; n=read(); for(int i=1;i&lt;n;i++) &#123; int a=read(),b=read(),c=read(); add_e(a,b,c);add_e(b,a,c); &#125; DFS(1,0,0);sum=0;u=rt; DFS(u,0,0);ans=sum;v=rt; DFS2(u,0); Solve(); printf("%d\n",ans); return 0;&#125;]]></content>
      <categories>
        <category>树的直径</category>
      </categories>
      <tags>
        <tag>DFS</tag>
        <tag>树的直径</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「SDOI2011」消防]]></title>
    <url>%2F2019%2F05%2F27%2F%E3%80%8CSDOI2011%E3%80%8D%E6%B6%88%E9%98%B2-Solution%2F</url>
    <content type="text"><![CDATA[树的直径怎么求？拿出软尺，往树干上一绕，读出示数，再除以π就好了。 传送门洛谷P2491 BZOJ2282 题解首先，只要直径上存在一条小于$s$的边，那么答案中选择的路径必定在直径上。 所以只要将直径求出来，然后从将两个端点依次往里移动，直到当前路径的长度小于等于$s$时，此时的路径就是答案。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;const int maxn=300005,inf=0x3F3F3F3F;int n,s,tot,lnk[maxn],son[maxn*2],nxt[maxn*2],w[maxn*2],rt,sum,u,v,Ver[maxn],E[maxn],Min[maxn],F[maxn],Max;bool flg,vis[maxn];inline int read()&#123; int ret=0,f=1;char ch=getchar(); while(ch&lt;'0'||ch&gt;'9')&#123;if(ch=='-')f=-f;ch=getchar();&#125; while(ch&gt;='0'&amp;&amp;ch&lt;='9')&#123;ret=ret*10+ch-'0';ch=getchar();&#125; return ret*f;&#125;inline void add_e(int x,int y,int z)&#123;tot++;son[tot]=y;w[tot]=z;nxt[tot]=lnk[x];lnk[x]=tot;&#125;void DFS(int now,int fa,int dist)&#123; if(dist&gt;sum)&#123;sum=dist;rt=now;&#125; for(int i=lnk[now];i;i=nxt[i]) if(son[i]!=fa) DFS(son[i],now,dist+w[i]);&#125;void DFS2(int now,int fa)&#123; Ver[++Ver[0]]=now;vis[now]=true; if(now==v)&#123;flg=true;return;&#125; for(int i=lnk[now];i&amp;&amp;!flg;i=nxt[i]) if(son[i]!=fa) &#123;E[++E[0]]=i;DFS2(son[i],now);if(!flg)E[0]--;&#125; if(!flg)&#123;Ver[0]--;vis[now]=false;&#125;&#125;void DFS3(int now,int fa,int rot,int dist)&#123; for(int i=lnk[now];i;i=nxt[i]) &#123; if(son[i]!=fa&amp;&amp;!vis[son[i]]) &#123; DFS3(son[i],now,rot,dist+w[i]); if(w[i]&lt;=s&amp;&amp;dist&lt;Min[rot]) Min[rot]=dist; if(F[son[i]]+w[i]&gt;F[now]) F[now]=F[son[i]]+w[i]; &#125; &#125;&#125;inline int Solve()&#123; int L=1,R=Ver[0],D1=0,D2=0,ret=inf; while(L&lt;=Ver[0]&amp;&amp;R&gt;=1) &#123; if(L&lt;R&amp;&amp;sum-D1-D2&lt;=s) return max(Max,max(D1,D2)); if(L&gt;=R) &#123; if(max(D1,sum-D1)+Min[Ver[L]]&lt;ret)&#123;ret=max(D1,sum-D1)+Min[Ver[L]];D1+=w[E[L]];L++;&#125; if(max(D2,sum-D2)+Min[Ver[R]]&lt;ret)&#123;ret=max(D2,sum-D2)+Min[Ver[R]];D2+=w[E[R-1]];R--;&#125; &#125; if(D1+w[E[L]]&lt;=D2+w[E[R-1]])&#123;D1+=w[E[L]];L++;&#125; else&#123;D2+=w[E[R-1]];R--;&#125; &#125; return ret;&#125;int main()&#123; n=read();s=read(); for(int i=1;i&lt;n;i++) &#123; int a=read(),b=read(),c=read(); add_e(a,b,c);add_e(b,a,c); &#125; memset(Min,63,sizeof(Min)); DFS(1,0,0);u=rt;sum=0; DFS(rt,0,0);v=rt; DFS2(u,0); for(int i=1;i&lt;=Ver[0];i++) &#123; DFS3(Ver[i],0,Ver[i],0); if(F[Ver[i]]&gt;Max) Max=F[Ver[i]]; &#125; printf("%d\n",Solve()); return 0;&#125;]]></content>
      <categories>
        <category>树的直径</category>
      </categories>
      <tags>
        <tag>DFS</tag>
        <tag>树的直径</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「JLOI2014」聪明的燕姿]]></title>
    <url>%2F2019%2F05%2F19%2F%E3%80%8CJLOI2014%E3%80%8D%E8%81%AA%E6%98%8E%E7%9A%84%E7%87%95%E5%A7%BF-Solution%2F</url>
    <content type="text"><![CDATA[大法师出奇迹！ 传送门洛谷P4397 BZOJ3629 题解对于一个数$X$对它分解质因数： X=p_1^{c_1}p_2^{c_2}\cdots p_k^{c_k}则有： \sum_{d|X}d=\prod_{i=1}^{k}{\sum_{j=0}^{c_k}{p_i^j}}所以可先把所有小于$\sqrt{S}$质数筛出来。 然后暴力搜索每个因子的个数。 最后那个大于$\sqrt{S}$的质因子，暴力判一下即可。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;typedef long long LL;int S,p[4700],tot,ans[10000000];bool vis[45000];inline void make_p()&#123; vis[0]=vis[1]=true; for(int i=2;i&lt;=45000;i++) &#123; if(!vis[i]) p[++p[0]]=i; for(int j=1;j&lt;=p[0]&amp;&amp;p[j]*i&lt;=45000;j++) &#123; vis[i*p[j]]=true; if(i%p[j]==0) break; &#125; &#125;&#125;inline bool IsPrime(int x)&#123; for(int i=2;i*i&lt;=x;i+=(i&amp;1)+1) if(x%i==0) return false; return true;&#125;void DFS(int pn,int SN,int Num)&#123; if(SN==1) &#123; ans[++tot]=Num; return; &#125; if(SN&gt;p[pn]&amp;&amp;IsPrime(SN-1)) ans[++tot]=Num*(SN-1); //特判 for(int i=pn;p[i]*p[i]&lt;=SN;i++) //枚举因子 &#123; LL t=p[i],sum=p[i]+1; for(;sum&lt;=SN;t*=p[i],sum+=t) //枚举因子个数 if(SN%sum==0) DFS(i+1,SN/sum,Num*t); &#125;&#125;int main()&#123; make_p(); while(scanf("%d",&amp;S)==1) &#123; tot=0;DFS(1,S,1); printf("%d\n",tot); sort(ans+1,ans+1+tot); for(int i=1;i&lt;=tot;i++) printf("%d%c",ans[i],i==tot?'\n':' '); &#125; return 0;&#125;]]></content>
      <categories>
        <category>DFS</category>
      </categories>
      <tags>
        <tag>DFS</tag>
        <tag>分解质因数</tag>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「CF311B」 Cats Transport]]></title>
    <url>%2F2019%2F05%2F14%2F%E3%80%8CCF311B%E3%80%8DCats-Transport%20-Solution%2F</url>
    <content type="text"><![CDATA[喵喵喵，斜率优化带猫猫早早回家。 传送门洛谷 CF311B 题解首先定义： dist[i]=\sum_{j=1}^{i}{d[j]}\\ A[i]=T[i]-dist[H[i]]\\ S[i]=\sum_{j=1}^{i}{A[j]}其中要先对A数组从小到大排序再计算前缀和。这样每个饲养员带走的必定为连续的几只猫。 定义$F[i][j]$表示前$i$个饲养员带走了前$j$只猫时的最小等待时间之和。转移方程为： F[i][j]=min(F[i-1][k]+A[j]*(j-k)-(S[j]-S[k]));但是直接这样转移的话复杂度太高，考虑斜率优化。可以把转移方程写成直线的形式： F[i-1][k]+S[k]=A[j]*k+F[i][j]-A[j]*j+S[j]这样就可以把$F[i-1][k]+S[k]$看作纵坐标，$k$看作横坐标，$A[j]$看成斜率。然后用单调队列维护一个斜率递增的下凸壳就行了。 代码挺短的QwQ。 1234567891011121314151617181920212223242526272829303132333435363738394041#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;typedef long long LL;const int maxn=100005;const LL inf=0x3F3F3F3F3F3F3F3Fll;int n,m,P,H[maxn],D[maxn],T[maxn],A[maxn],que[maxn],hed,til;LL S[maxn],F[105][maxn];inline int read()&#123; int ret=0,f=1;char ch=getchar(); while(ch&lt;'0'||ch&gt;'9')&#123;if(ch=='-')f=-f;ch=getchar();&#125; while(ch&gt;='0'&amp;&amp;ch&lt;='9')&#123;ret=ret*10+ch-'0';ch=getchar();&#125; return ret*f;&#125;int main()&#123; n=read();m=read();P=read(); for(int i=2;i&lt;=n;i++) D[i]=D[i-1]+read(); for(int i=1;i&lt;=m;i++) &#123; H[i]=read(); T[i]=read(); A[i]=T[i]-D[H[i]]; &#125; sort(A+1,A+1+m); for(int i=1;i&lt;=m;i++) S[i]=S[i-1]+A[i]; for(int i=1;i&lt;=m;i++) F[0][i]=inf; for(int i=1;i&lt;=P;i++) &#123; hed=til=1;que[1]=0; for(int j=1;j&lt;=m;j++) &#123; while(hed&gt;til&amp;&amp;(F[i-1][que[til+1]]+S[que[til+1]]-F[i-1][que[til]]-S[que[til]])&lt;=(LL)A[j]*(que[til+1]-que[til])) til++; F[i][j]=F[i-1][que[til]]+(LL)A[j]*(j-que[til])-(S[j]-S[que[til]]); while(hed&gt;til&amp;&amp;(F[i-1][j]+S[j]-F[i-1][que[hed]]-S[que[hed]])*(que[hed]-que[hed-1])&lt;=(F[i-1][que[hed]]+S[que[hed]]-F[i-1][que[hed-1]]-S[que[hed-1]])*(j-que[hed])) hed--; que[++hed]=j; &#125; &#125; printf("%lld\n",F[P][m]); return 0;&#125;]]></content>
      <categories>
        <category>斜率优化DP</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>斜率优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「SCOI2010」股票交易]]></title>
    <url>%2F2019%2F05%2F13%2F%E3%80%8CSCOI2010%E3%80%8D%E8%82%A1%E7%A5%A8%E4%BA%A4%E6%98%93-Solution%2F</url>
    <content type="text"><![CDATA[单调队列是个好东西。 传送门洛谷P2569 BZOJ1855 题解很容易想到一个DP： $F[i][j]$表示到了第$i$天结束时，手上有$j$只股票，能赚到的最多的钱。 直接暴力转移需要枚举上上一次交易的时间和上一次交易后手上的股票数，这样时间复杂度时$\Theta(n^4)$的。 但是如果枚举到每一个状态时都加上一句$F[i][j]=max(F[i][j],F[i-1][j]);$的话，这样只要从第$i-W-1$天转移过来就行，复杂度降到$\Theta(n^3)$。 仔细思考之后不难发现，对于所有状态$F[i-W-1][j]$，把手上的股票按照第$i$天的价格来折算成钱之后，可以通过一个单调队列来找最优的状态来转移，然后就优化到了$\Theta(n^2)$。可以过了。 代码蒟蒻我写单调队列的方式有点奇葩，所以特别丑Q$\omega$Q。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;const int maxn=2005,inf=0x3F3F3F3F;int n,m,W,AP[maxn],BP[maxn],AS[maxn],BS[maxn],que[maxn],F[maxn][maxn];inline int read()&#123; int ret=0,f=1;char ch=getchar(); while(ch&lt;'0'||ch&gt;'9')&#123;if(ch=='-')f=-f;ch=getchar();&#125; while(ch&gt;='0'&amp;&amp;ch&lt;='9')&#123;ret=ret*10+ch-'0';ch=getchar();&#125; return ret*f;&#125;int main()&#123; n=read();m=read();W=read(); for(int i=1;i&lt;=n;i++)&#123;AP[i]=read();BP[i]=read();AS[i]=read();BS[i]=read();&#125; memset(F,192,sizeof(F)); for(int i=1;i&lt;=W+1;i++) for(int j=0;j&lt;=m;j++) F[i][j]=max(F[i-1][j],j&lt;=AS[i]?-AP[i]*j:-inf); for(int i=W+2;i&lt;=n;i++) &#123; int hed=0,til=1; for(int j=m;j&gt;=m-AS[i];j--) &#123; while(hed&gt;=til&amp;&amp;F[i-W-1][j]&gt;=F[i-W-1][que[hed]]+(que[hed]-j)*AP[i]) hed--; que[++hed]=j; &#125; for(int j=m;j&gt;=0;j--) &#123; while(til&lt;=hed&amp;&amp;que[til]&gt;j) til++; F[i][j]=max(F[i][j],F[i-1][j]); if(j&lt;=AS[i]) F[i][j]=max(F[i][j],-j*AP[i]); F[i][j]=max(F[i][j],F[i-W-1][que[til]]-AP[i]*(j-que[til])); if(j&gt;AS[i]) &#123; while(hed&gt;=til&amp;&amp;F[i-W-1][j-1-AS[i]]&gt;=F[i-W-1][que[hed]]+(que[hed]-(j-1-AS[i]))*AP[i]) hed--; que[++hed]=j-1-AS[i]; &#125; &#125; hed=0;til=1; for(int j=0;j&lt;=BS[i];j++) &#123; while(hed&gt;=til&amp;&amp;F[i-W-1][j]&gt;=F[i-W-1][que[hed]]-(j-que[hed])*BP[i]) hed--; que[++hed]=j; &#125; for(int j=0;j&lt;=m;j++) &#123; while(til&lt;=hed&amp;&amp;que[til]&lt;j) til++; F[i][j]=max(F[i][j],F[i-W-1][que[til]]+BP[i]*(que[til]-j)); if(j+BS[i]&lt;m) &#123; while(hed&gt;=til&amp;&amp;F[i-W-1][j+1+BS[i]]&gt;=F[i-W-1][que[hed]]-(j+1+BS[i]-que[hed])*BP[i]) hed--; que[++hed]=j+1+BS[i]; &#125; &#125; &#125; printf("%d\n",F[n][0]); return 0;&#125;]]></content>
      <categories>
        <category>单调队列优化DP</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>单调队列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「APIO2007」动物园]]></title>
    <url>%2F2019%2F05%2F06%2F%E3%80%8CAPIO2007%E3%80%8D%E5%8A%A8%E7%89%A9%E5%9B%AD-Solution%2F</url>
    <content type="text"><![CDATA[数据范围这么大，压个毛线啊！ 传送门洛谷P3622 BZOJ1151 题解这题的数据范围挺大的。 但是每个小朋友只能看到连续的$5​$个围栏。 所以考虑状压DP。 $F[i][j]$表示围栏$i,i+1,i+2,i+3,i+4$的状态为$j$时，站在前$i$个位置中的小朋友最多有几个开心。 转移方程还是比较容易就能写出来的，但是由于这是一个环，相接的部分比较难搞。 由于$2^5=32$还是比较小的，直接暴力枚举前5个位置的状态，然后刷多次DP就好了。 代码123456789101112131415161718192021222324252627282930313233343536373839#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;const int maxn=10005;int n,C,F[maxn][35],W[maxn][35],ans;inline int read()&#123; int ret=0,f=1;char ch=getchar(); while(ch&lt;'0'||ch&gt;'9')&#123;if(ch=='-')f=-f;ch=getchar();&#125; while(ch&gt;='0'&amp;&amp;ch&lt;='9')&#123;ret=ret*10+ch-'0';ch=getchar();&#125; return ret*f;&#125;int main()&#123; n=read();C=read(); for(int i=1;i&lt;=C;i++) &#123; int E=read(),F=read(),L=read(),S1=0,S2=0; for(int j=1;j&lt;=F;j++) S1|=(1&lt;&lt;((read()-E+n)%n)); for(int j=1;j&lt;=L;j++) S2|=(1&lt;&lt;((read()-E+n)%n)); for(int j=0;j&lt;32;j++) if((j&amp;S2)||((~j)&amp;S1)) W[E][j]++; &#125; for(int s=0;s&lt;32;s++) &#123; memset(F[0],192,sizeof(F[0])); F[0][s]=0; for(int i=1;i&lt;=n;i++) for(int j=0;j&lt;32;j++) F[i][j]=max(F[i-1][(j&amp;15)&lt;&lt;1],F[i-1][(j&amp;15)&lt;&lt;1|1])+W[i][j]; if(F[n][s]&gt;ans) ans=F[n][s]; &#125; printf("%d\n",ans); return 0;&#125;]]></content>
      <categories>
        <category>状态压缩DP</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>状态压缩</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「华东师范大学ACM」游记]]></title>
    <url>%2F2019%2F04%2F27%2F%E3%80%8C%E5%8D%8E%E4%B8%9C%E5%B8%88%E8%8C%83%E5%A4%A7%E5%AD%A6ACM%E3%80%8D%E6%B8%B8%E8%AE%B0-Diary%2F</url>
    <content type="text"><![CDATA[蒟蒻我的第一场现场ACM。 Day1-2019.04.26今天早上是ZJOI2019的二试，考完试就和老叶以及其他几个同学来到了余姚北火车站。 到火车站的时间也挺早的，离出发还有一个多小时。 候车室的座位差不多都坐满了，找不到连着的几个空座位。 终于找到位置了，赶紧坐下来。 然后余智旺把电脑拿了出来搞事情，赶紧把他安排好。 过了好久，终于到了检票上车的时候。过了检票口，来到了位于车站顶部的站台。不知道余姚北车站为什么把站台弄在候车室的顶上，火车开过的时候感觉会很吵。 一辆不停车的高铁高速驶过了站台。那速度，风驰电掣的，差点就有黄霖切题的速度快了。 然后跟着黄霖走，走着走着看到了下脚下的标识，怎么到了14车了？我们的座位可是在2车的呀！差点就被黄霖带到坑里了。赶紧跑步跑到了2车的上车位置，才发现老叶在哪儿一脸笑容地等着我们。 坐上高铁，到了上海虹桥火车站。这个站叫一个大。老叶和义乌的老师带着我们一帮人坐地铁到了宾馆。此时正值高峰期，地铁上挤死了。又过了好久才到了宾馆。 到了宾馆，发现另一批从衢州出发的大佬早已经到了。扔下行李之后和大家一起去大学里吃晚饭。 晚饭感觉海星。 然后去试机。 去试机的时候其实已经很迟了，看了下电脑，Dell的。CPU是Core i7-6700，16GB的内存，Dell P2417H的显示器，而且显示器有“想怎么转就怎么转”支架，好评。 随便写了个A+B，发现Dev-C++一调试就Boom。 才发现自己不会用gdb的命令。 热身赛就随便做了几道题，然后就结束了。 晚上回宾馆，照例先放佛经，净化心灵，祈求保佑。 房间里的网线用不了，WiFi又卡的要死，差评。 晚上挺晚才睡的，但愿明天能有个好成绩吧。 Day2-2019.04.27早上一觉睡到8点多。 08:30下去吃早饭。感觉早饭一般般，但是有盒装酸奶，好评。 然后去了华东师大。 感觉华东师大的校园还挺漂亮的。 进了计软学院，一楼有小姐姐给大家发广告衫，要求穿上比赛。 然后进了场。 发现还是不能调试，问工作人员是什么情况，结果工作人员说那可能就是不能调试的（WTF…）。 10:00比赛开始。 一开始动作有点慢，看到A题挺简单的，就是给出一个例如“996”的字符串表示工作制度，然后求出此时一周的工作小时数。很多人过了，赶紧写了。但是因为我太菜了，还写挂了，过不了样例。由于没法调试，静态查了2分钟才发现问题所在，赶紧改掉。等我提交时已经有很多人过了。不过还好1A，要是WA了就完蛋了。 然后看到H题AC的人挺多的，点开一看，有是很水的。就是算一下等差数列。一下就AC了。 然后看F题AC的人还是比较多，点开看了一下，直接Hash+STL map就行了。也一下就AC了。 此时蒟蒻我已近不知道接下来开哪一道题了。刷新了几下看到有一个人AC了L题。于是点开看了下。想了一下发现直接贪心就行。写完过了样例马上交，也是一次性AC。此时蒟蒻我已经做了4题了。距离比赛开始一个多小时。看下排行榜好像到了20多名。 前面有小姐姐和小哥哥，每AC一道题就给挂一面彩旗或者挂一个气球。感觉还是挺惊险刺激的。 中午工作人员发了一包豆沙面包，台式烤香肠，一瓶农夫山泉，还有一盒牛奶。感觉体验不错。 然后看到I题有人AC，点开看了一下，一开始的想法就是直接上Floyd瞎搞。搞了半天总是WA。弄得我都想放弃了。看到B题有好多人过，赶紧点开看一看。 发现是个概率题。蒟蒻我并不会做。仔细思考了一下，发现了一些性质。赢的概率主要取决于双方都各有一张的牌的数量。然后写了个DFS来爆搜打表找关系。发现随着牌的数量的增加，赢得概率就是一串非常有规律的分数。我自己想了一下，认为当牌的数量趋近于$+\infty$时，赢的概率应该趋近于$\frac{1}{2}$。并且之前发现的规律正与之相符。我想应该不会错了，马上写了代码。 尴尬的是写完代码发现连样例都过不了，但是我仔细思考了之后坚信我写的DFS没有问题。于是抱着侥幸心理，我想说不定是样例错了。赶紧交了一发。结果很显然，WA了。 我又仔细检查了一下爆搜，还是觉得没有问题。保佑侥幸心理的我修改了答案的表达式，又交了几次，照样WA。 由于实在找不到我写的DFS哪里有问题，蒟蒻我便手推极限，但尴尬的是推出来还是和样例不一样。 此时的我已近有点想要放弃了，但是之前找到的规律看起来实在是太对了，使我又不想轻易放弃。我想我应该是题意理解错了。于是我只好又认真重新读了几遍题目，但是还是一无所获。 我便又看了看大家的提交记录，发现有些AC代码所用的空间高达20多MB，但是我的想法直接一个式子一算就好了。我开始严重怀疑我做题方向的正确性。 于是蒟蒻我又在这题上乱搞了很久。看着不断下降的名次，蒟蒻我心急如焚，但是又无能为力。 突然，我发现所谓的“魔法婆婆”牌所属对象与先手一方一共会构成四种情况，而不是简单的两种。蒟蒻我用DFS试了一下，剩余的一种情况下获胜的概率同样也为一串十分有规律的分数数列。 终于发现问题所在了。蒟蒻我赶紧重写了代码，这次终于AC了。蒟蒻我长舒一口气。此时只剩下半个多小时了。 然后回头看之前丢下的I题，发现AC的人更加多了。我仔细思考了一下，发现直接用Floyd乱搞很可能会构造出不合法的解。又想了一下，发现已知相互间距离的点可以认为在同一个联通块里，块与块之间只随便拉一条边的话肯定就能合法。于是我又写了一个并查集，然后终于过了。 回头一看排名，30多，感觉海星。离比赛结束没几分钟了。我变坐着休息了一下。这时小姐姐又走过来给我挂了一个气球。 这次个人ACM一共做了6道题，虽然还是很少，但是对于我自己来说我还是满意了，毕竟我实在是太菜了。 然后是中学组的颁奖会。看了下排行榜，最终排名33，中学组内排第8，勉强混了个一等奖。被上海省队虐爆了。 发奖品之前华东师大的老师先介绍了一下他们的计软学院。还给每个人送了一个布袋子，里面有一个笔记本和华东师大的报考指南（暴露本意）。 优胜奖的奖品是一个32GB的爱国者U盘，三等奖是小米的U型枕，二等奖是小米充电宝，一等奖是爱国者录音笔。不送机械键盘，差评。 颁完奖，合影留念后，我们便原路返回到上海虹桥火车站。此时又是高峰期，地铁挤得很。 晚饭就在火车站买了个汉堡吃了，20块钱，血亏。 火车晚上7点多开，到衢州已经快晚上10点了。一波三折之后终于到了家。 P.S. 事后听老叶说好像被华东师大的老师盯上了]]></content>
      <categories>
        <category>游记</category>
      </categories>
      <tags>
        <tag>游记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「ZJOI2019」游记]]></title>
    <url>%2F2019%2F04%2F26%2F%E3%80%8CZJOI2019%E3%80%8D%E6%B8%B8%E8%AE%B0-Diary%2F</url>
    <content type="text"><![CDATA[一个蒟蒻的ZJOI游记。 Round1Day1-2019.03.24今天早上8点过就早早到了机房，发现只有神仙黄霖和蒟蒻我。 过了一会儿8:30过了大家都到了。9:00左右乘车出发。 出发前和神仙赵章恺合个影沾点RP。 中午服务区吃饭，吃了一个十块钱的烤饼，血亏。 下午1点多钟到了镇海，先去了宾馆，老叶直接制定了宿舍分配方案，我有幸和哥哥陈浩杰分到一起。房间在二楼，进了房间，卧槽，一个硕大的CRT电视出现在了面前，连个HDMI接口都没有，看来电脑不能接到电视上爽了。差评。 然后去了填海镇海中学，镇中的建筑风格我真是欣赏不来，古色古香的。 报到领了狗牌、餐票，听说伙食贼差，不知道是不是真的。 门口有免费的旅游手册，好评。 学校里有小姐姐夹道欢迎，好评。 去了报告厅参加颁奖大会（然而并没有蒟蒻我的奖，可能是因为今年收不到钱了，所以没几个人有奖）。看到了兴华的郭老师和杭二的李建老师上台领奖。 然后又回到了宾馆。尝试联网，发现网速贼慢。就将就着用吧。 晚饭是在镇中的食堂吃的，老叶给一个寝室买了一套饭票，让大家轮流到外面吃。一张票25块钱，有点小贵。一顿是两荤两素一水果。对于平时在学校里一荤一素都吃不完的我来说有点多。味道一般吧。 晚上在宾馆做了几道题，其中有一道是网络流24题之一的餐巾计划问题的加强版，数据范围直接加上了两个0。这回真的是没法n方过百万了。陈浩杰看了一下题解，发现直接三分加贪心就好了，比网络流还好搞。写好一交结果不知什么原因就排到BZOJ的rank2了，然后又写了个读优就rank1了。陈浩杰又调了一会儿才过。东弄一下西搞一下就晚上11点多了，赶紧睡觉。 Day2-2019.03.25早上6:00钟的闹钟准时叫醒了自己，想再睡一会，结果就一觉睡到了7点钟。还好小威来叫了哥哥又叫了我，不然又要迟到了。 早饭是酒店里吃的，一般般。 早上集训队爷罗煜翔大佬给大家讲课。 先讲了下降幂的定义等，然后就是与下降幂形式多项式相关的一大坨东西。 蒟蒻我实在是太菜了，基本上全程掉线。 9:40左右休息了一下，然后又开始讲斯特林数。 斯特林数又被集训队爷写成了下降幂的形式。 讲了斯特林数单行的求法。 多项式平移。 斯特林数列的求法。 斯特林数单个的求法。 我数学还是太差了，真的没办法。 中午在外面吃的，吃了一碗红烧牛肉面，牛肉贼多，弄得我都开始怀疑是不是牛肉了。 下午是杂题选讲，孔朝哲大佬讲课。 感觉还是可以听懂一些的。 有一题是BZOJ4657，昨天刚做过一个类似的题目叫做方格取数问题，于是我便一眼看出来是网络流，建模后求最小割然后转为最大流，然后用不一定合法的最优方案的值减去最大流就是答案。但是我网络流建模不咋地，所以还是没能当场建出模型然后切掉。 下午和徐锐扬、徐瀚文坐在了一起，还看见了徐安矣。 不可思议的是我这机子竟然用了一天还是有电。 食堂吃了晚饭，然后去试机。 机子的显示器长宽比例很有问题，是5:4的，1280*1024的分辨率，差评。 键盘的手感不错，好评。 机子比较老，酷睿2的处理器，只有两个框框，差评。 其他都还好，就是软件的版本也有些旧。 总之机器没有衢二的好。 晚上回了宾馆，又写了会儿题，神仙赵章恺来了我们房间，我感觉明后天的运气不会差了。 泡了一杯宾馆里免费的雀巢咖啡喝，因为怕苦，咖啡放得很少，而糖放得很多。感觉味道不错。 今天睡得比昨天早，打算明天早一点起来。 Day3-2019.03.26今天早上5点半左右就醒了，春分刚过，太阳很早就出来了。又在床上躺了一会儿，6点过便起来了。早上也没干什么事，就看了一下板子。然后早早地就下楼去吃早饭。吃了早饭还是挺早的，又回房间待了一会儿，然后和大家一起出发去镇中。 早上是范致远大佬讲课。又是杂题选讲。 有一道题是以前在二中NOIP模拟赛的题，叫Maximum Tree Path，赵章恺上台切掉了，直接暴力枚举gcd然后动态加边维护直径即可。 还有一道题叫做“Count on a Treap ”，赵章恺以前准备NOIP的时候做过，就给我讲了一下，感觉还是不怎么难的，然后我就上台口胡了。这题再想清楚一些性质之后就转化为了动态维护最长上升子序列，弄个线段树瞎搞一下就好了。 ZJOI每年任务：上台口胡（1/1） 中午跑到外面吃了一碗脆皮鸡米饭，一般般。 下午是一位从来没有听说过名字的大佬给我们讲随机算法。 讲到了DZY lovs Chinese II，然后衢州二中初三神仙华外之光黄霖便上台秒了此题。 还讲到了什么Pollard Rho算法，这个算法以前听同学讲过，晚上就看到神仙学弟徐锐扬在切这个算法的模板题了。 下午讲课的时候讲课人给大家下了半个小时的课，然后我就看到很多听得不耐烦的人走了。我便去找徐瀚文大佬，还看到了Dilute、张亲翰、欧阳锳杰、邵嘉男、memset0等大佬。之前只是在网上听过他们的名字，这回还真让我见到了。结果因为一些原因差点被他们一起阿掉。 下午的课讲完之后，老叶请大家到学校边上的一家饭店吃饭，菜挺多的，还有海鲜，吃饭的时候我们这桌一直在互相fake。老叶说今年省选可能会比较简单，蒟蒻我的内心又划过一丝凉意。和徐锐扬开玩笑说如果明天我爆零了他就发三张女装照，没爆零我就发三张女装照。 吃完晚饭，去边上的一鸣真鲜奶吧买了个面包当做明天考试的时候的点心，然后就回宾馆了。 晚上感觉挺紧张的，明天就要省选考试了，不知道会不会爆零。更不知道能不能苟到二试。希望能考好点吧。晚上放了大悲咒、往生咒、般若波罗蜜多心经什么的，希望获得佛祖的保佑。 今天房间里的雀巢咖啡换了一种，看起来更高大上，泡了一点喝，还不错。 明天要考试了，今天打算再早一点睡觉。 晚上洗了个澡，就早早地躺床上了。很担心明天会不会爆零。 Day4-2019.03.27今天就是ZJOI2019的一试了。 早上准时起了床，看了会儿手机。才看到学弟徐锐扬又学习到凌晨。可怕。今天怕是要被踩了。然后下去吃了早饭。因为今天是考试，所以就不带电脑了。于是把电脑放在宾馆里，调大音量，继续放大悲咒。 然后就和各路神仙一起去ZJOI考场了。 密码迟了十分钟才公布，只好先打读优板子。 密码公布之前，看了一下加密过的压缩包，发现大样例中题目的英文名并没有被加密。我去！竟然有麻将！ 密码公布之后，打开了试卷。T1果真是麻将。就是在只有一个人打的情况下，问期望的最小胡牌巡目数。想了半天，还是连$n=5$的暴力都没想到，复杂度都很假。主要还是不知道该怎样快速判断一副牌胡了没。本来想DP，但是发现复杂度过不去。后来才发现，好像直接爆搜组面子和对子就好了。终于知道20分的暴力大概怎么写了，于是蒟蒻我赶紧写掉了。样例很水，是一个叫做什么纯正九莲宝灯的牌型，随便来一张牌都能胡。但是由于复杂度实在太大，连样例都出不来。 看T2，我去又是一个叫做线段树的题。 我也没想什么高级一点的东西，直接先把20分的暴力写了。但是样例实在是太水了，一开始忘记PushDown都过了。由于每次非询问操作都会将线段树的数量扩大一倍，所以我写的大暴力的复杂度仍然是指数级的。 接着看T3，题面又臭又长，跟什minimax搜索有关。我直接看部分分，瞎写了一个复杂度又是指数级的大暴力。由于没有细想性质，到底对不对也不知道。 因为T1一个样例都没过，所以回头去造了几个小样例手玩检查正确性。不知不觉中时间就过去了。 考试结束后，出来和同学们一交流，才发现原来T1在暴枚排列的时候可以加入很多剪枝。而我却为了图方便直接调用了STL里的next_permutation()，一点剪枝也没加。加了剪枝之后说不定能有50分，而我这个最多最多也就20分了。再一次因为自己傻逼没拿全部分分。不知道他们加剪枝的会不会被卡掉。 后来听谁一说，才发现今年的三道题打的暴力都不是多项式级别的复杂度。 然后会宾馆收拾了一下，就和大家一起坐车回家了。车上老叶给大家登记了一下预计的分数，神仙蓝天朗估分90，而且T1只算了20分，如果数据稍微水一点，就100+了，估计可以进队。 哎，回想起去年ZJOI的情形，不禁想要感叹时间怎么过得这样快。感觉这一年又这样荒废掉了，我还是这么菜。以后继续努力吧。 本来按照往年惯例，成绩应该下午还在路上的时候就出来了。但是今年好像说是领导有事情，所以要过两天才能知道成绩。 回来的路上在东阳服务区休息了一下，买了个汉堡吃。一个小小的汉堡要15块钱，服务区的东西就是贵啊。 在车上继续听大悲咒，苟进二试怕是没有希望了。希望佛祖保佑我暴力不要写挂吧。 ZJOI，再见OI。 才想起了翘了许久的文化课。回去之后怕是又要垫底了。 P.S. 成绩终于在2019.04.01出来了，蒟蒻我没有翻车，但还是只有可怜的50分。 Round2Day1-2019.04.23按理来说，这一天应当就是我出发的日子。但是出于一些令我愤怒的原因，我必须先留下来准备明天初中里的实验操作考试。蒟蒻我心中有 Day2-2019.04.24早上回初中参加了实验操作考试，考完便马上和同校的徐翰文一起感到了火车站。 到站时间比较早，离出发时间还有一个多小时。于是乎就和大佬徐翰文聊起了天。聊到离出发还有10分钟的时候，便起身去检票。过检票口的时候，我抬头看了一眼屏幕，卧槽，开车前7分钟停止检票（不应该是3分钟么？？？），再一看表，发现如果再晚2分钟就上不了车了。 上了车，拿出了电脑开始搞事情。前两天发现自己博客贼卡，后来发现了是因为加载页面的时候需要调用别人网站上的一个文件，但是别人的网站现在卡的要死。把那个文件搬到自己网站上之后就不卡了。 由于直达余姚的高铁票没了，蒟蒻我只好到杭州东转车。中午到了杭州，吃了自己带的一点东西。然后就上了去余姚的车了。 到了余姚，和徐翰文一起打了一辆出租车去余姚中学。挺远的，十几公里。到了之后先去了学校边上的宾馆，把行李卸了。然后去报告厅听课。下午是杂题选讲，还有ZZQ的“水题”选讲。感觉都挺难的，蒟蒻我都做不来。 课讲完之后，我先回了宾馆，然后去试机。刚进机房的时候，我看到显示器非常薄，看上去很不错的样子。坐下来之后，看了眼键盘。我去！这键盘也忒鬼畜了吧！标准键盘布局中上下左右四个方向键上方那六个键的布局被弄得鬼样。“Delete”键老大一个，都快和“Enter”一样大了。“Home”和“End”被弄到了上面去。敲了个NTT，快被键盘折磨死了。每次想按“End”就按到“Delete”。过了好久才差不多适应了。 再看了一下显示器分辨率，1080P，不错。 看了下CPU，Core i3-7100，不错。 看了下内存，8GB，不错。 看了下硬盘，不是SSD，但是无所谓了。 但是，系统是Win7，还没有画图和扫雷，差评。 Intel第六代处理器装Win7还是经常有的事情。但是第七代还装Win7，真的差评。 不知为什么余姚中学门口的减速带上写着“Lots of money？”。 试完机，蒟蒻我和刘迅，陈浩杰等大佬去了万达吃完饭，走了好久才到。蒟蒻我吃了半个披萨，喝了一杯肥宅快乐水。黄霖一边打雀一边说他自己是神仙，而且一顿能吃一斤。蒟蒻我一听就怕。 回来的时候实在不想走路了。叫了个滴滴，带了其他三个大佬一起回了宾馆。 晚上也没搞什么事情，挺早就睡了。 Day3-2019.04.25早上起床之后和学长们去路边的小店买了煎饼果子吃。我感觉海星。 听说今天学长毛一琛讲课。听ZS提到过他几次，想想就知道肯定很强。 早上挺早就到了报告厅里，我和徐亦周坐在一起。离讲课开始还有挺长时间。今天先是一位学长讲构造题，一开始感觉还挺有趣的，到后面逐渐掉线。 然后是杂题选讲，各种听不懂，看来我还是太菜了。 中午在余姚中学的食堂吃了饭，感觉还行吧。听学长说去年余姚中学的食堂比今年差得多。吃完中饭去了趟小店，余姚中学的小店可以刷饭卡，物价普遍比较便宜，比衢二的好。神仙学长赵章恺从我这儿嫖了瓶饮料，蒟蒻我感到十分荣幸，感觉明天的运气应该不会差。 下午和哥哥陈浩杰坐在了一起。 有一个大佬讲课前先进行了自我介绍。介绍的内容包括了雀魂ID（大雾）。 又是一个又强又稳又虚伪的大佬，说是水题选讲，但我还是做不来。 有些题目其实还挺有趣的（虽然我做不来）。 后面还讲了快速求阶乘、自然数倒数和的算法。但是我在多项式方面的知识储备几乎为零。真的得好好补补了。 还有一些其他的黑科技。 蒟蒻我基本上掉线。 明天就是省选二试了，今天下午上完课之后，老叶带我们去边上的一家快餐店大家聚一起吃了顿饭。 其他同学平均每人都拿了三个菜，蒟蒻我因为太菜，吃不完，只拿了两个菜。 昨天黄霖还说他一顿能吃一斤，今天蓝天朗就说黄霖一顿能吃一机房的蒟蒻了。差点把蒟蒻我吓得半死。 晚上回了宾馆，随便做了几道水题。 有一道数位DP，调了半天没发现问题，后来才发现是模数写错了（大雾）。 睡前看了下同房间的大佬姜华锦的桌面，我去那叫一个骚啊。 同样挺早就睡了。照例今天又放了一晚上的大悲咒、往生咒和般若波罗蜜多心经。 Day4-2019.04.26考试日。 早上起床之后调大音量继续放佛经。 然后和大佬们在街边的小铺买了几个包子和一盒牛奶当早饭。 到了学校，还是挺早的，在一楼的大厅里做了一会儿，然后把余智旺的事情给安排上了（斜眼笑.jpg）。 然后进了考场。 坐在我左边的是一个小姐姐。 坐我右边的是杭二中的邵嘉男。 解压密码有点鬼畜，左边的小姐姐输了好几次才成功，脾气稍微有点暴躁。 打开试卷一看，咦？T1竟然不是麻将？说好的Day2三道题名字和Day1一模一样的呢？ T1还是一个神仙期望题。求瞎按开关把开关按到指定状态的期望步数。 我尝试着去推前两个点的式子。但是因为我太菜了，还是推不出来。 T2看起来像是一个数据结构。 我先写了用bitset的$\Theta(\frac{n^3}{\omega})$算法。 大样例开O2的话0.2s。 看时限挺宽松的，而且评测机听说不错，而且STL开O2应该挺快的，蒟蒻我就没去想$\Theta(n)$的算法。 然后看T3。 按照惯例，T3应该是计算几何，所以应该把每一个人看做一条直线。 但是我实在是太菜了，不知道怎么搞，所以还是先想暴力算法。 一开始有了一个$\Theta(n^3)$的想法，能有20分，想了一会儿发现可以降到$\Theta(n^2)$。蒟蒻我不放心，便又写了个暴力枚举$X$的算法来对拍。刚开始因为细节挂了几次，后来就拍不停了，感觉40分应该没事。 然后开始开始考虑到底是搞T1、T2还是T3。 T1的前两个点我又推了一会儿，发现还是推不出来。刚想放弃但是又觉得这20分挺诱人的。 但是蒟蒻我太菜了，终究还是推不出来。 坐在我边上的小姐姐全程把自己所有的想法都打在了一个记事本里。好像后来对拍的时候发现自己的想法是错了，然后脾气又暴躁起来。蒟蒻我都快被吓到了。 T1的部分分搞不出来，只好再去想T2、T3。 蒟蒻我多次在T2和T3间徘徊，还是没有更好的想法。 然后去骗T1的分。 其实T1在$n=2$且$s_1=s_2$时还是比较好推的，赶紧把这分骗了。 这里搞一下那里弄一下，离考试结束只有半个小时左右了。 突然发现T2链的情况只需要弄两棵线段树分别维护最大最小值就可以了。蒟蒻我赶紧码完，然后开始对拍。出乎我预料的是我竟然没怎么调试就拍不停了，不知是昨天沾了赵章恺的光还是得到了佛祖的保佑的缘故。 然后不久后考试就结束了，我出了考场。 和别人一讨论，发现T2上树剖什么的一搞能得到一个$\Theta(n\log^3n)$的做法。 然后打开ZJOI2019讲课交流群一看，九条可怜亲口说T2的标算只有一个log，并且数据就是对着树剖造的。看来三个log的做法显然是过不了了。 回了宾馆收拾行李后上了车，去余姚北火车站，准备参加明天上海的华东师范大学的ACM比赛。 哎，希望这次能把写了的暴力分拿全，不要翻车吧。 期望的分：0+60+40=100。 P.S. 成绩几天后出来了，蒟蒻我只得了90分（脸黑）。T2被卡成40分。但是出乎我意料的是T1竟然骗到了10分。]]></content>
      <categories>
        <category>游记</category>
      </categories>
      <tags>
        <tag>游记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「BZOJ3155|洛谷P4868」Preprefix sum]]></title>
    <url>%2F2019%2F04%2F22%2F%E3%80%8CBZOJ3155%20%E6%B4%9B%E8%B0%B7P4868%E3%80%8DPreprefix-sum%20-Solution%2F</url>
    <content type="text"><![CDATA[线段树大水题？？？ 传送门洛谷P4868 BZOJ3155 题解不难发现，如果$A_i$的值增加了$\Delta$，那么$S_i$~$S_n$都增加了$\Delta$。 又$SSi=\sum{i=1}^{i}{S_i}$。 所以直接弄个线段树维护一下就好了。 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#include&lt;cstdio&gt;#include&lt;cstring&gt;using namespace std;typedef long long LL;const int maxn=100005;int n,m,A[maxn];LL S[maxn];char cmd[16];inline int read()&#123; int ret=0,f=1;char ch=getchar(); while(ch&lt;'0'||ch&gt;'9')&#123;if(ch=='-')f=-f;ch=getchar();&#125; while(ch&gt;='0'&amp;&amp;ch&lt;='9')&#123;ret=ret*10+ch-'0';ch=getchar();&#125; return ret*f;&#125;struct SegmentTree&#123; struct Node&#123;LL Sum,Tag;&#125;Tree[maxn*4]; inline void PushUp(int rt)&#123;Tree[rt].Sum=Tree[rt*2].Sum+Tree[rt*2+1].Sum;&#125; inline void PushDown(int rt,int LC,int RC) &#123; if(!Tree[rt].Tag) return; Tree[rt*2].Tag+=Tree[rt].Tag;Tree[rt*2+1].Tag+=Tree[rt].Tag; Tree[rt*2].Sum+=Tree[rt].Tag*LC;Tree[rt*2+1].Sum+=Tree[rt].Tag*RC; Tree[rt].Tag=0; &#125; inline void Build(int L=1,int R=n,int rt=1) &#123; if(L==R)&#123;Tree[rt].Sum=S[L];return;&#125; int M=(L+R)&gt;&gt;1; Build(L,M,rt*2); Build(M+1,R,rt*2+1); PushUp(rt); &#125; inline void RangeUpdate(int LL,int RR,int delta,int L=1,int R=n,int rt=1) &#123; if(LL&lt;=L&amp;&amp;R&lt;=RR)&#123;Tree[rt].Sum+=(::LL)delta*(R-L+1);Tree[rt].Tag+=delta;return;&#125; int M=(L+R)&gt;&gt;1; PushDown(rt,M-L+1,R-M); if(LL&lt;=M) RangeUpdate(LL,RR,delta,L,M,rt*2); if(M&lt;RR) RangeUpdate(LL,RR,delta,M+1,R,rt*2+1); PushUp(rt); &#125; inline LL RangeQuery(int LL,int RR,int L=1,int R=n,int rt=1) &#123; if(LL&lt;=L&amp;&amp;R&lt;=RR) return Tree[rt].Sum; int M=(L+R)&gt;&gt;1;::LL ret=0; PushDown(rt,M-L+1,R-M); if(LL&lt;=M) ret+=RangeQuery(LL,RR,L,M,rt*2); if(M&lt;RR) ret+=RangeQuery(LL,RR,M+1,R,rt*2+1); return ret; &#125;&#125;ST;int main()&#123; n=read();m=read(); for(int i=1;i&lt;=n;i++) A[i]=read(); for(int i=1;i&lt;=n;i++) S[i]=S[i-1]+A[i]; ST.Build(); while(m--) &#123; scanf("%s",cmd); if(strcmp(cmd,"Query")==0) &#123; int x=read(); printf("%lld\n",ST.RangeQuery(1,x)); &#125; else &#123; int x=read(),a=read(); ST.RangeUpdate(x,n,a-A[x]); A[x]=a; &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>线段树</category>
      </categories>
      <tags>
        <tag>线段树</tag>
        <tag>前缀和</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「CQOI2016」手机号码]]></title>
    <url>%2F2019%2F04%2F22%2F%E3%80%8CCQOI2016%E3%80%8D%E6%89%8B%E6%9C%BA%E5%8F%B7%E7%A0%81-Solution%2F</url>
    <content type="text"><![CDATA[蒟蒻我得好好学学数位DP。 传送门洛谷P4124 BZOJ4521 题解这题定义出来的数组有点长QwQ。 定义$F[pos][pre][pree][thr][fur][eig]$表示长度为$pos$，上一个数字为$pre$，上上个数字为$pree$，是/否出现过连续三个相同数字，是/否出现过4，是/否出现8，时的合法方案数。 然后写个记忆化DFS就好了。 代码12345678910111213141516171819202122232425262728293031#include&lt;cstdio&gt;#include&lt;cstring&gt;using namespace std;typedef long long LL;int A[15],len;LL L,R,F[15][11][11][2][2][2][2];LL DFS(int pos,int pre,int pree,bool thr,bool fur,bool eig,bool lim)&#123; if(fur&amp;&amp;eig) return 0; if(pos==0) return thr; LL&amp; ret=F[pos][pre][pree][thr][fur][eig][lim]; if(ret!=-1) return ret; ret=0; int end=lim?A[pos]:9; for(int i=(pos==11?1:0);i&lt;=end;i++) ret+=DFS(pos-1,i,pre,thr||(i==pre&amp;&amp;pre==pree),fur||i==4,eig||i==8,lim&amp;&amp;i==end); return ret;&#125;LL Solve(LL n)&#123; if(n&lt;10000000000ll) return 0; len=0; while(n)&#123;A[++len]=n%10;n/=10;&#125; memset(F,-1,sizeof(F)); return DFS(11,10,10,0,0,0,1);&#125;int main()&#123; scanf("%lld%lld",&amp;L,&amp;R); printf("%lld\n",Solve(R)-Solve(L-1)); return 0;&#125;]]></content>
      <categories>
        <category>数位DP</category>
      </categories>
      <tags>
        <tag>数位DP</tag>
        <tag>记忆化搜索</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「ZJOI2008」骑士]]></title>
    <url>%2F2019%2F04%2F22%2F%E3%80%8CZJOI2008%E3%80%8D%E9%AA%91%E5%A3%AB-Solution%2F</url>
    <content type="text"><![CDATA[好一个树形DP。 传送门洛谷P2607 BZOJ1040 题解他出题人要是敢去掉一条边，我就敢做！！！ 首先对于每一个骑士，向他最痛恨的人建一条边。 如果只有$n-1$条边的话，就是一个裸的带权的树上最大独立集。 但是由于要$n$条边，所以最后建出来的应该是一个基环内向树森林。 比如这样： 对于在环上的每一个点，可以直接DP出该点选与不选时它与它的子树的最大权值和。 对于环，我们可以再来一趟DP，定义$G[i][0/1/2/3]$： $G[i][0]$环上第一个点可以选，第$i$个点选时的最大权值和。 $G[i][1]$环上第一个点可以选，第$i$个点不选时的最大权值和。 $G[i][2]$环上第一个点不可以选，第$i$个点选时的最大权值和。 $G[i][3]$环上第一个点不可以选，第$i$个点不选时的最大权值和。 最后的答案为$max(G[n][0],G[n][2],G[n][3])​$。 对于每一个环，分别DP，然后把答案加在一起即可。 复杂度：$\Theta(n)$。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384#include&lt;cstdio&gt;#include&lt;vector&gt;using namespace std;typedef long long LL;const int maxn=1000005;int n,A[maxn],fa[maxn],in[maxn],len,C[maxn];vector &lt;int&gt; so[maxn];LL ans,G[maxn][4],F[maxn][2];inline int read()&#123; int ret=0,f=1;char ch=getchar(); while(ch&lt;'0'||ch&gt;'9')&#123;if(ch=='-')f=-f;ch=getchar();&#125; while(ch&gt;='0'&amp;&amp;ch&lt;='9')&#123;ret=ret*10+ch-'0';ch=getchar();&#125; return ret*f;&#125;inline void Toposort() //拓扑排序找环+建图&#123; static int que[maxn],hed,til; for(int i=1;i&lt;=n;i++) if(in[i]==0) que[++til]=i; while(hed!=til) &#123; hed++; in[fa[que[hed]]]--; so[fa[que[hed]]].push_back(que[hed]); if(!in[fa[que[hed]]]) que[++til]=fa[que[hed]]; &#125;&#125;void DFS(int now,int fa)&#123; F[now][1]=A[now]; for(int i=0;i&lt;(int)so[now].size();i++) &#123; DFS(so[now][i],now); F[now][1]+=F[so[now][i]][0]; F[now][0]+=max(F[so[now][i]][0],F[so[now][i]][1]); &#125;&#125;void GetCircle(int now)&#123; if(in[fa[now]]==0) return; C[++len]=now; in[fa[now]]--; GetCircle(fa[now]);&#125;void Solve() //对于每个环分别DP&#123; G[1][0]=F[C[1]][0]; G[1][1]=F[C[1]][1]; G[1][2]=F[C[1]][0]; G[1][3]=0; for(int i=2;i&lt;=len;i++) &#123; G[i][0]=G[i][2]=F[C[i]][0]; G[i][1]=G[i][3]=F[C[i]][1]; G[i][0]+=max(G[i-1][0],G[i-1][1]); G[i][1]+=G[i-1][0]; G[i][2]+=max(G[i-1][2],G[i-1][3]); G[i][3]+=G[i-1][2]; &#125; ans+=max(G[len][0],max(G[len][2],G[len][3]));&#125;int main()&#123; n=read(); for(int i=1;i&lt;=n;i++) &#123; A[i]=read(); fa[i]=read(); in[fa[i]]++; &#125; Toposort(); for(int i=1;i&lt;=n;i++) if(in[i]&gt;0) DFS(i,0); for(int i=1;i&lt;=n;i++) &#123; if(in[i]&gt;0) &#123; len=0; GetCircle(i); Solve(); &#125; &#125; printf("%lld\n",ans); return 0;&#125;]]></content>
      <categories>
        <category>树形DP</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>树形DP</tag>
        <tag>基环树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「JLOI2014」松鼠的新家]]></title>
    <url>%2F2019%2F04%2F07%2F%E3%80%8CJLOI2014%E3%80%8D%E6%9D%BE%E9%BC%A0%E7%9A%84%E6%96%B0%E5%AE%B6-Solution%2F</url>
    <content type="text"><![CDATA[蒟蒻我差点把简单问题复杂化QwQ。 传送门洛谷P3258 BZOJ3631 题解这两天刚做了几道树剖题。 害得我这题一上来就像码树剖。 其实完全没必要。 由于修改操作只有将一整条路劲上的点都加1，所以直接树上差分就可以了。 设修改的路径的两个端点分别为$a,b$，那么只要让a和b的权值加1，LCA(a,b)和它的父亲的权值分别减1。然后对于任意一个节点，它整个子树的权值加和便是该节点真正的权值。 然后注意一下细节即可。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;const int maxn=300005;int n,A[maxn],tot,lnk[maxn],son[maxn*2],nxt[maxn*2],F[maxn],father[maxn][20],dep[maxn];inline char nc()&#123; const int S=131072;static char buf[S],*L,*R; return L==R&amp;&amp;(R=(L=buf)+fread(buf,1,S,stdin),L==R)?EOF:*L++;&#125;inline int read()&#123; int ret=0,f=1;char ch=nc(); while(ch&lt;'0'||ch&gt;'9')&#123;if(ch=='-')f=-f;ch=nc();&#125; while(ch&gt;='0'&amp;&amp;ch&lt;='9')&#123;ret=ret*10+ch-'0';ch=nc();&#125; return ret*f;&#125;inline void add_e(int x,int y)&#123;tot++;son[tot]=y;nxt[tot]=lnk[x];lnk[x]=tot;&#125;void Build(int now,int fa)&#123; father[now][0]=fa;dep[now]=dep[fa]+1; for(int i=1;i&lt;=18;i++) father[now][i]=father[father[now][i-1]][i-1]; for(int i=lnk[now];i;i=nxt[i]) if(son[i]!=fa) Build(son[i],now);&#125;inline int LCA(int u,int v)&#123; if(dep[u]&lt;dep[v]) swap(u,v); for(int i=18;i&gt;=0;i--) if(dep[father[u][i]]&gt;=dep[v]) u=father[u][i]; for(int i=18;i&gt;=0;i--) if(father[u][i]!=father[v][i])&#123;u=father[u][i];v=father[v][i];&#125; if(u!=v) return father[u][0]; return u;&#125;void DFS(int now,int fa)&#123; for(int i=lnk[now];i;i=nxt[i]) if(son[i]!=fa) &#123;DFS(son[i],now);F[now]+=F[son[i]];&#125;&#125;int main()&#123; n=read(); for(int i=1;i&lt;=n;i++) A[i]=read(); for(int i=1;i&lt;n;i++) &#123; int a=read(),b=read(); add_e(a,b);add_e(b,a); &#125; Build(1,0); for(int i=1;i&lt;n;i++) &#123; F[A[i]]++; F[A[i+1]]++; int lca=LCA(A[i],A[i+1]); F[lca]--; F[father[lca][0]]--; &#125; DFS(1,0); for(int i=1;i&lt;n;i++) F[A[i+1]]--; for(int i=1;i&lt;=n;i++) printf("%d\n",F[i]); return 0;&#125;]]></content>
      <categories>
        <category>树上差分</category>
      </categories>
      <tags>
        <tag>线段树</tag>
        <tag>树链剖分</tag>
        <tag>LCA</tag>
        <tag>树上差分</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「HNOI2012」永无乡]]></title>
    <url>%2F2019%2F04%2F07%2F%E3%80%8CHNOI2012%E3%80%8D%E6%B0%B8%E6%97%A0%E4%B9%A1-Solution%2F</url>
    <content type="text"><![CDATA[平衡树真是神奇。 传送门洛谷P3224 BZOJ2733 题解对于每一个联通块，都可以用一棵Splay来维护。 对于合并操作，可以采用启发式合并的方法，将小Splay接到大的Splay上去，然后把小的Splay的每一个节点都旋转到根节点（其实就是相当于把小的Splay拆了之后一个个加入到大的Splay里）。 对于一个节点，由于每次都是由小树往大树里加，所以进行一次合并之后，树的大小至少变到原来小树的两倍。所以每一个节点最多被合并$\log n​$次。 所以时间复杂度为$\Theta(n\log^2n)$。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;const int maxn=100005;int n,m,q;inline int read()&#123; int ret=0,f=1;char ch=getchar(); while(ch&lt;'0'||ch&gt;'9')&#123;if(ch=='-')f=-f;ch=getchar();&#125; while(ch&gt;='0'&amp;&amp;ch&lt;='9')&#123;ret=ret*10+ch-'0';ch=getchar();&#125; return ret*f;&#125;inline char GetCmd()&#123; char ch=getchar(); while(ch!='B'&amp;&amp;ch!='Q') ch=getchar(); return ch;&#125;struct SplayTree&#123; int fa[maxn],cnt[maxn],que[maxn]; inline int getfa(int x)&#123;return fa[x]==x?x:fa[x]=getfa(fa[x]);&#125; struct Node&#123;int siz,val,fa,son[2];&#125;Tree[maxn]; inline void PushUp(int rt)&#123;Tree[rt].siz=Tree[Tree[rt].son[0]].siz+Tree[Tree[rt].son[1]].siz+1;&#125; inline int check(int x)&#123;return Tree[Tree[x].fa].son[1]==x?1:0;&#125; inline void Rotate(int x) &#123; int y=Tree[x].fa,z=Tree[y].fa,k=check(x),w=Tree[x].son[k^1]; Tree[w].fa=y; Tree[y].son[k]=w; Tree[x].fa=z; Tree[z].son[check(y)]=x; Tree[y].fa=x; Tree[x].son[k^1]=y; PushUp(y); PushUp(x); &#125; inline void Splay(int x) &#123; while(Tree[x].fa) &#123; int y=Tree[x].fa; if(Tree[y].fa) &#123; if(check(x)==check(y)) Rotate(y); else Rotate(x); &#125; Rotate(x); &#125; &#125; inline void Link(int a,int b) &#123; if(getfa(a)==getfa(b)) return; if(cnt[getfa(a)]&lt;cnt[getfa(b)]) swap(a,b); cnt[getfa(a)]+=cnt[getfa(b)];cnt[getfa(b)]=0; fa[fa[b]]=fa[a]; Splay(b);Splay(a); int p=a,fa=0; while(p) &#123; fa=p; p=Tree[p].son[Tree[b].val&gt;Tree[p].val]; &#125; Tree[fa].son[Tree[b].val&gt;Tree[fa].val]=b; Tree[b].fa=fa; int hed=0,til=1; que[1]=b; while(hed!=til) &#123; hed++; if(Tree[que[hed]].son[0]) que[++til]=Tree[que[hed]].son[0]; if(Tree[que[hed]].son[1]) que[++til]=Tree[que[hed]].son[1]; &#125; for(int i=1;i&lt;=til;i++) Splay(que[i]); &#125; inline int Kth(int x,int k) &#123; Splay(x); int p=x; while(p) &#123; if(Tree[Tree[p].son[0]].siz+1==k) return p; if(Tree[Tree[p].son[0]].siz+1&gt;k) p=Tree[p].son[0]; else&#123;k-=Tree[Tree[p].son[0]].siz+1;p=Tree[p].son[1];&#125; &#125; return -1; &#125;&#125;ST;int main()&#123; n=read();m=read(); for(int i=1;i&lt;=n;i++) &#123; ST.fa[i]=i;ST.cnt[i]=1; ST.Tree[i].siz=1; ST.Tree[i].val=read(); &#125; for(int i=1;i&lt;=m;i++) &#123; int a=read(),b=read(); ST.Link(a,b); &#125; q=read(); while(q--) &#123; if(GetCmd()=='B') &#123; int a=read(),b=read(); ST.Link(a,b); &#125; else &#123; int x=read(),k=read(); printf("%d\n",ST.Kth(x,k)); &#125; &#125; return 0;&#125;]]></content>
      <tags>
        <tag>平衡树</tag>
        <tag>SplayTree</tag>
        <tag>启发式合并</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「HNOI2004」宠物收养场]]></title>
    <url>%2F2019%2F04%2F07%2F%E3%80%8CHNOI2004%E3%80%8D%E5%AE%A0%E7%89%A9%E6%94%B6%E5%85%BB%E5%9C%BA-Solution%2F</url>
    <content type="text"><![CDATA[set真香。 传送门洛谷P2286 BZOJ1208 题解只要记一下当前是人多还是宠物多，然后弄个平衡树维护一下。 每次找个前驱和后继，挑个接近的来。 也可以用STL里的set来维护。 然后注意一下细节就行了。 记得答案要取模。 代码set真香 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include&lt;set&gt;#include&lt;cstdio&gt;using namespace std;int n,peo,pet,ans;set&lt;int&gt; S;set&lt;int&gt;::iterator p1,p2;inline int read()&#123; int ret=0,f=1;char ch=getchar(); while(ch&lt;'0'||ch&gt;'9')&#123;if(ch=='-')f=-f;ch=getchar();&#125; while(ch&gt;='0'&amp;&amp;ch&lt;='9')&#123;ret=ret*10+ch-'0';ch=getchar();&#125; return ret*f;&#125;inline int ABS(int x)&#123;return x&lt;0?-x:x;&#125;int main()&#123; n=read(); for(int i=1;i&lt;=n;i++) &#123; int opt=read(),a=read(); if(opt==0) &#123; if(peo==0)&#123;S.insert(a);pet++;&#125; else &#123; p1=p2=S.lower_bound(a);p2--; if(p1!=S.begin()&amp;&amp;(p1==S.end()||ABS(*p1-a)&gt;=ABS(*p2-a))) p1--; ans+=ABS(*p1-a); S.erase(p1);peo--; &#125; &#125; else &#123; if(pet==0)&#123;S.insert(a);peo++;&#125; else &#123; p1=p2=S.lower_bound(a);p2--; if(p1!=S.begin()&amp;&amp;(p1==S.end()||ABS(*p1-a)&gt;=ABS(*p2-a))) p1--; ans+=ABS(*p1-a); S.erase(p1);pet--; &#125; &#125; ans%=1000000; &#125; printf("%d\n",ans); return 0;&#125;]]></content>
      <categories>
        <category>平衡树</category>
      </categories>
      <tags>
        <tag>平衡树</tag>
        <tag>set</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「HNOI2002」营业额统计]]></title>
    <url>%2F2019%2F04%2F07%2F%E3%80%8CHNOI2002%E3%80%8D%E8%90%A5%E4%B8%9A%E9%A2%9D%E7%BB%9F%E8%AE%A1-Solution%2F</url>
    <content type="text"><![CDATA[裸的平衡树？ 题解我们需要求出每一天营业额的前驱和后继，然后挑一个更接近的就行了。 直接上平衡树搞就行。 或者调用STL里的set。 代码蒟蒻我手写了个伸展树。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;const int maxn=32800,inf=0X3F3F3F3F;int n,ans;bool vis[2000010];inline int read()&#123; int ret=0,f=1;char ch=getchar(); while(ch&lt;'0'||ch&gt;'9')&#123;if(ch=='-')f=-f;ch=getchar();&#125; while(ch&gt;='0'&amp;&amp;ch&lt;='9')&#123;ret=ret*10+ch-'0';ch=getchar();&#125; return ret*f;&#125;struct SplayTree&#123; int tot,root; struct Node&#123;int val,siz,fa,son[2];&#125;Tree[maxn]; inline int check(int x)&#123;return Tree[Tree[x].fa].son[1]==x?1:0;&#125; inline void PushUp(int x)&#123;Tree[x].siz=Tree[Tree[x].son[0]].siz+Tree[Tree[x].son[1]].siz+1;&#125; inline void Rotate(int x) &#123; int y=Tree[x].fa,z=Tree[y].fa,k=check(x),w=Tree[x].son[k^1]; Tree[y].son[k]=w; Tree[w].fa=y; Tree[x].fa=z; Tree[z].son[check(y)]=x; Tree[x].son[k^1]=y; Tree[y].fa=x; PushUp(y); PushUp(x); &#125; inline void Splay(int x) &#123; while(Tree[x].fa) &#123; int y=Tree[x].fa; if(Tree[y].fa) &#123; if(check(x)==check(y)) Rotate(y); else Rotate(x); &#125; Rotate(x); &#125; root=x; &#125; inline void Insert(int v) &#123; int p=root,fa=0; while(p) &#123; fa=p; p=Tree[p].son[v&gt;Tree[p].val]; &#125; p=++tot; Tree[fa].son[v&gt;Tree[fa].val]=p; Tree[p].fa=fa; Tree[p].siz=1; Tree[p].val=v; Splay(p); &#125; int FindPre(int v) &#123; int p=Tree[root].son[0]; if(!p) return -inf; while(Tree[p].son[1]) p=Tree[p].son[1]; return Tree[p].val; &#125; int FindSuf(int v) &#123; int p=Tree[root].son[1]; if(!p) return inf; while(Tree[p].son[0]) p=Tree[p].son[0]; return Tree[p].val; &#125;&#125;ST;int main()&#123; n=read(); for(int i=1;i&lt;=n;i++) &#123; int Ai=read(); if(i==1) ans+=Ai; if(!vis[Ai+1000005]) &#123; ST.Insert(Ai); if(i!=1) ans+=min(Ai-ST.FindPre(Ai),ST.FindSuf(Ai)-Ai); vis[Ai+1000005]=true; &#125; &#125; printf("%d\n",ans); return 0;&#125;]]></content>
      <categories>
        <category>平衡树</category>
      </categories>
      <tags>
        <tag>平衡树</tag>
        <tag>set</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「SDOI2011」染色]]></title>
    <url>%2F2019%2F04%2F07%2F%E3%80%8CSDOI2011%E3%80%8D%E6%9F%93%E8%89%B2-Solution%2F</url>
    <content type="text"><![CDATA[再来水一发树剖QwQ。 传送门洛谷P2486 BZOJ2243 题解首先这题上来先树剖。 然后考虑线段树怎么写。 对于每一个节点，需要记录它所控制的区间中颜色的段数、开头的颜色和结尾的颜色。 合并两个区间的时候，需要判断前面区间结尾颜色是否等于后面区间的开头颜色，如果相同区间颜色段数要减一。 其他按照树剖的套路写就行了。 然后就没了QwQ… 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;const int maxn=100005;int n,m,tot,lnk[maxn],son[maxn*2],C[maxn],nxt[maxn*2],idx,siz[maxn],wson[maxn],fa[maxn],top[maxn],seg[maxn],dep[maxn],rev[maxn],ans;inline int read()&#123; int ret=0,f=1;char ch=getchar(); while(ch&lt;'0'||ch&gt;'9')&#123;if(ch=='-')f=-f;ch=getchar();&#125; while(ch&gt;='0'&amp;&amp;ch&lt;='9')&#123;ret=ret*10+ch-'0';ch=getchar();&#125; return ret*f;&#125;inline char GetCmd()&#123; char ch=getchar(); while(ch!='Q'&amp;&amp;ch!='C') ch=getchar(); return ch;&#125;struct SegmentTree&#123; struct Node&#123;int FC,BC,Sum,Tag;&#125;Tree[maxn*4]; void PushUp(int rt) &#123; Tree[rt].Sum=Tree[rt*2].Sum+Tree[rt*2+1].Sum-(int)(Tree[rt*2].BC==Tree[rt*2+1].FC); Tree[rt].FC=Tree[rt*2].FC; Tree[rt].BC=Tree[rt*2+1].BC; &#125; void PushDown(int rt) &#123; if(Tree[rt].Tag==0) return; Tree[rt*2].Sum=1; Tree[rt*2+1].Sum=1; Tree[rt*2].FC=Tree[rt*2].BC=Tree[rt*2+1].FC=Tree[rt*2+1].BC=Tree[rt].Tag; Tree[rt*2].Tag=Tree[rt].Tag; Tree[rt*2+1].Tag=Tree[rt].Tag; Tree[rt].Tag=0; &#125; void Build(int L=1,int R=n,int rt=1) &#123; if(L==R) &#123; Tree[rt].Sum=1; Tree[rt].FC=Tree[rt].BC=C[rev[L]]; return; &#125; int M=(L+R)&gt;&gt;1; Build(L,M,rt*2); Build(M+1,R,rt*2+1); PushUp(rt); &#125; void RangeUpdate(int LL,int RR,int co,int L=1,int R=n,int rt=1) &#123; if(LL&lt;=L&amp;&amp;R&lt;=RR) &#123; Tree[rt].Sum=1; Tree[rt].Tag=co; Tree[rt].FC=Tree[rt].BC=co; return; &#125; int M=(L+R)/2; PushDown(rt); if(LL&lt;=M) RangeUpdate(LL,RR,co,L,M,rt*2); if(M&lt;RR) RangeUpdate(LL,RR,co,M+1,R,rt*2+1); PushUp(rt); &#125; Node RangeQuery(int LL,int RR,int L=1,int R=n,int rt=1) &#123; if(LL&lt;=L&amp;&amp;R&lt;=RR) return Tree[rt]; int M=(L+R)&gt;&gt;1;Node IL,IR,ret; PushDown(rt); if(LL&lt;=M) IL=RangeQuery(LL,RR,L,M,rt*2); if(M&lt;RR) IR=RangeQuery(LL,RR,M+1,R,rt*2+1); if(LL&lt;=M&amp;&amp;M&gt;=RR) return IL; if(LL&gt;M&amp;&amp;M&lt;RR) return IR; ret.Sum=IL.Sum+IR.Sum-(int)(IL.BC==IR.FC); ret.FC=IL.FC;ret.BC=IR.BC; return ret; &#125;&#125;T;inline void add_e(int x,int y)&#123;tot++;son[tot]=y;nxt[tot]=lnk[x];lnk[x]=tot;&#125;void DFS1(int now)&#123; siz[now]=1;dep[now]=dep[fa[now]]+1; for(int i=lnk[now];i;i=nxt[i]) &#123; if(son[i]==fa[now]) continue; fa[son[i]]=now; DFS1(son[i]); siz[now]+=siz[son[i]]; &#125; for(int i=lnk[now];i;i=nxt[i]) if(son[i]!=fa[now]&amp;&amp;siz[son[i]]&gt;siz[wson[now]]) wson[now]=son[i];&#125;void DFS2(int now)&#123; seg[now]=++idx;rev[seg[now]]=now; if(now==1) top[now]=1; if(wson[now]) &#123; top[wson[now]]=top[now]; DFS2(wson[now]); &#125; for(int i=lnk[now];i;i=nxt[i]) &#123; if(son[i]==fa[now]||son[i]==wson[now]) continue; top[son[i]]=son[i]; DFS2(son[i]); &#125;&#125;inline void PathUpdate(int u,int v,int nc)&#123; while(top[u]!=top[v]) &#123; if(dep[top[u]]&lt;dep[top[v]]) swap(u,v); T.RangeUpdate(seg[top[u]],seg[u],nc); u=fa[top[u]]; &#125; if(dep[u]&lt;dep[v]) swap(u,v); T.RangeUpdate(seg[v],seg[u],nc);&#125;inline void PathQuery(int u,int v)&#123; ans=0; while(top[u]!=top[v]) &#123; if(dep[top[u]]&lt;dep[top[v]]) swap(u,v); ans+=T.RangeQuery(seg[top[u]],seg[u]).Sum; if(T.RangeQuery(seg[top[u]],seg[top[u]]).BC==T.RangeQuery(seg[fa[top[u]]],seg[fa[top[u]]]).BC) ans--; u=fa[top[u]]; &#125; if(dep[u]&lt;dep[v]) swap(u,v); ans+=T.RangeQuery(seg[v],seg[u]).Sum; printf("%d\n",ans);&#125;int main()&#123; n=read();m=read(); for(int i=1;i&lt;=n;i++) C[i]=read(); for(int i=1;i&lt;n;i++) &#123; int a=read(),b=read(); add_e(a,b);add_e(b,a); &#125; DFS1(1);DFS2(1);T.Build(); while(m--) &#123; if(GetCmd()=='C') &#123; int a=read(),b=read(),c=read(); PathUpdate(a,b,c); &#125; else &#123; int a=read(),b=read(); PathQuery(a,b); &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>树链剖分</category>
      </categories>
      <tags>
        <tag>线段树</tag>
        <tag>树链剖分</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「NOI2015」软件包管理器]]></title>
    <url>%2F2019%2F04%2F06%2F%E3%80%8CNOI2015%E3%80%8D%E8%BD%AF%E4%BB%B6%E5%8C%85%E7%AE%A1%E7%90%86%E5%99%A8-Solution%2F</url>
    <content type="text"><![CDATA[又是一个树剖题QwQ。 传送门洛谷P2146 BZOJ4196 题解不难发现，各个软件包之间的依赖关系构成了一棵树。 所以先把树建出来，每一个节点设一个权值，权值为$0$表示还未安装，权值为$1$表示已安装。 当安装软件$x$的时候，答案为$x$到根节点的路径上没有安装的软件的数量，然后把一整条路径上的节点的权值都设成1。 卸载软件$x$的时候，答案为$x$的子树中已经安装的软件的数量，然后把整棵子树中所有节点的权值都设为0。 然后弄个支持区间覆盖查询区间加和的线段树维护下就好了。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114#include&lt;cstdio&gt;#include&lt;cstring&gt;using namespace std;const int maxn=100005;int n,m,tot,lnk[maxn],son[maxn*2],w[maxn],nxt[maxn*2],idx,siz[maxn],wson[maxn],fa[maxn],top[maxn],seg[maxn],rev[maxn],ans;char cmd[10];inline int read()&#123; int ret=0,f=1;char ch=getchar(); while(ch&lt;'0'||ch&gt;'9')&#123;if(ch=='-')f=-f;ch=getchar();&#125; while(ch&gt;='0'&amp;&amp;ch&lt;='9')&#123;ret=ret*10+ch-'0';ch=getchar();&#125; return ret*f;&#125;struct SegmentTree&#123; struct Node&#123;int Sum,Tag;&#125;Tree[maxn*4]; void PushUp(int rt)&#123;Tree[rt].Sum=Tree[rt*2].Sum+Tree[rt*2+1].Sum;&#125; void PushDown(int rt,int LC,int RC) &#123; if(Tree[rt].Tag==-1) return; Tree[rt*2].Sum=Tree[rt].Tag*LC; Tree[rt*2+1].Sum=Tree[rt].Tag*RC; Tree[rt*2].Tag=Tree[rt].Tag; Tree[rt*2+1].Tag=Tree[rt].Tag; Tree[rt].Tag=-1; &#125; void RangeUpdate(int LL,int RR,int delta,int L=1,int R=n,int rt=1) &#123; if(LL&lt;=L&amp;&amp;R&lt;=RR) &#123; Tree[rt].Sum=delta*(R-L+1); Tree[rt].Tag=delta; return; &#125; int M=(L+R)/2; PushDown(rt,M-L+1,R-M); if(LL&lt;=M) RangeUpdate(LL,RR,delta,L,M,rt*2); if(M&lt;RR) RangeUpdate(LL,RR,delta,M+1,R,rt*2+1); PushUp(rt); &#125; int QueryRange(int LL,int RR,int L=1,int R=n,int rt=1) &#123; if(LL&lt;=L&amp;&amp;R&lt;=RR) return Tree[rt].Sum; int M=(L+R)/2,ret=0; PushDown(rt,M-L+1,R-M); if(LL&lt;=M) ret+=QueryRange(LL,RR,L,M,rt*2); if(M&lt;RR) ret+=QueryRange(LL,RR,M+1,R,rt*2+1); return ret; &#125;&#125;T;inline void add_e(int x,int y)&#123;tot++;son[tot]=y;nxt[tot]=lnk[x];lnk[x]=tot;&#125;void DFS1(int now)&#123; siz[now]=1; for(int i=lnk[now];i;i=nxt[i]) &#123; if(son[i]==fa[now]) continue; fa[son[i]]=now; DFS1(son[i]); siz[now]+=siz[son[i]]; &#125; for(int i=lnk[now];i;i=nxt[i]) if(son[i]!=fa[now]&amp;&amp;siz[son[i]]&gt;siz[wson[now]]) wson[now]=son[i];&#125;void DFS2(int now)&#123; seg[now]=++idx;rev[seg[now]]=now; if(now==1) top[now]=1; if(wson[now]) &#123; top[wson[now]]=top[now]; DFS2(wson[now]); &#125; for(int i=lnk[now];i;i=nxt[i]) &#123; if(son[i]==fa[now]||son[i]==wson[now]) continue; top[son[i]]=son[i]; DFS2(son[i]); &#125;&#125;int main()&#123; n=read(); for(int i=2;i&lt;=n;i++) &#123; int a=read()+1; add_e(a,i);add_e(i,a); &#125; for(int i=1;i&lt;=n*4;i++) T.Tree[i].Tag=-1; DFS1(1);DFS2(1); m=read(); while(m--) &#123; scanf("%s",cmd); int x=read()+1;ans=0; if(strcmp(cmd,"install")==0) &#123; while(x&gt;0) &#123; ans+=seg[x]-seg[top[x]]+1-T.QueryRange(seg[top[x]],seg[x]); T.RangeUpdate(seg[top[x]],seg[x],1); x=fa[top[x]]; &#125; printf("%d\n",ans); &#125; else &#123; ans=T.QueryRange(seg[x],seg[x]+siz[x]-1); T.RangeUpdate(seg[x],seg[x]+siz[x]-1,0); printf("%d\n",ans); &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>树链剖分</category>
      </categories>
      <tags>
        <tag>线段树</tag>
        <tag>树链剖分</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「国家集训队」跳跳棋]]></title>
    <url>%2F2019%2F04%2F06%2F%E3%80%8C%E5%9B%BD%E5%AE%B6%E9%9B%86%E8%AE%AD%E9%98%9F%E3%80%8D%E8%B7%B3%E8%B7%B3%E6%A3%8B-Solution%2F</url>
    <content type="text"><![CDATA[这题藏得有点深啊。 传送门洛谷P1852 BZOJ2144 题解这题的建模有点神仙。 根据题意，设三颗棋子的位置分别为$a,b,c(a&lt;b&lt;c)​$，令$d1=b-a,d2=c-b​$。 由题意可知，一共有三种移动方式： 中间的棋子往左跳。 中间的棋子往右跳。 两边的棋子中离中间棋子近的一颗往中间跳。 假如不断使用第三种跳法，那么对于任意一个状态，最后它将会跳到一个$d1=d2$的状态，此时便不能继续跳了。 并且对于任意一个状态，它只可能由两种状态执行操作三而转移过来。 所以如果以一个$d1=d2​$的状态作为根，每个状态向可能转移到该状态的两个状态建边，那么这将会是一颗二叉树。 对于两个状态，它们所对应的节点在树上的最短路径的长度就是转移所需的最小步数。 如果这两个状态不在同一棵树上，那么它们之间就不可能相互转移。 于是乎建出树之后，直接求LCA就行了。 但是还有一个问题就是树太大了，存不下。 那就可以先求出两个状态到根的深度，然后先把深度大的向上跳到深度相同，接着二分到LCA的距离即可。 注意当$d1$和$d2​$相差了好多倍时，可以一次性跳好几步，以免TLE。 然后就，没了… 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;int dep1,dep2,ans;struct Ball&#123; int a,b,c; inline void Sort() &#123; if(a&gt;b) swap(a,b); if(a&gt;c) swap(a,c); if(b&gt;c) swap(b,c); &#125; bool operator == (const Ball&amp; b)const&#123;return a==b.a&amp;&amp;this-&gt;b==b.b&amp;&amp;c==b.c;&#125;&#125;A,B,tep1,tep2;int GetFather(Ball x,int stp,Ball&amp; lst)&#123; int d1=x.b-x.a,d2=x.c-x.b,ret=0; while(d1!=d2&amp;&amp;stp&gt;0) &#123; if(d1&lt;d2) &#123; if(d2%d1==0) &#123; int nt=min(stp,d2/d1-1); x.a+=nt*d1;x.b+=nt*d1; stp=0;ret+=nt; &#125; else &#123; int nt=min(stp,d2/d1); x.a+=nt*d1;x.b+=nt*d1; stp-=nt;ret+=nt; &#125; &#125; else &#123; if(d1%d2==0) &#123; int nt=min(stp,d1/d2-1); x.b-=nt*d2;x.c-=nt*d2; stp=0;ret+=nt; &#125; else &#123; int nt=min(stp,d1/d2); x.b-=nt*d2;x.c-=nt*d2; stp-=nt;ret+=nt; &#125; &#125; d1=x.b-x.a;d2=x.c-x.b; &#125; lst=x; return ret;&#125;int main()&#123; scanf("%d%d%d%d%d%d",&amp;A.a,&amp;A.b,&amp;A.c,&amp;B.a,&amp;B.b,&amp;B.c); A.Sort();B.Sort(); dep1=GetFather(A,2147483647,tep1); dep2=GetFather(B,2147483647,tep2); if(!(tep1==tep2)) &#123; printf("NO\n"); return 0; &#125; if(dep1&gt;dep2) &#123; ans+=dep1-dep2; GetFather(A,dep1-dep2,tep1); A=tep1;dep1=dep2; &#125; if(dep2&gt;dep1) &#123; ans+=dep2-dep1; GetFather(B,dep2-dep1,tep2); B=tep2;dep2=dep1; &#125; int L=0,R=dep1,mid; while(L&lt;=R) &#123; mid=(L+R)&gt;&gt;1; GetFather(A,mid,tep1); GetFather(B,mid,tep2); tep1==tep2?R=mid-1:L=mid+1; &#125; ans+=L*2; printf("YES\n%d\n",ans); return 0;&#125;]]></content>
      <categories>
        <category>LCA</category>
      </categories>
      <tags>
        <tag>二分</tag>
        <tag>LCA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「HAOI2015」树上操作]]></title>
    <url>%2F2019%2F04%2F06%2F%E3%80%8CHAOI2015%E3%80%8D%E6%A0%91%E4%B8%8A%E6%93%8D%E4%BD%9C-Solution%2F</url>
    <content type="text"><![CDATA[赤裸裸的树剖啊。 传送门洛谷P3178 BZOJ4034 题解裸的树链剖分，没啥好说的。直接搞就好了 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124#include&lt;cstdio&gt;using namespace std;typedef long long LL;const int maxn=100005;int n,m,tot,lnk[maxn],son[maxn*2],w[maxn],nxt[maxn*2],idx,siz[maxn],wson[maxn],fa[maxn],top[maxn],seg[maxn],rev[maxn];LL ans;inline int read()&#123; int ret=0,f=1;char ch=getchar(); while(ch&lt;'0'||ch&gt;'9')&#123;if(ch=='-')f=-f;ch=getchar();&#125; while(ch&gt;='0'&amp;&amp;ch&lt;='9')&#123;ret=ret*10+ch-'0';ch=getchar();&#125; return ret*f;&#125;struct SegmentTree&#123; struct Node&#123;LL Sum,Tag;&#125;Tree[maxn*4]; void PushUp(int rt)&#123;Tree[rt].Sum=Tree[rt*2].Sum+Tree[rt*2+1].Sum;&#125; void PushDown(int rt,int LC,int RC) &#123; if(!Tree[rt].Tag) return; Tree[rt*2].Sum+=Tree[rt].Tag*LC; Tree[rt*2+1].Sum+=Tree[rt].Tag*RC; Tree[rt*2].Tag+=Tree[rt].Tag; Tree[rt*2+1].Tag+=Tree[rt].Tag; Tree[rt].Tag=0; &#125; void Build(int L=1,int R=n,int rt=1) &#123; if(L==R)&#123;Tree[rt].Sum=w[rev[L]];return;&#125; int M=(L+R)&gt;&gt;1; Build(L,M,rt*2); Build(M+1,R,rt*2+1); PushUp(rt); &#125; void RangeUpdate(int LL,int RR,int delta,int L=1,int R=n,int rt=1) &#123; if(LL&lt;=L&amp;&amp;R&lt;=RR) &#123; Tree[rt].Sum+=(long long)delta*(R-L+1); Tree[rt].Tag+=delta; return; &#125; int M=(L+R)/2; PushDown(rt,M-L+1,R-M); if(LL&lt;=M) RangeUpdate(LL,RR,delta,L,M,rt*2); if(M&lt;RR) RangeUpdate(LL,RR,delta,M+1,R,rt*2+1); PushUp(rt); &#125; LL QueryRange(int LL,int RR,int L=1,int R=n,int rt=1) &#123; if(LL&lt;=L&amp;&amp;R&lt;=RR) return Tree[rt].Sum; int M=(L+R)/2;::LL ret=0; PushDown(rt,M-L+1,R-M); if(LL&lt;=M) ret+=QueryRange(LL,RR,L,M,rt*2); if(M&lt;RR) ret+=QueryRange(LL,RR,M+1,R,rt*2+1); return ret; &#125;&#125;T;inline void add_e(int x,int y)&#123;tot++;son[tot]=y;nxt[tot]=lnk[x];lnk[x]=tot;&#125;void DFS1(int now)&#123; siz[now]=1; for(int i=lnk[now];i;i=nxt[i]) &#123; if(son[i]==fa[now]) continue; fa[son[i]]=now; DFS1(son[i]); siz[now]+=siz[son[i]]; &#125; for(int i=lnk[now];i;i=nxt[i]) if(son[i]!=fa[now]&amp;&amp;siz[son[i]]&gt;siz[wson[now]]) wson[now]=son[i];&#125;void DFS2(int now)&#123; seg[now]=++idx;rev[seg[now]]=now; if(now==1) top[now]=1; if(wson[now]) &#123; top[wson[now]]=top[now]; DFS2(wson[now]); &#125; for(int i=lnk[now];i;i=nxt[i]) &#123; if(son[i]==fa[now]||son[i]==wson[now]) continue; top[son[i]]=son[i]; DFS2(son[i]); &#125;&#125;int main()&#123; n=read();m=read(); for(int i=1;i&lt;=n;i++) w[i]=read(); for(int i=1;i&lt;n;i++) &#123; int a=read(),b=read(); add_e(a,b);add_e(b,a); &#125; DFS1(1);DFS2(1);T.Build(); while(m--) &#123; int opt=read(),x=read(); if(opt==1) &#123; int a=read(); T.RangeUpdate(seg[x],seg[x],a); &#125; else if(opt==2) &#123; int a=read(); T.RangeUpdate(seg[x],seg[x]+siz[x]-1,a); &#125; else &#123; ans=0; while(x&gt;0) &#123; ans+=T.QueryRange(seg[top[x]],seg[x]); x=fa[top[x]]; &#125; printf("%lld\n",ans); &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>树链剖分</category>
      </categories>
      <tags>
        <tag>线段树</tag>
        <tag>树链剖分</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「国家集训队」middle]]></title>
    <url>%2F2019%2F03%2F29%2F%E3%80%8C%E5%9B%BD%E5%AE%B6%E9%9B%86%E8%AE%AD%E9%98%9F%E3%80%8Dmiddle-Solution%2F</url>
    <content type="text"><![CDATA[丽洁姐的题目，不错不错。 传送门洛谷P2839 BZOJ2653 题解这题还是挺好玩的。 首先可以二分枚举答案。设当前枚举到的答案为$mid$，那么就把大于等于当前答案的数标为1，小于的标为-1。如果两个端点分别在指定区间内的加和最大的区间的加和大于等于0，那么当前二分到的值可以再大一些，否则就应该小一些。 由于最后的区间必然包括$[b+1,c-1]$，所以需要求出区间$[a,b]$的最大后缀和以及区间$[c,d]$的最大前缀和。 先对原序列离散化，这样最后可能二分到的答案就只剩下$n$个。然以后对于每一个可能二分到的答案，将以它为基准构造出的由1和-1组成的序列预处理出来，用线段树就可以维护一个区间的加和、最大前缀和、最大后缀和。但是这样复杂度是爆炸的。所以可以先排序，然后由于每次按顺序修改基准数只会将一个位置的值由1改为-1，所以用主席树维护就好了。 原序列中可能有相同元数字，注意细节即可。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101#include&lt;map&gt;#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;const int maxn=20005,LOG=16;int n,Q,cnt,A[maxn],id[maxn],q[10],ans;map&lt;int,int&gt; CR;inline int read()&#123; int ret=0,f=1;char ch=getchar(); while(ch&lt;'0'||ch&gt;'9')&#123;if(ch=='-')f=-f;ch=getchar();&#125; while(ch&gt;='0'&amp;&amp;ch&lt;='9')&#123;ret=ret*10+ch-'0';ch=getchar();&#125; return ret*f;&#125;struct ChairmanTree&#123; int tot,R[maxn]; struct Node&#123;int L,R,Sum,FMS,BMS;&#125;Tree[maxn*2*LOG]; inline void PushUp(int rt) &#123; Tree[rt].Sum=Tree[Tree[rt].L].Sum+Tree[Tree[rt].R].Sum; Tree[rt].FMS=max(Tree[Tree[rt].L].FMS,Tree[Tree[rt].L].Sum+Tree[Tree[rt].R].FMS); Tree[rt].BMS=max(Tree[Tree[rt].R].BMS,Tree[Tree[rt].R].Sum+Tree[Tree[rt].L].BMS); &#125; inline int New()&#123;return ++tot;&#125; void Build(int rt,int L=1,int R=n) &#123; if(L==R)&#123;Tree[rt].Sum=Tree[rt].FMS=Tree[rt].BMS=1;return;&#125; Tree[rt].L=New(); Tree[rt].R=New(); int M=(L+R)&gt;&gt;1; Build(Tree[rt].L,L,M); Build(Tree[rt].R,M+1,R); PushUp(rt); &#125; void Update(int rt,int pre,int p,int L=1,int R=n) &#123; if(L==R)&#123;Tree[rt].Sum=Tree[rt].FMS=Tree[rt].BMS=-1;return;&#125; Tree[rt]=Tree[pre]; int M=(L+R)&gt;&gt;1; if(p&lt;=M) &#123; Tree[rt].L=New(); Update(Tree[rt].L,Tree[pre].L,p,L,M); &#125; if(M&lt;p) &#123; Tree[rt].R=New(); Update(Tree[rt].R,Tree[pre].R,p,M+1,R); &#125; PushUp(rt); &#125; Node Query(int rt,int LL,int RR,int L=1,int R=n) &#123; if(LL&gt;RR)&#123;return (Node)&#123;0,0,0,0,0&#125;;&#125; if(LL&lt;=L&amp;&amp;R&lt;=RR) return Tree[rt]; int M=(L+R)&gt;&gt;1;Node IL,IR,ret; if(LL&lt;=M) IL=Query(Tree[rt].L,LL,RR,L,M); if(M&lt;RR) IR=Query(Tree[rt].R,LL,RR,M+1,R); if(LL&lt;=M&amp;&amp;M&gt;=RR) return IL; if(LL&gt;M&amp;&amp;M&lt;RR) return IR; ret.Sum=IL.Sum+IR.Sum; ret.FMS=max(IL.FMS,IL.Sum+IR.FMS); ret.BMS=max(IR.BMS,IR.Sum+IL.BMS); return ret; &#125;&#125;CT;inline bool cmp(int x,int y)&#123;return A[x]&lt;A[y];&#125;inline void Solve(int a,int b,int c,int d)&#123; int L=1,R=n,mid; while(L&lt;=R) &#123; mid=(L+R)&gt;&gt;1; ChairmanTree::Node IL=CT.Query(CT.R[CR[A[id[mid]]]],a,b),IM=CT.Query(CT.R[CR[A[id[mid]]]],b+1,c-1),IR=CT.Query(CT.R[CR[A[id[mid]]]],c,d); IL.BMS+IM.Sum+IR.FMS&gt;=0?L=mid+1:R=mid-1; &#125; ans=A[id[R]]; printf("%d\n",ans);&#125;int main()&#123; n=read(); for(int i=1;i&lt;=n;i++) A[i]=read(); for(int i=1;i&lt;=n;i++) id[i]=i; sort(id+1,id+1+n,cmp); CT.R[1]=CT.New();CT.Build(1);CR[A[id[1]]]=1; for(int i=2;i&lt;=n;i++) &#123; CT.R[i]=CT.New(); if(!CR[A[id[i]]]) CR[A[id[i]]]=i; CT.Update(CT.R[i],CT.R[i-1],id[i-1]); &#125; Q=read(); while(Q--) &#123; q[1]=(read()+ans)%n+1;q[2]=(read()+ans)%n+1;q[3]=(read()+ans)%n+1;q[4]=(read()+ans)%n+1; sort(q+1,q+1+4); Solve(q[1],q[2],q[3],q[4]); &#125; return 0;&#125;]]></content>
      <categories>
        <category>主席树</category>
      </categories>
      <tags>
        <tag>二分</tag>
        <tag>主席树</tag>
        <tag>可持久化线段树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「BZOJ5164」餐厅计划问题]]></title>
    <url>%2F2019%2F03%2F25%2F%E3%80%8CBZOJ5164%E3%80%8D%E9%A4%90%E5%8E%85%E8%AE%A1%E5%88%92%E9%97%AE%E9%A2%98-Solution%2F</url>
    <content type="text"><![CDATA[什么鬼，数据范围直接加上两个0？ 传送门BZOJ5164 题解前两天刚做过这题的简化版，数据范围比较小，那题直接上网络流搞就好了。 但是这题数据范围大了好多，没法n方过百万了。 考虑一下，不难发现，总的购买餐巾的数量与购买餐巾数量一定时的最小话费呈一个单谷函数哎！ 然后就可三分或者二分了查找最小值了！ 但是怎么计算购买餐巾数量一定时的最小话费呢？ 当然是贪心啦！ 先一次性把新的餐巾都买来，有新的就用新的，没新的就尝试找一天的旧餐巾送到慢洗部，如果还是不够的话就找离当前最近的一天的旧餐巾送到快西部。 找的时候弄个并查集维护一下就好了。计算最小费用的是$O(n)$的。 注意如果不存在合法方案的话费用为$\infty$。 所以总的时间复杂度为$O(nlog\sum_{i=1}^{n}{ri})$。 然后写完之后交掉发现自己BZOJ竟然rank1。（好吧总共也没几个人A掉） 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;const int maxn=200005,inf=2147483647;int n,m1,m2,c1,c2,p,r[maxn],L=1,R,mid,lst[maxn],fa[maxn];inline char nc()&#123; const int S=131072;static char buf[S],*L,*R; return L==R&amp;&amp;(R=(L=buf)+fread(buf,1,S,stdin),L==R)?EOF:*L++;&#125;inline int read()&#123; int ret=0,f=1;char ch=nc(); while(ch&lt;'0'||ch&gt;'9')&#123;if(ch=='-')f=-f;ch=nc();&#125; while(ch&gt;='0'&amp;&amp;ch&lt;='9')&#123;ret=ret*10+ch-'0';ch=nc();&#125; return ret*f;&#125;inline int getfa(int x)&#123;return fa[x]==x?x:fa[x]=getfa(fa[x]);&#125;inline int check(int cnt)&#123; int ret=cnt*p,p1=1,p2; memset(lst,0,sizeof(lst)); for(int i=1;i&lt;=n;i++) fa[i]=i; for(int i=1;i&lt;=n;i++) &#123; int ri=r[i]; if(cnt&gt;0) &#123; int t=min(ri,cnt); ri-=t;cnt-=t; &#125; if(ri&gt;0) &#123; while(p1&lt;i&amp;&amp;ri&gt;0&amp;&amp;i-p1&gt;=m1) &#123; int t=min(ri,lst[p1]); ri-=t;lst[p1]-=t;ret+=t*c1; if(lst[p1]==0) p1++; &#125; p2=i-m2; while(ri&gt;0&amp;&amp;p2&gt;0&amp;&amp;i-p2&gt;=m2) &#123; int t=min(ri,lst[p2]); ri-=t;lst[p2]-=t;ret+=t*c2; if(lst[p2]==0)&#123;fa[p2]=p2-1;p2=getfa(p2-1);&#125; &#125; if(ri) return inf; &#125; lst[i]=r[i]; &#125; return ret;&#125;int main()&#123; n=read();m1=read();m2=read();c1=read();c2=read();p=read(); if(c1&gt;c2)&#123;swap(m1,m2);swap(c1,c2);&#125; for(int i=1;i&lt;=n;i++) &#123; r[i]=read(); R+=r[i]; &#125; while(L&lt;=R) &#123; mid=(L+R)&gt;&gt;1; check(mid)&gt;=check(mid+1)?L=mid+1:R=mid-1; &#125; printf("%d\n",check(R+1)); return 0;&#125;]]></content>
      <categories>
        <category>贪心</category>
      </categories>
      <tags>
        <tag>网络流</tag>
        <tag>三分</tag>
        <tag>二分</tag>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「ICPC-Beijing 2006」狼抓兔子]]></title>
    <url>%2F2019%2F03%2F24%2F%E3%80%8CICPC-Beijing-2006%E3%80%8D%E7%8B%BC%E6%8A%93%E5%85%94%E5%AD%90-Solution%2F</url>
    <content type="text"><![CDATA[又是一个网络流。 传送门洛谷P4001 BZOJ1001 题解最大流最小割定理的一个简单运用。 很显然题目中要求的就是图中网络的最小割。 所以直接求最大流就好了。 注意题目中的边是双向的。 数据稍微有点大，但是毕竟Dinic可是n方过百万的，直接搞就好了，注意要稍微加一些优化。 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;const int maxn=1000005,maxe=6000005,inf=0x3F3F3F3F;int n,m,S,T,tot,lnk[maxn],son[maxe],nxt[maxe],cap[maxe],que[maxn],dep[maxn],ans;inline char nc()&#123; const int S=131072;static char buf[S],*L,*R; return L==R&amp;&amp;(R=(L=buf)+fread(buf,1,S,stdin),L==R)?EOF:*L++;&#125;inline int read()&#123; int ret=0,f=1;char ch=nc(); while(ch&lt;'0'||ch&gt;'9')&#123;if(ch=='-')f=-f;ch=nc();&#125; while(ch&gt;='0'&amp;&amp;ch&lt;='9')&#123;ret=ret*10+ch-'0';ch=nc();&#125; return ret*f;&#125;inline void add_e(int x,int y,int z)&#123;tot++;son[tot]=y;cap[tot]=z;nxt[tot]=lnk[x];lnk[x]=tot;&#125;int DFS(int now,int lim)&#123; if(lim==0||now==T) return lim; int ret=0; for(int i=lnk[now];i&amp;&amp;lim;i=nxt[i]) &#123; if(cap[i]&gt;0&amp;&amp;dep[now]+1==dep[son[i]]) &#123; int tep=DFS(son[i],min(lim,cap[i])); if(tep) &#123; ret+=tep; lim-=tep; cap[i]-=tep; cap[(i&amp;1)?i+1:i-1]+=tep; &#125; else dep[son[i]]=-1; &#125; &#125; return ret;&#125;inline void Dinic()&#123; while(true) &#123; int hed=0,til=1; memset(dep,63,sizeof(dep)); que[1]=S;dep[S]=1; while(hed!=til) &#123; hed++; for(int i=lnk[que[hed]];i;i=nxt[i]) &#123; if(cap[i]&gt;0&amp;&amp;dep[que[hed]]+1&lt;dep[son[i]]) &#123; dep[son[i]]=dep[que[hed]]+1; til++; que[til]=son[i]; &#125; &#125; &#125; if(dep[T]==inf) return; ans+=DFS(S,inf); &#125;&#125;int main()&#123; n=read();m=read();S=1;T=n*m; for(int i=1;i&lt;=n;i++) &#123; for(int j=1;j&lt;m;j++) &#123; int a=(i-1)*m+j,b=(i-1)*m+j+1,c=read(); add_e(a,b,c);add_e(b,a,c); &#125; &#125; for(int i=1;i&lt;n;i++) &#123; for(int j=1;j&lt;=m;j++) &#123; int a=(i-1)*m+j,b=i*m+j,c=read(); add_e(a,b,c);add_e(b,a,c); &#125; &#125; for(int i=1;i&lt;n;i++) &#123; for(int j=1;j&lt;m;j++) &#123; int a=(i-1)*m+j,b=i*m+j+1,c=read(); add_e(a,b,c);add_e(b,a,c); &#125; &#125; Dinic(); printf("%d\n",ans); return 0;&#125;]]></content>
      <categories>
        <category>最大流</category>
      </categories>
      <tags>
        <tag>网络流</tag>
        <tag>最大流</tag>
        <tag>Dinic</tag>
        <tag>最小割</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「ZJOI模拟赛」线段树]]></title>
    <url>%2F2019%2F03%2F19%2F%E3%80%8CZJOI%E6%A8%A1%E6%8B%9F%E8%B5%9B%E3%80%8D%E7%BA%BF%E6%AE%B5%E6%A0%91-Solution%2F</url>
    <content type="text"><![CDATA[骚年，你只要种一棵主席树和两棵线段树就能A了这题了，多环保啊！ 题面出于一些原因，这里不放题面。 题解考虑询问的实质。 其实询问的答案必然是序列A中一整段连续区间的最大值。 将$m$个操作进行处理，每个操作都往离它最近的有交集的两个操作（一个操作向左延伸，一个向右）建边。 然后询问的时候倍增，就能很快找到询问实际的左右边界。 用主席树又可以很快找到一个点在操作区间$[L,R]$中最后覆盖它的是哪一个操作。 于是乎建边的时候开一棵线段树，维护全局最大值的时候再开一棵，一共三棵树。 然后就好了。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;const int maxn=100005,LOG=18;int n,m,q,A[maxn],QL[maxn],QR[maxn],FL[maxn][LOG],FR[maxn][LOG];inline int read()&#123; int ret=0,f=1;char ch=getchar(); while(ch&lt;'0'||ch&gt;'9')&#123;if(ch=='-')f=-f;ch=getchar();&#125; while(ch&gt;='0'&amp;&amp;ch&lt;='9')&#123;ret=ret*10+ch-'0';ch=getchar();&#125; return ret*f;&#125;struct SegmentTree&#123; struct Node&#123;int Max,Tag;&#125;Tree[maxn*4]; inline void PushUp(int rt)&#123;Tree[rt].Max=max(Tree[rt*2].Max,Tree[rt*2+1].Max);&#125; inline void PushDown(int rt) &#123; if(Tree[rt].Tag==0) return; Tree[rt*2].Max=Tree[rt].Tag;Tree[rt*2+1].Max=Tree[rt].Tag; Tree[rt*2].Tag=Tree[rt].Tag;Tree[rt*2+1].Tag=Tree[rt].Tag; Tree[rt].Tag=0; &#125; inline void RangeUpdate(int LL,int RR,int num,int L=1,int R=n,int rt=1) &#123; if(LL&lt;=L&amp;&amp;R&lt;=RR)&#123;Tree[rt].Max=Tree[rt].Tag=num;return;&#125; PushDown(rt); int M=(L+R)&gt;&gt;1; if(LL&lt;=M) RangeUpdate(LL,RR,num,L,M,rt*2); if(M&lt;RR) RangeUpdate(LL,RR,num,M+1,R,rt*2+1); PushUp(rt); &#125; inline int RangeQuery(int LL,int RR,int L=1,int R=n,int rt=1) &#123; if(LL&lt;=L&amp;&amp;R&lt;=RR) return Tree[rt].Max; PushDown(rt); int M=(L+R)&gt;&gt;1,ret=0; if(LL&lt;=M) ret=max(ret,RangeQuery(LL,RR,L,M,rt*2)); if(M&lt;RR) ret=max(ret,RangeQuery(LL,RR,M+1,R,rt*2+1)); return ret; &#125; void Build(int* A,int L=1,int R=n,int rt=1) &#123; if(L==R)&#123;Tree[rt].Max=A[L];return;&#125; int M=(L+R)&gt;&gt;1; Build(A,L,M,rt*2); Build(A,M+1,R,rt*2+1); PushUp(rt); &#125;&#125;TA,TB;struct ChairmanTree&#123; int tot,R[maxn]; struct Node&#123;int L,R,Val;&#125;Tree[maxn*4*LOG]; int New()&#123;return ++tot;&#125; void Build(int rt,int L=1,int R=n) &#123; if(L==R) return; if(rt==1) this-&gt;R[0]=1; Tree[rt].L=New(); Tree[rt].R=New(); int M=(L+R)&gt;&gt;1; Build(Tree[rt].L,L,M); Build(Tree[rt].R,M+1,R); &#125; void RangeUpdate(int LL,int RR,int num,int pre,int rt,int L=1,int R=n) &#123; Tree[rt]=Tree[pre]; if(LL&lt;=L&amp;&amp;R&lt;=RR)&#123;Tree[rt].Val=num;return;&#125; int M=(L+R)&gt;&gt;1; if(LL&lt;=M) &#123; Tree[rt].L=New(); RangeUpdate(LL,RR,num,Tree[pre].L,Tree[rt].L,L,M); &#125; if(M&lt;RR) &#123; Tree[rt].R=New(); RangeUpdate(LL,RR,num,Tree[pre].R,Tree[rt].R,M+1,R); &#125; &#125; int Query(int P,int rt,int L=1,int R=n) &#123; if(L==R) return Tree[rt].Val; int M=(L+R)&gt;&gt;1,ret=Tree[rt].Val; if(P&lt;=M) return max(ret,Query(P,Tree[rt].L,L,M)); else return max(ret,Query(P,Tree[rt].R,M+1,R)); &#125;&#125;TC;int main()&#123; freopen("segment.in","r",stdin); freopen("segment.out","w",stdout); n=read();m=read();q=read(); for(int i=1;i&lt;=n;i++) A[i]=read(); TA.Build(A); TC.Build(TC.New()); for(int i=1;i&lt;=m;i++) &#123; QL[i]=read();QR[i]=read(); FL[i][0]=TB.RangeQuery(QL[i],QL[i]); FR[i][0]=TB.RangeQuery(QR[i],QR[i]); TC.R[i]=TC.New(); TC.RangeUpdate(QL[i],QR[i],i,TC.R[i-1],TC.R[i]); TB.RangeUpdate(QL[i],QR[i],i); &#125; for(int i=1;i&lt;=m;i++) &#123; for(int j=1;j&lt;=16;j++) &#123; FL[i][j]=FL[FL[i][j-1]][j-1]; FR[i][j]=FR[FR[i][j-1]][j-1]; &#125; &#125; while(q--) &#123; if(read()==1) &#123; int u=read(),v=read(); TA.RangeUpdate(u,u,v); &#125; else &#123; int L=read(),R=read(),K=read(); int Lm=TC.Query(K,TC.R[R]),Rm=Lm; if(Lm&lt;L) Lm=Rm=0; for(int i=16;i&gt;=0;i--) &#123; if(FL[Lm][i]&gt;=L) Lm=FL[Lm][i]; if(FR[Rm][i]&gt;=L) Rm=FR[Rm][i]; &#125; Lm=QL[Lm];Rm=QR[Rm]; if(Lm&gt;0) printf("%d\n",TA.RangeQuery(Lm,Rm)); else printf("%d\n",TA.RangeQuery(K,K)); &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>倍增</category>
      </categories>
      <tags>
        <tag>线段树</tag>
        <tag>主席树</tag>
        <tag>倍增</tag>
        <tag>可持久化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「网络流24题」家园]]></title>
    <url>%2F2019%2F03%2F18%2F%E3%80%8C%E7%BD%91%E7%BB%9C%E6%B5%8124%E9%A2%98%E3%80%8D%E5%AE%B6%E5%9B%AD-Solution%2F</url>
    <content type="text"><![CDATA[你必须从四维空间的角度来解这一题… 传送门洛谷P2754 LOJ6015 题解此题的重难点在于建模。 不难发现，如果单单考虑空间，这题的模型还是难以建立。 所以需要将时间也考虑在内，从四维空间的角度来建模。（什么鬼？？？） 设图中的每一个节点都表示某一个时间上的一个星球，比如“第$i$天的第$j$个星球”。 考虑宇宙飞船的飞行，其实就是在四维空间内穿梭，每一次飞行相当于“从第$i$天的第$j$个星球飞往第$i+1$天的第$k$个星球”。 然后建模就很方便了。 对于第$i​$天的星球$j​$，都连向第$i+1​$天的星球$j​$，容量为$+\infty​$。 弄一个源，连向每一天的地球；再由每一天的月球连向一个汇，容量均为为$+\infty$。 对于一次飞行，在起点与终点之间连一条容量为飞船大小的边。 然后最大流就是当前最多能运送的人员数量。 于是乎就可以从小到大枚举答案，每次答案增加时就在网络中加入一套新的节点和边。 当最大流大于等于人数的时候就行了。 由于每次都是在上一次的基础之上继续刷最大流，用Dinic会比较快。（网络流管什么时间复杂度） 如果地球和月球不在一个联通块里，就无解，通过并查集可以解决。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;const int maxn=12000,maxe=31000,inf=0x3F3F3F3F;int n,m,k,S=1,T=2,tot,lnk[maxn],dep[maxn],son[maxe],nxt[maxe],cap[maxe],que[maxn],ans,MF,fa[100];inline int read()&#123; int ret=0,f=1;char ch=getchar(); while(ch&lt;'0'||ch&gt;'9')&#123;if(ch=='-')f=-f;ch=getchar();&#125; while(ch&gt;='0'&amp;&amp;ch&lt;='9')&#123;ret=ret*10+ch-'0';ch=getchar();&#125; return ret*f;&#125;inline void add_e(int x,int y,int z)&#123;tot++;son[tot]=y;cap[tot]=z;nxt[tot]=lnk[x];lnk[x]=tot;&#125;struct SpaceShip&#123;int r,S[20],H;&#125;A[25];inline int getfa(int x)&#123;return fa[x]==x?x:fa[x]=getfa(fa[x]);&#125;inline void Merge(int x,int y)&#123; if(getfa(x)==getfa(y)) return; fa[fa[x]]=fa[y];&#125;inline int id(int x)&#123; if(x==0) return 1; if(x==-1) return 2; return x+2;&#125;int DFS(int now,int lim)&#123; if(lim==0||now==T) return lim; int ret=0; for(int i=lnk[now];i;i=nxt[i]) &#123; if(dep[now]+1==dep[son[i]]) &#123; int tep=DFS(son[i],min(lim,cap[i])); ret+=tep; cap[i]-=tep; cap[(i&amp;1)?i+1:i-1]+=tep; &#125; &#125; return ret;&#125;inline void Dinic()&#123; while(true) &#123; memset(dep,63,sizeof(dep)); int hed=0,til=1; que[1]=S;dep[S]=1; while(hed!=til) &#123; hed++; for(int i=lnk[que[hed]];i;i=nxt[i]) &#123; if(cap[i]&gt;0&amp;&amp;dep[que[hed]]+1&lt;dep[son[i]]) &#123; dep[son[i]]=dep[que[hed]]+1; til++;que[til]=son[i]; &#125; &#125; &#125; if(dep[T]==inf) return; MF+=DFS(S,inf); &#125;&#125;int main()&#123; n=read();m=read();k=read(); for(int i=1;i&lt;=n+2;i++) fa[i]=i; for(int i=1;i&lt;=m;i++) &#123; A[i].H=read();A[i].r=read(); for(int j=1;j&lt;=A[i].r;j++) A[i].S[j]=read(); for(int j=1;j&lt;A[i].r;j++) Merge(id(A[i].S[j]),id(A[i].S[j+1])); &#125; if(getfa(id(0))!=getfa(id(-1)))&#123;printf("%d\n",0);return 0;&#125; add_e(S,3,inf);add_e(3,S,0);add_e(4,T,inf);add_e(T,4,0); while(true) &#123; ans++; add_e(S,ans*(n+2)+3,inf); add_e(ans*(n+2)+3,S,0); add_e(ans*(n+2)+4,T,inf); add_e(T,ans*(n+2)+4,0); for(int i=1;i&lt;=m;i++) &#123; int a=(ans-1)*(n+2)+2+id(A[i].S[(ans-1)%A[i].r+1]),b=ans*(n+2)+2+id(A[i].S[ans%A[i].r+1]); add_e(a,b,A[i].H);add_e(b,a,0); &#125; add_e((ans-1)*(n+2)+3,ans*(n+2)+3,inf); add_e(ans*(n+2)+3,(ans-1)*(n+2)+3,0); add_e((ans-1)*(n+2)+4,ans*(n+2)+4,inf); add_e(ans*(n+2)+4,(ans-1)*(n+2)+4,0); for(int i=1;i&lt;=n;i++) &#123; int a=(ans-1)*(n+2)+2+i+2,b=ans*(n+2)+2+i+2; add_e(a,b,inf);add_e(b,a,0); &#125; Dinic(); if(MF&gt;=k)&#123;printf("%d\n",ans);return 0;&#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>最大流</category>
      </categories>
      <tags>
        <tag>网络流</tag>
        <tag>最大流</tag>
        <tag>Dinic</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「网络流24题」试题库问题]]></title>
    <url>%2F2019%2F03%2F18%2F%E3%80%8C%E7%BD%91%E7%BB%9C%E6%B5%8124%E9%A2%98%E3%80%8D%E8%AF%95%E9%A2%98%E5%BA%93%E9%97%AE%E9%A2%98-Solution%2F</url>
    <content type="text"><![CDATA[又是一道经典题。 传送门洛谷P2763 LOJ6006 题解考虑如何建模。 很显然这是一个二分图。 对于题库中的每一道题，像试卷中的所有可行的空位连边。 比如题库中一道题可以属于$1$类或者$2类$，那么就往试卷中所有$1类$和$2$类的位置连边。 由于一道题只能用在试卷上的一个位置，且试卷上的一个位置也只能放一道题。 所以直接上匈牙利算法求解该二分图的最大匹配即可。 当最大匹配数小于$m$时即为无解。（洛谷上的数据真水，一开始我没考虑无解的情况竟然AC了） 也可以转化成最大流问题，然后用EK、Dinic等求解。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include&lt;cstdio&gt;#include&lt;cstring&gt;using namespace std;const int maxn=1005;int k,st[maxn],grp[maxn],n,m,tot,lnk[maxn],son[maxn*maxn],nxt[maxn*maxn],cp[maxn],len[maxn],A[25][maxn],sum;bool vis[maxn];inline int read()&#123; int ret=0,f=1;char ch=getchar(); while(ch&lt;'0'||ch&gt;'9')&#123;if(ch=='-')f=-f;ch=getchar();&#125; while(ch&gt;='0'&amp;&amp;ch&lt;='9')&#123;ret=ret*10+ch-'0';ch=getchar();&#125; return ret*f;&#125;inline void add_e(int x,int y)&#123;tot++;son[tot]=y;nxt[tot]=lnk[x];lnk[x]=tot;&#125;bool Hungary(int now)&#123; for(int i=lnk[now];i;i=nxt[i]) &#123; if(!vis[son[i]]) &#123; vis[son[i]]=true; if(!cp[son[i]]||Hungary(cp[son[i]])) &#123; cp[son[i]]=now; return true; &#125; &#125; &#125; return false;&#125;int main()&#123; k=read();n=read(); for(int i=1;i&lt;=k;i++) &#123; int cnt=read();st[i]=m+1; for(int j=1;j&lt;=cnt;j++) grp[++m]=i; &#125; for(int i=1;i&lt;=n;i++) &#123; int cnt=read(); for(int j=1;j&lt;=cnt;j++) &#123; int to=read(); for(int k=st[to];grp[k]==to;k++) add_e(i,k); &#125; &#125; for(int i=1;i&lt;=n;i++)&#123;memset(vis,false,n+3);Hungary(i);&#125; for(int i=1;i&lt;=m;i++) if(cp[i]) &#123;len[grp[i]]++;A[grp[i]][len[grp[i]]]=cp[i];&#125; for(int i=1;i&lt;=k;i++) sum+=len[i]; if(sum&lt;m)&#123;printf("No Solution!");return 0;&#125; for(int i=1;i&lt;=k;i++) &#123; printf("%d:",i); for(int j=1;j&lt;=len[i];j++) printf(" %d",A[i][j]); printf("\n"); &#125; return 0;&#125;]]></content>
      <categories>
        <category>二分图最大匹配</category>
      </categories>
      <tags>
        <tag>网络流</tag>
        <tag>最大流</tag>
        <tag>匈牙利算法</tag>
        <tag>二分图</tag>
        <tag>二分图最大匹配</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「网络流24题」运输问题]]></title>
    <url>%2F2019%2F03%2F18%2F%E3%80%8C%E7%BD%91%E7%BB%9C%E6%B5%8124%E9%A2%98%E3%80%8D%E8%BF%90%E8%BE%93%E9%97%AE%E9%A2%98-Solution%2F</url>
    <content type="text"><![CDATA[好经典的模型。 传送门洛谷P4015 LOJ6011 题解乍一看就是一个二分图。 但是要求很明显要求最小费用最大流。 考虑如何建模。 由于每一个仓库只能流出定量的货物，但是又不能把每一个仓库看做源。 所以把所有货物都连到同一个源上，连到第$i​$个仓库的边嘚的容量为$A_i​$，费用为$0​$。 每一家零售店又都连到一个汇上，从第$i$家零售店连出的边的容量为$B_i$，费用为$0$。 中间从仓库到零售店的边就按照题目里的说的那样连，容量为$+\infty$。 然后直接跑最小费用最大流就好了。 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;const int maxn=210,maxm=20205,inf=0x3F3F3F3F;int m,n,S,T,tot,lnk[maxn],son[maxm],nxt[maxm],w[maxm],cap[maxm],que[maxn],lst[maxn],pre[maxn],dist[maxn],flow[maxn],ans;bool vis[maxn];inline int read()&#123; int ret=0,f=1;char ch=getchar(); while(ch&lt;'0'||ch&gt;'9')&#123;if(ch=='-')f=-f;ch=getchar();&#125; while(ch&gt;='0'&amp;&amp;ch&lt;='9')&#123;ret=ret*10+ch-'0';ch=getchar();&#125; return ret*f;&#125;inline void add_e(int x,int y,int z,int c)&#123;tot++;son[tot]=y;w[tot]=z;cap[tot]=c;nxt[tot]=lnk[x];lnk[x]=tot;&#125;inline void MinCostMaxFlow(int flg)&#123; while(true) &#123; if(flg==1) memset(dist,63,sizeof(dist)); else memset(dist,192,sizeof(dist)); memset(flow,63,sizeof(flow)); int hed=0,til=1; que[1]=S;dist[S]=0;vis[S]=true;pre[T]=0; while(hed!=til) &#123; hed=(hed+1)%maxn;vis[que[hed]]=false; for(int i=lnk[que[hed]];i;i=nxt[i]) &#123; if(cap[i]&amp;&amp;((flg==1&amp;&amp;dist[que[hed]]+w[i]&lt;dist[son[i]])||(flg==-1&amp;&amp;dist[que[hed]]+w[i]&gt;dist[son[i]]))) &#123; dist[son[i]]=dist[que[hed]]+w[i]; pre[son[i]]=que[hed]; lst[son[i]]=i; flow[son[i]]=min(flow[que[hed]],cap[i]); if(!vis[son[i]]) &#123; vis[son[i]]=true; til=(til+1)%maxn; que[til]=son[i]; &#125; &#125; &#125; &#125; if(pre[T]==0) return; ans+=flow[T]*dist[T]; int p=T; while(p!=S) &#123; cap[lst[p]]-=flow[T]; cap[(lst[p]&amp;1)?lst[p]+1:lst[p]-1]+=flow[T]; p=pre[p]; &#125; &#125;&#125;int main()&#123; m=read();n=read();S=1;T=m+n+2; for(int i=1;i&lt;=m;i++) &#123; int ai=read(); add_e(S,i+1,0,ai); add_e(i+1,S,0,0); &#125; for(int i=1;i&lt;=n;i++) &#123; int bi=read(); add_e(i+m+1,T,0,bi); add_e(T,i+m+1,0,0); &#125; for(int i=1;i&lt;=m;i++) &#123; for(int j=1;j&lt;=n;j++) &#123; int cij=read(); add_e(i+1,j+m+1,cij,inf); add_e(j+m+1,i+1,-cij,0); &#125; &#125; MinCostMaxFlow(1); printf("%d\n",ans); for(int i=2;i&lt;=tot;i+=2)&#123;cap[i-1]+=cap[i];cap[i]=0;&#125; ans=0; MinCostMaxFlow(-1); printf("%d\n",ans); return 0;&#125;]]></content>
      <categories>
        <category>最小费用最大流</category>
      </categories>
      <tags>
        <tag>网络流</tag>
        <tag>费用流</tag>
        <tag>最大流</tag>
        <tag>最小费用最大流</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「网络流24题」飞行员配对方案问题]]></title>
    <url>%2F2019%2F03%2F18%2F%E3%80%8C%E7%BD%91%E7%BB%9C%E6%B5%8124%E9%A2%98%E3%80%8D%E9%A3%9E%E8%A1%8C%E5%91%98%E9%85%8D%E5%AF%B9%E6%96%B9%E6%A1%88%E9%97%AE%E9%A2%98-Solution%2F</url>
    <content type="text"><![CDATA[没啥好说的，就是二分图的最大匹配 传送门洛谷P2756 LOJ6000 输入输出格式有所不同。 题解就是一个二分图的最大匹配问题啊，裸的一批，直接上匈牙利搞就好了。 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include&lt;cstdio&gt;#include&lt;cstring&gt;using namespace std;const int maxn=105;int n,m,tot,lnk[maxn],son[maxn*maxn],nxt[maxn*maxn],cp[maxn],ans;bool vis[maxn];inline int read()&#123; int ret=0,f=1;char ch=getchar(); while(ch&lt;'0'||ch&gt;'9')&#123;if(ch=='-')f=-f;ch=getchar();&#125; while(ch&gt;='0'&amp;&amp;ch&lt;='9')&#123;ret=ret*10+ch-'0';ch=getchar();&#125; return ret*f;&#125;inline void add_e(int x,int y)&#123;tot++;son[tot]=y;nxt[tot]=lnk[x];lnk[x]=tot;&#125;bool Hungary(int now)&#123; for(int i=lnk[now];i;i=nxt[i]) &#123; if(!vis[son[i]]) &#123; vis[son[i]]=true; if(!cp[son[i]]||Hungary(cp[son[i]])) &#123; cp[son[i]]=now; return true; &#125; &#125; &#125; return false;&#125;int main()&#123; m=read();n=read(); while(true) &#123; int a=read(),b=read()-m; if(a&lt;0&amp;&amp;b&lt;0) break; add_e(b,a); &#125; for(int i=1;i&lt;=n;i++) &#123; memset(vis,false,sizeof(vis)); ans+=Hungary(i); &#125; if(ans==0)&#123;printf("No Solution!\n");return 0;&#125; printf("%d\n",ans); for(int i=1;i&lt;=m;i++) if(cp[i]) printf("%d %d\n",i,cp[i]+m); return 0;&#125;]]></content>
      <categories>
        <category>二分图最大匹配</category>
      </categories>
      <tags>
        <tag>网络流</tag>
        <tag>最大流</tag>
        <tag>二分图最大匹配</tag>
        <tag>匈牙利</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「网络流24题」餐巾计划问题]]></title>
    <url>%2F2019%2F03%2F18%2F%E3%80%8C%E7%BD%91%E7%BB%9C%E6%B5%8124%E9%A2%98%E3%80%8D%E9%A4%90%E5%B7%BE%E8%AE%A1%E5%88%92%E9%97%AE%E9%A2%98-Solution%2F</url>
    <content type="text"><![CDATA[又是一道有意思的网络流。 传送门洛谷P1251 LOJ6008 数据输入格式略有不同 题解此题重点在于建模。 首先很显然这题是一个费用流。 但是建模不是很好搞，需要绕几个弯。 首先拆点，将每一天分为早上和下午，早上需要准备好$r_i​$块干净的餐巾，晚上又免费获得了$r_i​$块脏的餐巾。 于是乎可以这样建图： 从源点连出$n$条边（绿的那些）到早上（下面那一排点），容量为$+\infty$，代价为$p$。如果需要买新的餐巾，从这些边流过来。 表示早上的$n$个点再连出来$n$条边到汇，容量为$r_i$，代价为$0$。正常情况下这些变必须满载。表示每天早上都可以提供$r_i$条干净的餐巾。 从源点再连出来$n$条边到每一个表示晚上的节点（上面一排），容量为$r_i$，代价为$0$。表示每天晚上可以免费获得$r_i$条脏餐巾。这些边不一定满载，因为脏的餐巾可以扔掉。 表示每一天晚上的节点再连出来一条边到下一天晚上（红的边），容量为$+\infty​$，代价为$0​$。当天的脏餐巾可以放到下一天再处理。 表示每一天晚上的节点连出一条边到$m$天后的早上（蓝的边），容量为$+ \infty$，代价为$f$。表示送去快洗部。 送去慢洗部的同上。 然后直接刷最小费用最大流即可。 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;typedef long long LL;const int maxn=4005,maxe=24005,inf=0x3F3F3F3F;int N,r[2005],p,m,f,n,s,tot,S,T,lnk[maxn],son[maxe],nxt[maxe],w[maxe],cap[maxe],que[maxn],dist[maxn],lst[maxn],pre[maxn],flow[maxn];bool vis[maxn];LL ans;inline int read()&#123; int ret=0,f=1;char ch=getchar(); while(ch&lt;'0'||ch&gt;'9')&#123;if(ch=='-')f=-f;ch=getchar();&#125; while(ch&gt;='0'&amp;&amp;ch&lt;='9')&#123;ret=ret*10+ch-'0';ch=getchar();&#125; return ret*f;&#125;inline void add_e(int x,int y,int z,int c)&#123; tot++;son[tot]=y;w[tot]=z;cap[tot]=c;nxt[tot]=lnk[x];lnk[x]=tot; tot++;son[tot]=x;w[tot]=-z;cap[tot]=0;nxt[tot]=lnk[y];lnk[y]=tot;&#125;inline void MinCostMaxFlow()&#123; while(true) &#123; memset(dist,63,sizeof(dist)); memset(flow,63,sizeof(flow)); int hed=0,til=1; que[1]=S;dist[S]=0;vis[S]=true;pre[T]=0; while(hed!=til) &#123; hed=(hed+1)%maxn;vis[que[hed]]=false; for(int i=lnk[que[hed]];i;i=nxt[i]) &#123; if(cap[i]&gt;0&amp;&amp;dist[que[hed]]+w[i]&lt;dist[son[i]]) &#123; dist[son[i]]=dist[que[hed]]+w[i]; lst[son[i]]=i; pre[son[i]]=que[hed]; flow[son[i]]=min(flow[que[hed]],cap[i]); if(!vis[son[i]]) &#123; vis[son[i]]=true; til=(til+1)%maxn; que[til]=son[i]; &#125; &#125; &#125; &#125; if(pre[T]==0) return; ans+=(LL)dist[T]*flow[T]; int p=T; while(p!=S) &#123; cap[lst[p]]-=flow[T]; cap[(lst[p]&amp;1)?lst[p]+1:lst[p]-1]+=flow[T]; p=pre[p]; &#125; &#125;&#125;int main()&#123; N=read();S=2*N+1;T=2*N+2; for(int i=1;i&lt;=N;i++) r[i]=read(); p=read();m=read();f=read();n=read();s=read(); for(int i=1;i&lt;=N;i++) add_e(S,i,p,inf); for(int i=1;i&lt;=N;i++) add_e(i,T,0,r[i]); for(int i=1;i&lt;=N;i++) add_e(S,i+N,0,r[i]); for(int i=1;i&lt;N;i++) add_e(i+N,i+N+1,0,inf); for(int i=1;i&lt;=N;i++) &#123; int to1=i+m,to2=i+n; if(to1&lt;=N) add_e(i+N,to1,f,inf); if(to2&lt;=N) add_e(i+N,to2,s,inf); &#125; MinCostMaxFlow(); printf("%lld\n",ans); return 0;&#125;]]></content>
      <categories>
        <category>最小费用最大流</category>
      </categories>
      <tags>
        <tag>网络流</tag>
        <tag>费用流</tag>
        <tag>最大流</tag>
        <tag>最小费用最大流</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「网络流24题」魔术球问题]]></title>
    <url>%2F2019%2F03%2F18%2F%E3%80%8C%E7%BD%91%E7%BB%9C%E6%B5%8124%E9%A2%98%E3%80%8D%E9%AD%94%E6%9C%AF%E7%90%83%E9%97%AE%E9%A2%98-Solution%2F</url>
    <content type="text"><![CDATA[纳尼？这是网络流？？？ 传送门洛谷P2765 LOJ6003 题解这题一眼看上去就是一个贪心。 从小到大枚举球的编号，然后从$1$到$n$枚举柱子，找到第一个可以放上去的柱子后就把球放上去，直到放不了位置。 这个贪心看起来很假，但是是对的。 考虑网络流的做法，对于两个球，如果编号加和为完全平方数，那么就从编号小的球往编号大的球建一条边。然后整张图的最小路径覆盖就等于所需柱子的数量。从小到大枚举球的个数，当所需柱子的数量大于$n​$时就上一次的个数就是答案。 考虑贪心和网络流的关系。 其实贪心的过程就是往网络里加点的过程。由于优先考虑加到有球的柱子上，所以就相当于在维护最小路径覆盖是的数量。 所以贪心的做法本质上和网络流的做法是一样的。 代码123456789101112131415161718192021222324252627#include&lt;cmath&gt;#include&lt;cstdio&gt;using namespace std;const int maxn=60;int n,ans,top[maxn],A[maxn][maxn];inline bool check(int x)&#123; int sq=sqrt(x)+1e-10; return sq*sq==x;&#125;int main()&#123; scanf("%d",&amp;n); while(true) &#123; bool suc=false; for(int i=1;i&lt;=n;i++) if(top[i]==0||check(A[i][top[i]]+ans+1)) &#123;ans++;top[i]++;A[i][top[i]]=ans;suc=true;break;&#125; if(!suc) break; &#125; printf("%d\n",ans); for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=top[i];j++) printf("%d%c",A[i][j],j==top[i]?'\n':' '); return 0;&#125;]]></content>
      <categories>
        <category>贪心</category>
      </categories>
      <tags>
        <tag>网络流</tag>
        <tag>贪心</tag>
        <tag>最大流</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「JSOI2013」丢番图]]></title>
    <url>%2F2019%2F03%2F17%2F%E3%80%8CJSOI2013%E3%80%8D%E4%B8%A2%E7%95%AA%E5%9B%BE-Solution%2F</url>
    <content type="text"><![CDATA[挺好玩的一个数学题。 传送门洛谷P5253 BZOJ4459 题解首先来看看题目中给出的式子，看起来不是很好搞： \frac{1}{x}+\frac{1}{y}=\frac{1}{n}分式不好搞，所以先给它乘开： ny+nx=xy都移到一边： xy-nx-ny=0化为两式相乘的形式： (x-n)(y-n)=n^2不难发现，将$n^2$分解为任意两数相乘的形式时，都有唯一的$x,y$与之对应。 所以$n^2$的因子个数加一除以二就是答案。 但是$n^2$比较大，不好分解质因数。 但是$n$比较小，根据平方的性质，$n^2$的每一个质因子的个数等于$n$每一个质因子个数的两倍。 然后就好搞了。 代码12345678910111213141516171819202122232425262728293031#include&lt;cstdio&gt;using namespace std;typedef long long LL;int cnt,p[665000],tot[665000];LL n,ans;bool vis[10000005];inline void make_p() //欧拉筛素数&#123; vis[0]=vis[1]=true; for(int i=2;i&lt;=10000000;i++) &#123; if(!vis[i])&#123;cnt++;p[cnt]=i;&#125; for(int j=1;j&lt;=cnt&amp;&amp;p[j]*i&lt;=10000000;j++) vis[p[j]*i]=true; &#125;&#125;inline void Solve()&#123; for(int i=1;i&lt;=cnt;i++) while(n%p[i]==0) &#123;n/=p[i];tot[i]++;&#125; //分解质因数 if(n&gt;1)&#123;cnt++;tot[cnt]=1;p[cnt]=n;&#125; ans=1; for(int i=1;i&lt;=cnt;i++) ans*=2*tot[i]+1; //计算因子个数 ans=(ans+1)/2;&#125;int main()&#123; make_p(); scanf("%lld",&amp;n); Solve(); printf("%lld\n",ans); return 0;&#125;]]></content>
      <categories>
        <category>分解质因数</category>
      </categories>
      <tags>
        <tag>分解质因数</tag>
        <tag>数学</tag>
        <tag>欧拉筛</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「VK Cup 2015-Round 2」A.Berland Miners /「ZJOI模拟赛」俄刻阿诺斯]]></title>
    <url>%2F2019%2F03%2F15%2F%E3%80%8CVK%20Cup%202015-Round%202%E3%80%8DA.Berland%20Miners%20%E3%80%8CZJOI%E6%A8%A1%E6%8B%9F%E8%B5%9B%E3%80%8D%E4%BF%84%E5%88%BB%E9%98%BF%E8%AF%BA%E6%96%AF-Solution%2F</url>
    <content type="text"><![CDATA[没想到蒟蒻我有生之年竟然也能A上一道VK CUP的题。 传送门原题链接： CF533A 洛谷 数据范围与时有所不同。 下文中的B数组就是棒子的长度。 题解首先考虑没有开凿操作时，如何判断当前的情况是否合法。 不难发现，能否将一根棒子放进一个洞穴里，取决于该洞穴到根中高度最小的节点，设每个节点到根节点路径上高度最小值为$Min[i]​$（可以$O(n)​$构造出来）。对$Min​$和$B​$两个数组分别从小到大排序。 当满足$B[i] \leq Min[j]$时，棒子$i$就可以放进洞穴$j$里。设第$i$根棒子可以放进$num[i]$个洞穴。当满足$\forall i,num[i]\geq i$时，就合法。也就是当且仅当$\min_{i=1}^{n}{(num[i]-i)}\geq 0$时合法。 然后考虑开凿操作。由于不知道开凿哪一个节点，那么$O(n)​$枚举过去。然后二分要开凿的高度。 比如要对图中这个节点进行开凿，那么它的子树中的以该节点为最小值的节点的$Min$值就会改变，所以$Min$数组中就可能需要删去几个原先的值然后加入几个新元素（可能加入二分后的高度或原先到根节点链上的次小值），由于$Min$数组中的每一个元素都对$num$数组中一个连续区间产生贡献，且删除一个元素后一整个区间的值被减1，加入一个元素后一整个区间的值被加1，所以就套个线段树维护全局最小值即可。并且由于每个节点到树根的链上只有一个最小值，所以对于每一个节点，只有一个节点在二分的时候会影响到它，所以时间复杂度为$O(n\log n \log B_i)$。 然后蒟蒻我傻呵呵地卡了半天常数，死活过不去，只好想$O(n\log n)$的做法。 经过ZZK大佬的点拨，我发现其实根本不需要二分。 找到最长的$num_i-B_i$的值小于零的棒子，那么如果有解，就一定要将某个洞穴的高度开凿到这根棒子的长度。 于是乎就可以$O(n)$枚举开凿哪一个洞穴，然后检查一下开凿完之后是否合法就好了。 代码下面是两个log的代码（贼慢）： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;const int maxn=200005,inf=0x3F3F3F3F;int n,m,tot,lnk[maxn],w[maxn],son[maxn*2],nxt[maxn*2],B[maxn],Min[maxn],Sec[maxn],tot2,lnk2[maxn],son2[maxn],nxt2[maxn],L,R=inf,mid;inline int read()&#123; int ret=0,f=1;char ch=getchar(); while(ch&lt;'0'||ch&gt;'9')&#123;if(ch=='-')f=-f;ch=getchar();&#125; while(ch&gt;='0'&amp;&amp;ch&lt;='9')&#123;ret=ret*10+ch-'0';ch=getchar();&#125; return ret*f;&#125;inline void add_e(int x,int y)&#123;tot++;son[tot]=y;nxt[tot]=lnk[x];lnk[x]=tot;&#125;inline void add_e2(int x,int y)&#123;tot2++;son2[tot2]=y;nxt2[tot2]=lnk2[x];lnk2[x]=tot2;&#125;struct SegmentTree&#123; struct Node&#123;int Min,Tag;&#125;Tree[maxn*4]; void PushUp(int rt)&#123;Tree[rt].Min=min(Tree[rt*2].Min,Tree[rt*2+1].Min);&#125; void PushDown(int rt) &#123; if(!Tree[rt].Tag) return; Tree[rt*2].Min+=Tree[rt].Tag;Tree[rt*2+1].Min+=Tree[rt].Tag; Tree[rt*2].Tag+=Tree[rt].Tag;Tree[rt*2+1].Tag+=Tree[rt].Tag; Tree[rt].Tag=0; &#125; void RangeUpdate(int LL,int RR,int delta,int L=1,int R=m,int rt=1) &#123; if(LL&lt;=L&amp;&amp;R&lt;=RR)&#123;Tree[rt].Min+=delta;Tree[rt].Tag+=delta;return;&#125; PushDown(rt); int M=(L+R)/2; if(LL&lt;=M) RangeUpdate(LL,RR,delta,L,M,rt*2); if(M&lt;RR) RangeUpdate(LL,RR,delta,M+1,R,rt*2+1); PushUp(rt); &#125; void Build(int L=1,int R=m,int rt=1) &#123; if(L==R)&#123;Tree[rt].Min=L-m-1;return;&#125; int M=(L+R)/2; Build(L,M,rt*2); Build(M+1,R,rt*2+1); PushUp(rt); &#125; int QueryAll()&#123;return Tree[1].Min;&#125;&#125;T;void Build(int now,int fa,int id,int mi,int se)&#123; if(w[now]&lt;=mi)&#123;se=mi;mi=w[now];id=now;&#125; else if(w[now]&lt;se) se=w[now]; Min[now]=mi;Sec[now]=se;add_e2(id,now); for(int i=lnk[now];i;i=nxt[i]) if(son[i]!=fa) Build(son[i],now,id,mi,se);&#125;inline void Modify(int num,int delta)&#123; static int L,R,mid; L=1;R=m; while(L&lt;=R) &#123; mid=(L+R)/2; B[mid]&lt;=num?L=mid+1:R=mid-1; &#125; if(R&gt;=1) T.RangeUpdate(1,R,delta);&#125;inline bool Check(int now,int fa)&#123; for(int i=lnk2[now];i;i=nxt2[i]) &#123; Modify(Min[now],-1); Modify(min(Sec[son2[i]],w[now]+mid),1); &#125; bool flg=false; if(T.QueryAll()&gt;=0) flg=true; for(int i=lnk2[now];i;i=nxt2[i]) &#123; Modify(Min[now],1); Modify(min(Sec[son2[i]],w[now]+mid),-1); &#125; if(flg) return true; for(int i=lnk[now];i;i=nxt[i]) if(son[i]!=fa&amp;&amp;Check(son[i],now)) return true; return false;&#125;int main()&#123; n=read(); for(int i=1;i&lt;=n;i++) w[i]=read(); for(int i=2;i&lt;=n;i++) &#123; int a=read(),b=read(); add_e(a,b);add_e(b,a); &#125; m=read(); for(int i=1;i&lt;=m;i++) B[i]=read(); sort(B+1,B+1+m); Build(1,0,0,inf,inf); T.Build(); for(int i=1;i&lt;=n;i++) Modify(Min[i],1); while(L&lt;=R) &#123; mid=(L+R)/2; Check(1,0)?R=mid-1:L=mid+1; &#125; printf("%d\n",L&lt;inf?L:-1); return 0;&#125; 一个log的代码（跑的飞快）： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;const int maxn=200005,inf=0x3F3F3F3F;int n,m,tot,lnk[maxn],w[maxn],son[maxn*2],nxt[maxn*2],B[maxn],Min[maxn],Sec[maxn],tot2,lnk2[maxn],son2[maxn],nxt2[maxn],BMax,ans=inf;inline char nc()&#123; static char buf[8388608],*L=buf,*R=buf; return L==R&amp;&amp;(R=(L=buf)+fread(buf,1,8388608,stdin),L==R)?EOF:*L++;&#125;inline int read()&#123; int ret=0,f=1;char ch=nc(); while(ch&lt;'0'||ch&gt;'9')&#123;if(ch=='-')f=-f;ch=nc();&#125; while(ch&gt;='0'&amp;&amp;ch&lt;='9')&#123;ret=ret*10+ch-'0';ch=nc();&#125; return ret*f;&#125;inline void add_e(int x,int y)&#123;tot++;son[tot]=y;nxt[tot]=lnk[x];lnk[x]=tot;&#125;inline void add_e2(int x,int y)&#123;tot2++;son2[tot2]=y;nxt2[tot2]=lnk2[x];lnk2[x]=tot2;&#125;struct SegmentTree&#123; struct Node&#123;int Min,Tag;&#125;Tree[maxn*4]; inline void PushUp(int rt)&#123;Tree[rt].Min=(Tree[rt&lt;&lt;1].Min&lt;Tree[rt&lt;&lt;1|1].Min?Tree[rt&lt;&lt;1].Min:Tree[rt&lt;&lt;1|1].Min);&#125; inline void PushDown(int rt) &#123; if(!Tree[rt].Tag) return; Tree[rt&lt;&lt;1].Min+=Tree[rt].Tag;Tree[rt&lt;&lt;1|1].Min+=Tree[rt].Tag; Tree[rt&lt;&lt;1].Tag+=Tree[rt].Tag;Tree[rt&lt;&lt;1|1].Tag+=Tree[rt].Tag; Tree[rt].Tag=0; &#125; inline void RangeUpdate(int RR,int delta,int L=1,int R=m,int rt=1) &#123; if(RR==m)&#123;Tree[rt].Min+=delta;Tree[rt].Tag+=delta;return;&#125; while(L&lt;=R&amp;&amp;L&lt;=RR) &#123; PushDown(rt); int M=(L+R)&gt;&gt;1; if(M&lt;=RR)&#123;Tree[rt&lt;&lt;1].Min+=delta;Tree[rt&lt;&lt;1].Tag+=delta;L=M+1;rt=rt&lt;&lt;1|1;&#125; else&#123;R=M;rt=rt&lt;&lt;1;&#125; &#125; while(rt&gt;1)&#123;rt&gt;&gt;=1;PushUp(rt);&#125; &#125; void Build(int L=1,int R=m,int rt=1) &#123; if(L==R)&#123;Tree[rt].Min=L-m-1;return;&#125; int M=(L+R)&gt;&gt;1; Build(L,M,rt&lt;&lt;1); Build(M+1,R,rt&lt;&lt;1|1); PushUp(rt); &#125; inline int Query(int pos,int L=1,int R=m,int rt=1) &#123; if(L==R) return Tree[rt].Min; int M=(L+R)&gt;&gt;1; PushDown(rt); if(pos&lt;=M) return Query(pos,L,M,rt&lt;&lt;1); else return Query(pos,M+1,R,rt&lt;&lt;1|1); &#125;&#125;T;void Build(int now,int fa,int id,int mi,int se)&#123; if(w[now]&lt;=mi)&#123;se=mi;mi=w[now];id=now;&#125; else if(w[now]&lt;se) se=w[now]; Min[now]=mi;Sec[now]=se;add_e2(id,now); for(int i=lnk[now];i;i=nxt[i]) if(son[i]!=fa) Build(son[i],now,id,mi,se);&#125;inline void Modify(int num,int delta)&#123; int L=1,R=m,mid; while(L&lt;=R) &#123; mid=(L+R)&gt;&gt;1; B[mid]&lt;=num?L=mid+1:R=mid-1; &#125; if(R&gt;=1) T.RangeUpdate(R,delta);&#125;inline void Solve(int now,int fa)&#123; if(w[now]&lt;BMax&amp;&amp;BMax-w[now]&lt;ans) &#123; for(int i=lnk2[now];i;i=nxt2[i]) &#123; Modify(Min[now],-1); Modify(min(Sec[son2[i]],BMax),1); &#125; if(T.Tree[1].Min&gt;=0) ans=BMax-w[now]; for(int i=lnk2[now];i;i=nxt2[i]) &#123; Modify(Min[now],1); Modify(min(Sec[son2[i]],BMax),-1); &#125; &#125; for(int i=lnk[now];i;i=nxt[i]) if(son[i]!=fa) Solve(son[i],now);&#125;int main()&#123; n=read(); for(int i=1;i&lt;=n;i++) w[i]=read(); for(int i=2;i&lt;=n;i++) &#123; int a=read(),b=read(); add_e(a,b);add_e(b,a); &#125; m=read(); for(int i=1;i&lt;=m;i++) B[i]=read(); sort(B+1,B+1+m); Build(1,0,0,inf,inf); T.Build(); for(int i=1;i&lt;=n;i++) Modify(Min[i],1); for(int i=m;i;i--) if(T.Query(i)&lt;0) &#123;BMax=B[i];break;&#125; if(BMax) Solve(1,0); else ans=0; printf("%d\n",ans==inf?-1:ans); return 0;&#125;]]></content>
      <categories>
        <category>线段树</category>
      </categories>
      <tags>
        <tag>线段树</tag>
        <tag>二分</tag>
        <tag>单调性</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「ZJOI模拟赛」Bug级的存在]]></title>
    <url>%2F2019%2F03%2F14%2F%E3%80%8CZJOI%E6%A8%A1%E6%8B%9F%E8%B5%9B%E3%80%8DBug%E7%BA%A7%E7%9A%84%E5%AD%98%E5%9C%A8-Solution%2F</url>
    <content type="text"><![CDATA[什么毒瘤题目QwQ。 传送门原题链接： CF407E 洛谷 题解首先一个区间满足条件，必须要有整个区间内的$A_i$模$d​$同余，并且没有相同元素，暂时先不考虑需要补上的数的个数。 考虑从左往右枚举右端点$head$，再用一个指针$tail$来控制合法的左端点所在区间，如果$[head,tail]$这个区间不合法，那么就让$tail++$，此时如果左端点$L$在$[head,tail]$区间内构成的所有区间$[L,head]$都合法。而且很显然当$head$变大时，$tail$单调不将。 然后对于左端点$L (L\in[tail,head])$，考虑需要补上的元素个数是否会超过$k$，推一下式子，移一下项，发现当满足以下式子时的左端点$L​$就是合法的： \frac{\max_{i=L}^{R}{a_i}-\min_{i=L}^{R}{a_i}}{d}+L\leq R+k此时当右端点确定时，式子的右边也是确定的。也就是说，我们要找一个满足上式的且最靠左的左端点$L$。可以通过一些办法维护每个左端点$L$到当前枚举到的右端点区间内的最大值和最小值。 当右端点向右移动的时候，考虑维护两个单调栈，一个单调增，一个单调降，就拿单调增的来举例。由单调栈的性质可以得出，区间$[stack[top-1]+1,stack[top]]$内的每一个元素的值都大于$stack[top]$的值，所以当栈顶要被弹出时，将区间$[stack[top-1]+1,stack[top]]$内的每一个左端点的最小值都减去当前值与栈顶的差值。最大值同理。可以用线段树来维护。 然后就可以在线段树上二分来找满足条件的最靠左的左端点，如果当前遍历到的节点的左节点所管辖的区间内中有满足条件的节点就往左走，否则就往右走。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120#include&lt;map&gt;#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;typedef long long LL;const int maxn=200005;const LL inf=0x3F3F3F3F3F3F3F3Fll;int n,k,d,A[maxn],Area[maxn],num,hed,til,top1,stk1[maxn],top2,stk2[maxn],ans,ansL,ansR;map&lt;int,int&gt; H;inline int read()&#123; int ret=0,f=1;char ch=getchar(); while(ch&lt;'0'||ch&gt;'9')&#123;if(ch=='-')f=-f;ch=getchar();&#125; while(ch&gt;='0'&amp;&amp;ch&lt;='9')&#123;ret=ret*10+ch-'0';ch=getchar();&#125; return ret*f;&#125;struct SegmentTree&#123; struct Node&#123;LL Mi,Ma,TagMi,TagMa,Val;&#125;Tree[maxn*4]; void PushUp(int rt) &#123; Tree[rt].Mi=min(Tree[rt*2].Mi,Tree[rt*2+1].Mi); Tree[rt].Ma=max(Tree[rt*2].Ma,Tree[rt*2+1].Ma); Tree[rt].Val=min(Tree[rt*2].Val,Tree[rt*2+1].Val); &#125; void PushDown(int rt) &#123; Tree[rt*2].Mi+=Tree[rt].TagMi;Tree[rt*2].TagMi+=Tree[rt].TagMi;Tree[rt*2].Val-=Tree[rt].TagMi; Tree[rt*2].Ma+=Tree[rt].TagMa;Tree[rt*2].TagMa+=Tree[rt].TagMa;Tree[rt*2].Val+=Tree[rt].TagMa; Tree[rt*2+1].Mi+=Tree[rt].TagMi;Tree[rt*2+1].TagMi+=Tree[rt].TagMi;Tree[rt*2+1].Val-=Tree[rt].TagMi; Tree[rt*2+1].Ma+=Tree[rt].TagMa;Tree[rt*2+1].TagMa+=Tree[rt].TagMa;Tree[rt*2+1].Val+=Tree[rt].TagMa; Tree[rt].TagMi=Tree[rt].TagMa=0; &#125; void RangeUpdateMin(int LL,int RR,int delta,int L=1,int R=n,int rt=1) &#123; if(LL&lt;=L&amp;&amp;R&lt;=RR)&#123;Tree[rt].Mi+=delta;Tree[rt].TagMi+=delta;Tree[rt].Val-=delta;return;&#125; PushDown(rt); int M=(L+R)/2; if(LL&lt;=M) RangeUpdateMin(LL,RR,delta,L,M,rt*2); if(M&lt;RR) RangeUpdateMin(LL,RR,delta,M+1,R,rt*2+1); PushUp(rt); &#125; void RangeUpdateMax(int LL,int RR,int delta,int L=1,int R=n,int rt=1) &#123; if(LL&lt;=L&amp;&amp;R&lt;=RR)&#123;Tree[rt].Ma+=delta;Tree[rt].TagMa+=delta;Tree[rt].Val+=delta;return;&#125; PushDown(rt); int M=(L+R)/2; if(LL&lt;=M) RangeUpdateMax(LL,RR,delta,L,M,rt*2); if(M&lt;RR) RangeUpdateMax(LL,RR,delta,M+1,R,rt*2+1); PushUp(rt); &#125; void Delete(int P,int L=1,int R=n,int rt=1) &#123; if(L==P&amp;&amp;R==P)&#123;Tree[rt].Val=inf;return;&#125; PushDown(rt); int M=(L+R)/2; if(P&lt;=M) Delete(P,L,M,rt*2); if(M&lt;P) Delete(P,M+1,R,rt*2+1); PushUp(rt); &#125; void Build(int L=1,int R=n,int rt=1) &#123; if(L==R)&#123;Tree[rt].Val=L;Tree[rt].Mi=Tree[rt].Ma=A[L];return;&#125; int M=(L+R)/2; Build(L,M,rt*2); Build(M+1,R,rt*2+1); PushUp(rt); &#125; LL Query(int num,int L=1,int R=n,int rt=1) &#123; if(L==R) return L; int M=(L+R)/2; PushDown(rt); if(Tree[rt*2].Val&lt;=num) return Query(num,L,M,rt*2); else return Query(num,M+1,R,rt*2+1); &#125;&#125;T;int main()&#123; n=read();k=read();d=read(); for(int i=1;i&lt;=n;i++) A[i]=read()+1000000000; if(!d) &#123; for(int i=1,j;i&lt;=n;) &#123; j=i; while(j&lt;n&amp;&amp;A[j+1]==A[i]) j++; if(j-i+1&gt;ans)&#123;ans=j-i+1;ansL=i;ansR=j;&#125; i=j+1; &#125; printf("%d %d\n",ansL,ansR); return 0; &#125; for(int i=1;i&lt;=n;) &#123; int j=i;Area[i]=i; while(j&lt;n&amp;&amp;A[j+1]%d==A[i]%d)&#123;j++;Area[j]=i;&#125; i=j+1; &#125; til=1;T.Build(); while(hed&lt;n) &#123; hed++;H[A[hed]]++; while(H[A[hed]]&gt;1||Area[hed]!=Area[til])&#123;T.Delete(til);H[A[til]]--;til++;&#125; while(top1&gt;0&amp;&amp;A[hed]&lt;=A[stk1[top1]]) &#123; T.RangeUpdateMin(stk1[top1-1]+1,stk1[top1],A[hed]/d-A[stk1[top1]]/d); top1--; &#125; stk1[++top1]=hed; while(top2&gt;0&amp;&amp;A[hed]&gt;=A[stk2[top2]]) &#123; T.RangeUpdateMax(stk2[top2-1]+1,stk2[top2],A[hed]/d-A[stk2[top2]]/d); top2--; &#125; stk2[++top2]=hed; LL L=T.Query(hed+k); if(L&gt;=til&amp;&amp;hed-L+1&gt;ans)&#123;ans=hed-L+1;ansL=L;ansR=hed;&#125; &#125; printf("%d %d\n",ansL,ansR); return 0;&#125;]]></content>
      <categories>
        <category>单调栈</category>
      </categories>
      <tags>
        <tag>线段树</tag>
        <tag>单调栈</tag>
        <tag>等差序列</tag>
        <tag>同余</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「TJOI2010」分金币]]></title>
    <url>%2F2019%2F03%2F08%2F%E3%80%8CTJOI2010%E3%80%8D%E5%88%86%E9%87%91%E5%B8%81-Solution%2F</url>
    <content type="text"><![CDATA[又是一道模拟退火的题QwQ。 传送门洛谷P3878 题解感觉这样的题目还是比较套路的QwQ。 还是先考虑一个看起来比较靠谱的贪心，比如考虑按顺序遍历这些金币，如果当前两堆个数相等的话谁小就先丢到谁哪儿，否则就丢到个数少的一堆里。 此时决策的方案还是与遍历的顺序有关，所以上模拟退火确定一个最优的顺序，然后就好了QwQ。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;algorithm&gt;using namespace std;const int maxn=35;const double delta=0.998;int T,n,v[maxn],ans;inline int read()&#123; int ret=0,f=1;char ch=getchar(); while(ch&lt;'0'||ch&gt;'9')&#123;if(ch=='-')f=-f;ch=getchar();&#125; while(ch&gt;='0'&amp;&amp;ch&lt;='9')&#123;ret=ret*10+ch-'0';ch=getchar();&#125; return ret*f;&#125;inline int ABS(int x)&#123;return x&lt;0?-x:x;&#125;inline int Calc()&#123; int sum1=0,sum2=0,cnt1=0,cnt2=0; for(int i=1;i&lt;=n;i++) &#123; if(cnt1==cnt2) &#123; if(sum1&lt;sum2)&#123;sum1+=v[i];cnt1++;&#125; else&#123;sum2+=v[i];cnt2++;&#125; &#125; else &#123; if(cnt1&lt;cnt2)&#123;sum1+=v[i];cnt1++;&#125; else&#123;sum2+=v[i];cnt2++;&#125; &#125; &#125; return ABS(sum1-sum2);&#125;inline void SA(double T)&#123; while(T&gt;1e-12) &#123; int a=rand()%n+1,b=rand()%n+1; while(a==b)&#123;a=rand()%n+1;b=rand()%n+1;&#125; swap(v[a],v[b]); int now=Calc(); if(now&lt;ans) ans=now; else if(exp((ans-now)/T)&lt;(double)rand()/RAND_MAX) swap(v[a],v[b]); T*=delta; &#125;&#125;int main()&#123; srand(20030909); T=read(); while(T--) &#123; n=read(); for(int i=1;i&lt;=n;i++) v[i]=read(); ans=Calc(); if(n&gt;1) for(int i=1;i&lt;=15;i++) SA(19630217); printf("%d\n",ans); &#125; return 0;&#125;]]></content>
      <categories>
        <category>模拟退火</category>
      </categories>
      <tags>
        <tag>随机算法</tag>
        <tag>贪心</tag>
        <tag>模拟退火</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「HAOI2006」均分数据]]></title>
    <url>%2F2019%2F03%2F08%2F%E3%80%8CHAOI2006%E3%80%8D%E5%9D%87%E5%88%86%E6%95%B0%E6%8D%AE-Solution%2F</url>
    <content type="text"><![CDATA[今天是国际劳动妇女节，各位妇女们有没有去劳动啊QwQ？反正我没去 传送门洛谷P2503 BZOJ2428 题解数据范围好小啊，看起来像是状压DP或者搜索之类的。蒟蒻我选择了模拟退火+贪心。 先考虑贪心，我们从$1$到$n$遍历整个序列，每次就把当前的元素丢到加和最小的那一组里。 显然光光这样贪心是肯定不行的，但是这样得到的答案还是比较优的。考虑怎样改进。 不难发现，如果遍历序列的顺序会影响最后的答案，那么可以考虑直接random_shuffle，打乱个比如$10^5​$次的，很大概率上就能刷到最优解了。 但是总感觉直接random_shuffle不太靠谱啊（不过貌似也能AC），但是蒟蒻我选择了模拟退火，感觉起来会靠谱一些（其实到底是不是更靠谱我也不知道，但是我想练一下模拟退火，所以就这样写了）。 每次随机拎出来两个元素交换，然后再计算当前答案就可以了。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;const int maxn=25,maxm=10;const double delta=0.991;int n,m,A[maxn];double X[maxn],avg,ret,ans;inline double Calc() //计算当前答案&#123; ret=avg=0; memset(X,0,sizeof(X)); for(int i=1;i&lt;=n;i++) &#123; int mi=1; for(int j=1;j&lt;=m;j++) if(X[j]&lt;X[mi]) mi=j; X[mi]+=A[i]; &#125; for(int i=1;i&lt;=m;i++) avg+=X[i]; avg/=m; for(int i=1;i&lt;=m;i++) ret+=(X[i]-avg)*(X[i]-avg); return sqrt(ret/m);&#125;inline void SA(double T)&#123; while(T&gt;1e-12) &#123; int a=rand()%n+1,b=rand()%n+1; while(a==b)&#123;a=rand()%n+1;b=rand()%n+1;&#125;//rand出来两个是一样的概率挺大的，这样可以提升效率 swap(A[a],A[b]); double now=Calc(); if(now&lt;ans) ans=now; else if(exp((ans-now)/T)&lt;(double)rand()/RAND_MAX) swap(A[a],A[b]); T*=delta; &#125;&#125;int main()&#123; srand(20030909); //黄霖的生日，种子什么的选大佬的生日肯定不会错的 scanf("%d%d",&amp;n,&amp;m); for(int i=1;i&lt;=n;i++) scanf("%d",&amp;A[i]); sort(A+1,A+1+n); ans=Calc(); for(int i=1;i&lt;=100;i++) SA(19630217); //退火100次又不会WA并且还比较快，求稳的话可以多来几次 printf("%.2lf\n",ans); return 0;&#125;]]></content>
      <categories>
        <category>模拟退火</category>
      </categories>
      <tags>
        <tag>随机算法</tag>
        <tag>贪心</tag>
        <tag>模拟退火</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「HNOI2008」遥远的行星]]></title>
    <url>%2F2019%2F03%2F07%2F%E3%80%8CHNOI2008%E3%80%8D%E9%81%A5%E8%BF%9C%E7%9A%84%E8%A1%8C%E6%98%9F-Solution%2F</url>
    <content type="text"><![CDATA[又是一道玄学的题目QwQ。 传送门洛谷P3198 BZOJ1011 题解首先要一眼看到这题的重点：结果的相对误差不超过$5\%$即可。 所以考虑非完美算法。 首先，对于第$i​$个行星，对它有贡献的星球区间是$[1,\lfloor A\cdot i\rfloor]​$。设$R=\lfloor A\cdot i\rfloor​$。 然后再设一个阈值$S$比如$S=n^{0.4}$。 接下来的操作类似于分块，把区间$[1,R]$分成若干个块，每个块的大小为$S$，剩下的零头暴力搞，对于每一个完整的块，设这个块为$[a,b]$，那么这个块的贡献约等于 \frac{M[i]\cdot\sum_{j=a}^{b}M[j]}{i-\frac{a+b}{2}}这个式子可以构造前缀和来求。 把所有块的贡献加起来，注意下细节，就能过了QwQ。 代码12345678910111213141516171819202122232425262728#include&lt;cmath&gt;#include&lt;cstdio&gt;using namespace std;typedef long long LL;const int maxn=100005;int n,S,M[maxn];double A,ans;LL sum[maxn];inline int read()&#123; int ret=0,f=1;char ch=getchar(); while(ch&lt;'0'||ch&gt;'9')&#123;if(ch=='-')f=-f;ch=getchar();&#125; while(ch&gt;='0'&amp;&amp;ch&lt;='9')&#123;ret=ret*10+ch-'0';ch=getchar();&#125; return ret*f;&#125;int main()&#123; n=read();scanf("%lf",&amp;A);S=pow(n,0.38)+1e-10; for(int i=1;i&lt;=n;i++)&#123;M[i]=read();sum[i]=sum[i-1]+M[i];&#125; //构造前缀和 for(int i=1;i&lt;=n;i++) &#123; int R=i*A+1e-10,j;ans=0; //加上1e-10是为了防止精度损失 for(j=1;j+S&lt;=R;j+=S) //处理整块 ans+=(double)M[i]*(sum[j+S-1]-sum[j-1])/(i-(double)(2*j+S-1)/2); for(;j&lt;=R;j++) //处理零头 ans+=(double)M[i]*M[j]/(i-j); printf("%lf\n",ans); &#125; return 0;&#125;]]></content>
      <categories>
        <category>分块</category>
      </categories>
      <tags>
        <tag>分块</tag>
        <tag>概率</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「USACO」Haywire]]></title>
    <url>%2F2019%2F03%2F07%2F%E3%80%8CUSACO%E3%80%8DHaywire-Solution%2F</url>
    <content type="text"><![CDATA[什么神仙题目。蒟蒻我前前后后一共交了13次，才终于把这个退火搞懂了QwQ。 传送门洛谷P2210 题解蒟蒻我之前一直对模拟退火保持一个懵逼状态，今天是差不多把大概原理终于理清楚了QwQ。 其实基本上就是个退火的板子，但是蒟蒻我一直搞不清楚计算接受较差答案的概率。 一般来说，计算改成的式子是这样的： exp((now-ans)/T)&gt;rand()/RAND_MAX 其中now表示当前的答案，ans表示已知最优答案，也有可能是ans-now，总之应该是个负数。满足上式，则接受较差的答案。 其中$exp(x)$表示$e^x$，函数图像大概是这样的： 所以与当前最优答案差距越大，温度越低，$exp()$的值就越小，接受这个较差的答案的概率就越小。 还有，调参的时候，降温系数，停止退火的温度下限，温度初始值，退火的次数要一起调，尤其是退火的次数，多退几次还是很有必要的。种子可以用神仙学长ZZK的生日20020222。 代码1234567891011121314151617181920212223242526272829303132333435363738394041#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;algorithm&gt;using namespace std;const double delta=0.99;int n,fri[20][5],Q[20],ans;inline int Calc()&#123; int ret=0; for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=3;j++) if(Q[i]&gt;Q[fri[i][j]]) ret+=Q[i]-Q[fri[i][j]]; return ret;&#125;inline void SA(double T)&#123; while(T&gt;1e-12) &#123; int a=rand()%n+1,b=rand()%n+1; while(a==b)&#123;a=rand()%n+1;b=rand()%n+1;&#125; swap(Q[a],Q[b]); int now=Calc(); if(now&lt;ans) ans=now; else if(exp((ans-now)/T)&lt;(double)rand()/RAND_MAX) swap(Q[a],Q[b]); T*=delta; &#125;&#125;int main()&#123; srand(19260817); scanf("%d",&amp;n); for(int i=1;i&lt;=n;i++) scanf("%d%d%d",&amp;fri[i][1],&amp;fri[i][2],&amp;fri[i][3]); for(int i=1;i&lt;=n;i++) Q[i]=i; ans=Calc(); for(int i=1;i&lt;=500;i++) SA(19260817); printf("%d\n",ans); return 0;&#125;]]></content>
      <categories>
        <category>模拟退火</category>
      </categories>
      <tags>
        <tag>随机算法</tag>
        <tag>模拟退火</tag>
        <tag>搜索</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「YNOI2016」这是我自己的发明]]></title>
    <url>%2F2019%2F03%2F06%2F%E3%80%8CYNOI2016%E3%80%8D%E8%BF%99%E6%98%AF%E6%88%91%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8F%91%E6%98%8E-Solution%2F</url>
    <content type="text"><![CDATA[震惊！我妻由乃当上了发明家！！！ 传送门洛谷P4689 BZOJ4940 题解又是一道由乃OI的毒瘤题QwQ。 前置技能，这题的简化版：SNOI2017 一个简单的询问。 做完上面一题，不难发现，只要爬到树上做这题就行了。 先一巴掌把树拍扁按照DFS序将树化成一个序列，这样每一颗子树对应着序列上的一段区间，然后就和之前那一题没什么区别了。 但是！！！竟然有换根这种操作。 不过不难发现，其实换根的操作就是假的。 先设当前的根为$rt$，询问子树的节点为$x$，不管怎样，我们就认为根始终是节点$1$。 然后又这么几种情况： $x=rt​$ 此时询问的就是整棵树。 $LCA(x,rt)\neq x$ 此时查询的就是当$1$为根时$x$的子树。 $LCA(x,rt)=x​$ 此时查询整棵树除去rt到x路径上离x最近的一个节点（就是图中好几个箭头指的那个点）的子树。可以拆成两个序列解决。那个节点可以通过倍增找到。 拆分成若干个序列之后，直接莫队即可。 还有记得要离散，权值是比较大的。我就因为没看数据范围，忘记离散，结果崩掉1个点QwQ 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798#include&lt;map&gt;#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;typedef long long LL;const int maxn=100005,maxm=500005;int n,m,q,rt,idx,tot,lnk[maxn],son[maxn*2],nxt[maxn*2],St[maxn],En[maxn],father[maxn][20],dep[maxn],A[maxn],B[maxn],S,Area[maxn],num,cnt1[maxn],cnt2[maxn],p1,p2;LL ans[maxm],now; //要开的东西实在太多，写的好丑QwQmap&lt;int,int&gt; hsh;inline int read()&#123; int ret=0,f=1;char ch=getchar(); while(ch&lt;'0'||ch&gt;'9')&#123;if(ch=='-')f=-f;ch=getchar();&#125; while(ch&gt;='0'&amp;&amp;ch&lt;='9')&#123;ret=ret*10+ch-'0';ch=getchar();&#125; return ret*f;&#125;inline void add_e(int x,int y)&#123;tot++;son[tot]=y;nxt[tot]=lnk[x];lnk[x]=tot;&#125;void Build(int now,int fa) //以节点1作为根节点初始化&#123; father[now][0]=fa;dep[now]=dep[fa]+1;idx++;A[idx]=B[now];St[now]=idx; for(int i=1;i&lt;=16;i++) father[now][i]=father[father[now][i-1]][i-1]; for(int i=lnk[now];i;i=nxt[i]) if(son[i]!=fa) Build(son[i],now); En[now]=idx;&#125;int LCA(int u,int v) //倍增LCA&#123; if(dep[u]&lt;dep[v]) swap(u,v); for(int i=16;i&gt;=0;i--) if(dep[father[u][i]]&gt;=dep[v]) u=father[u][i]; for(int i=16;i&gt;=0;i--) if(father[u][i]!=father[v][i])&#123;u=father[u][i];v=father[v][i];&#125; if(u!=v) return father[u][0]; return u;&#125;int GetSon(int u,int v)&#123; if(dep[u]&lt;dep[v]) swap(u,v); for(int i=16;i&gt;=0;i--) if(dep[father[u][i]]&gt;dep[v]) u=father[u][i]; return u;&#125;struct Interval&#123; int R1,R2,f,id; void Init()&#123;if(R1&gt;R2)swap(R1,R2);&#125; bool operator &lt; (const Interval&amp; b)const&#123;return Area[R1]&lt;Area[b.R1]||(Area[R1]==Area[b.R1]&amp;&amp;((Area[R1]&amp;1)?R2&lt;b.R2:R2&gt;b.R2));&#125;&#125;Q[maxm*16]; //注意一个询问最左可以拆成16个区间inline void Add(int L1,int R1,int L2,int R2,int id)&#123; num++;Q[num].R1=R1;Q[num].R2=R2;Q[num].f=1;Q[num].Init();Q[num].id=id; if(L1&gt;1)&#123;num++;Q[num].R1=L1-1;Q[num].R2=R2;Q[num].f=-1;Q[num].Init();Q[num].id=id;&#125; if(L2&gt;1)&#123;num++;Q[num].R1=R1;Q[num].R2=L2-1;Q[num].f=-1;Q[num].Init();Q[num].id=id;&#125; if(L1&gt;1&amp;&amp;L2&gt;1)&#123;num++;Q[num].R1=L1-1;Q[num].R2=L2-1;Q[num].f=1;Q[num].Init();Q[num].id=id;&#125;&#125;int main()&#123; n=read();m=read();S=sqrt(n)+1e-10;rt=1; for(int i=1;i&lt;=n;i++) A[i]=B[i]=read(); sort(B+1,B+1+n);int tep=0; for(int i=1;i&lt;=n;i++) if(!hsh[B[i]]) hsh[B[i]]=++tep; for(int i=1;i&lt;=n;i++) B[i]=hsh[A[i]]; //离散 for(int i=1;i&lt;=n;i++) Area[i]=(i-1)/S+1; for(int i=1;i&lt;n;i++) &#123; int a=read(),b=read(); add_e(a,b);add_e(b,a); &#125; Build(1,0); for(int i=1;i&lt;=m;i++) &#123; if(read()==1) rt=read(); else &#123; int x=read(),y=read();q++; int len1=0,L1[3],R1[3],len2=0,L2[3],R2[3]; if(x==rt)&#123;len1++;L1[len1]=1;R1[len1]=n;&#125; else if(LCA(x,rt)!=x)&#123;len1++;L1[len1]=St[x];R1[len1]=En[x];&#125; else&#123;int v=GetSon(rt,x);len1++;L1[len1]=1;R1[len1]=St[v]-1;if(En[v]&lt;n)&#123;len1++;L1[len1]=En[v]+1;R1[len1]=n;&#125;&#125; if(y==rt)&#123;len2++;L2[len2]=1;R2[len2]=n;&#125; else if(LCA(y,rt)!=y)&#123;len2++;L2[len2]=St[y];R2[len2]=En[y];&#125; else&#123;int v=GetSon(rt,y);len2++;L2[len2]=1;R2[len2]=St[v]-1;if(En[v]&lt;n)&#123;len2++;L2[len2]=En[v]+1;R2[len2]=n;&#125;&#125; for(int j=1;j&lt;=len1;j++) for(int k=1;k&lt;=len2;k++) Add(L1[j],R1[j],L2[k],R2[k],q); //拆成区间上莫队 &#125; &#125; sort(Q+1,Q+1+num); //莫队 for(int i=1;i&lt;=num;i++) &#123; while(p2&lt;Q[i].R2)&#123;p2++;cnt2[A[p2]]++;now+=cnt1[A[p2]];&#125; while(p1&gt;Q[i].R1)&#123;cnt1[A[p1]]--;now-=cnt2[A[p1]];p1--;&#125; while(p2&gt;Q[i].R2)&#123;cnt2[A[p2]]--;now-=cnt1[A[p2]];p2--;&#125; while(p1&lt;Q[i].R1)&#123;p1++;cnt1[A[p1]]++;now+=cnt2[A[p1]];&#125; ans[Q[i].id]+=now*Q[i].f; &#125; for(int i=1;i&lt;=q;i++) printf("%lld\n",ans[i]); return 0;&#125;]]></content>
      <categories>
        <category>莫队</category>
      </categories>
      <tags>
        <tag>莫队</tag>
        <tag>LCA</tag>
        <tag>DFS序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「洛谷P4886」快递员]]></title>
    <url>%2F2019%2F03%2F05%2F%E3%80%8C%E6%B4%9B%E8%B0%B7P4886%E3%80%8D%E5%BF%AB%E9%80%92%E5%91%98-Solution%2F</url>
    <content type="text"><![CDATA[完了…没高中读了QwQ，我要去打工送快递！！！QwQ 传送门洛谷P4886 题解这题其实还是挺好玩的。 首先随便钦定一个点，临时作为快递中心 。 然后可以$O(n)$计算出每一组点对到快递中心的距离和。设点对到快递中心最大距离和为$Max$，可能有多个点对到快递中心的距离和都是$Max$那么就把它们都存下来。 如果当前的快递中心在任意一组距离最大的点对之间最短路径上，那么答案就是$Max$不可能再小了。 如果有任意两组点对，一组在当前快递中心的一棵子树里，另一组在另一棵子树里，那么答案同样也无法更小。 否则答案最优时的快递中心就有可能在当前唯一一棵有点对的子树中，那么就取这棵子树的重心作为临时快递中心，然后递归。由于每次取的都是重心，所以只会递归$\log n$层，总时间复杂度为$O(n\log n)​$。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include&lt;cstdio&gt;#include&lt;cstdlib&gt;using namespace std;const int maxn=100005;int n,m,u[maxn],v[maxn],tot,lnk[maxn],son[maxn*2],w[maxn*2],nxt[maxn*2],sum,siz[maxn],maxp[maxn],rt,sub[maxn],dist[maxn],que[maxn],ans=1000000000;bool vis[maxn];inline int read()&#123; int ret=0,f=1;char ch=getchar(); while(ch&lt;'0'||ch&gt;'9')&#123;if(ch=='-')f=-f;ch=getchar();&#125; while(ch&gt;='0'&amp;&amp;ch&lt;='9')&#123;ret=ret*10+ch-'0';ch=getchar();&#125; return ret*f;&#125;inline void add_e(int x,int y,int z)&#123;tot++;son[tot]=y;w[tot]=z;nxt[tot]=lnk[x];lnk[x]=tot;&#125;void GetRoot(int now,int fa) //找重心&#123; siz[now]=1;maxp[now]=0; for(int i=lnk[now];i;i=nxt[i]) &#123; if(vis[son[i]]||son[i]==fa) continue; GetRoot(son[i],now);siz[now]+=siz[son[i]]; if(siz[son[i]]&gt;maxp[now]) maxp[now]=siz[son[i]]; &#125; if(sum-siz[now]&gt;maxp[now]) maxp[now]=sum-siz[now]; if(maxp[now]&lt;maxp[rt]) rt=now;&#125;void GetDist(int now,int fa,int st)&#123; sub[now]=st; for(int i=lnk[now];i;i=nxt[i]) if(son[i]!=fa) &#123;dist[son[i]]=dist[now]+w[i];GetDist(son[i],now,st);&#125;&#125;inline void Print()&#123;printf("%d\n",ans);exit(0);&#125; //输出答案void Solve(int now)&#123; if(vis[now]) Print(); vis[now]=true;dist[now]=0; for(int i=lnk[now];i;i=nxt[i]) &#123;dist[son[i]]=w[i];GetDist(son[i],now,son[i]);&#125; //先暴力计算距离 int Max=0,len=0,las=0; for(int i=1;i&lt;=m;i++) &#123; if(dist[u[i]]+dist[v[i]]&gt;Max)&#123;len=1;que[len]=i;Max=dist[u[i]]+dist[v[i]];&#125; else if(dist[u[i]]+dist[v[i]]==Max) que[++len]=i; //刷最大距离和 &#125; if(Max&lt;ans) ans=Max; for(int i=1;i&lt;=len;i++) &#123; if(sub[u[que[i]]]!=sub[v[que[i]]]) Print(); //分情况考虑答案 if(!las) las=sub[u[que[i]]]; if(sub[u[que[i]]]!=las) Print(); &#125; rt=0;sum=siz[las];GetRoot(las,0);Solve(rt); //递归解决&#125;int main()&#123; n=read();m=read(); for(int i=1;i&lt;n;i++) &#123; int a=read(),b=read(),c=read(); add_e(a,b,c);add_e(b,a,c); &#125; for(int i=1;i&lt;=m;i++)&#123;u[i]=read();v[i]=read();&#125; sum=maxp[0]=n;GetRoot(1,0);Solve(rt); Print(); return 0;&#125;]]></content>
      <categories>
        <category>点分治</category>
      </categories>
      <tags>
        <tag>点分治</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「IOI2011」Race]]></title>
    <url>%2F2019%2F03%2F05%2F%E3%80%8CIOI2011%E3%80%8DRace-Solution%2F</url>
    <content type="text"><![CDATA[又是一个赤裸裸的点分治QwQ。 传送门洛谷P4149 BZOJ2599 题解基本上就是点分治的裸题QwQ。 每次找重心，然后刷出当前处理的子树中每个点到重心的距离和经过的边的数量，直接搞就行了，记得要刷边数的最小值，还要判无解。没啥好说的QwQ。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include&lt;cstdio&gt;#include&lt;cstring&gt;using namespace std;const int maxn=200005,maxk=1000005,inf=0x3F3F3F3F;int n,K,tot,lnk[maxn],son[maxn*2],w[maxn*2],nxt[maxn*2],sum,siz[maxn],maxp[maxn],rt,dist[maxn],cnt[maxn],num,Q[maxn][2],ans=inf,jud[maxk],que[maxn];bool vis[maxn];inline int read()&#123; int ret=0,f=1;char ch=getchar(); while(ch&lt;'0'||ch&gt;'9')&#123;if(ch=='-')f=-f;ch=getchar();&#125; while(ch&gt;='0'&amp;&amp;ch&lt;='9')&#123;ret=ret*10+ch-'0';ch=getchar();&#125; return ret*f;&#125;inline void add_e(int x,int y,int z)&#123;tot++;son[tot]=y;w[tot]=z;nxt[tot]=lnk[x];lnk[x]=tot;&#125;void GetRoot(int now,int fa)&#123; siz[now]=1;maxp[now]=0; for(int i=lnk[now];i;i=nxt[i]) &#123; if(vis[son[i]]||son[i]==fa) continue; GetRoot(son[i],now);siz[now]+=siz[son[i]]; if(siz[son[i]]&gt;maxp[now]) maxp[now]=siz[son[i]]; &#125; if(sum-siz[now]&gt;maxp[now]) maxp[now]=sum-siz[now]; if(maxp[now]&lt;maxp[rt]) rt=now;&#125;void GetDist(int now,int fa)&#123; if(dist[now]&gt;K||cnt[now]&gt;ans) return; num++;Q[num][0]=dist[now];Q[num][1]=cnt[now]; for(int i=lnk[now];i;i=nxt[i]) if(!vis[son[i]]&amp;&amp;son[i]!=fa) &#123;dist[son[i]]=dist[now]+w[i];cnt[son[i]]=cnt[now]+1;GetDist(son[i],now);&#125;&#125;void Solve(int now)&#123; int len=1;que[1]=0;vis[now]=true;jud[0]=0; for(int i=lnk[now];i;i=nxt[i]) &#123; if(vis[son[i]]) continue; num=0;dist[son[i]]=w[i];cnt[son[i]]=1;GetDist(son[i],0); for(int j=1;j&lt;=num;j++) if(Q[j][1]+jud[K-Q[j][0]]&lt;ans) ans=Q[j][1]+jud[K-Q[j][0]]; for(int j=1;j&lt;=num;j++) &#123; if(Q[j][1]&lt;jud[Q[j][0]]) jud[Q[j][0]]=Q[j][1]; que[++len]=Q[j][0]; &#125; &#125; for(int i=1;i&lt;=len;i++) jud[que[i]]=inf; for(int i=lnk[now];i;i=nxt[i]) if(!vis[son[i]]) &#123;sum=siz[son[i]];rt=0;GetRoot(son[i],0);Solve(rt);&#125;&#125;int main()&#123; n=read();K=read(); for(int i=1;i&lt;n;i++) &#123; int a=read()+1,b=read()+1,c=read(); add_e(a,b,c);add_e(b,a,c); &#125; memset(jud,63,sizeof(jud)); maxp[0]=sum=n;GetRoot(1,0);Solve(rt); printf("%d\n",ans==inf?-1:ans); return 0;&#125;]]></content>
      <categories>
        <category>点分治</category>
      </categories>
      <tags>
        <tag>点分治</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「SNOI2017」一个简单的询问]]></title>
    <url>%2F2019%2F03%2F04%2F%E3%80%8CSNOI2017%E3%80%8D%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E8%AF%A2%E9%97%AE-Solution%2F</url>
    <content type="text"><![CDATA[嗯哼？这不是赤裸裸的莫队吗QwQ？ 传送门BZOJ5016 题解首先拐一道弯，令$F(L1,R1,L2,R2)=\sum_{x=0}^{\infty}{get(L1,R1,x)\cdot get(L2,R2,x)}​$。 那么根据容斥的原理，可以得到$F(L1,R1,L2,R2)=F(1,R1,1,R2)-F(1,L1,1,R2)-F(1,R1,1,L2)+F(1,L1,1,L2)$。 那么就把一个询问先拆成四个询问。 然后只要想办法求出$F(1,x,1,y)$。裸的莫队啊啊啊！！！注意细节即可。 然后就没有然后了。 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;typedef long long LL;const int maxn=50005;int n,q,A[maxn],S,Area[maxn],tot,cnt1[maxn],cnt2[maxn],p1,p2;LL ans[maxn],now;inline int read()&#123; int ret=0,f=1;char ch=getchar(); while(ch&lt;'0'||ch&gt;'9')&#123;if(ch=='-')f=-f;ch=getchar();&#125; while(ch&gt;='0'&amp;&amp;ch&lt;='9')&#123;ret=ret*10+ch-'0';ch=getchar();&#125; return ret*f;&#125;struct Interval&#123; int R1,R2,f,id; void Init()&#123;if(R1&gt;R2)swap(R1,R2);&#125; bool operator &lt; (const Interval&amp; b)const&#123;return Area[R1]&lt;Area[b.R1]||(Area[R1]==Area[b.R1]&amp;&amp;((Area[R1]&amp;1)?R2&lt;b.R2:R2&gt;b.R2));&#125;&#125;Q[maxn*4];int main()&#123; n=read();S=sqrt(n)+1e-10; for(int i=1;i&lt;=n;i++) A[i]=read(); for(int i=1;i&lt;=n;i++) Area[i]=(i-1)/S+1; q=read(); for(int i=1;i&lt;=q;i++) &#123; int L1=read(),R1=read(),L2=read(),R2=read(); tot++;Q[tot].R1=R1;Q[tot].R2=R2;Q[tot].f=1;Q[tot].Init();Q[tot].id=i; tot++;Q[tot].R1=L1-1;Q[tot].R2=R2;Q[tot].f=-1;Q[tot].Init();Q[tot].id=i; tot++;Q[tot].R1=R1;Q[tot].R2=L2-1;Q[tot].f=-1;Q[tot].Init();Q[tot].id=i; tot++;Q[tot].R1=L1-1;Q[tot].R2=L2-1;Q[tot].f=1;Q[tot].Init();Q[tot].id=i; &#125; sort(Q+1,Q+1+tot); for(int i=1;i&lt;=tot;i++) &#123; while(p2&lt;Q[i].R2)&#123;p2++;cnt2[A[p2]]++;now+=cnt1[A[p2]];&#125; while(p1&gt;Q[i].R1)&#123;cnt1[A[p1]]--;now-=cnt2[A[p1]];p1--;&#125; while(p2&gt;Q[i].R2)&#123;cnt2[A[p2]]--;now-=cnt1[A[p2]];p2--;&#125; while(p1&lt;Q[i].R1)&#123;p1++;cnt1[A[p1]]++;now+=cnt2[A[p1]];&#125; ans[Q[i].id]+=now*Q[i].f; &#125; for(int i=1;i&lt;=q;i++) printf("%lld\n",ans[i]); return 0;&#125;]]></content>
      <categories>
        <category>莫队</category>
      </categories>
      <tags>
        <tag>莫队</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「ZJOI2019模拟赛 十二」紫苑]]></title>
    <url>%2F2019%2F03%2F04%2F%E3%80%8CZJOI2019%E6%A8%A1%E6%8B%9F%E8%B5%9B%20%E5%8D%81%E4%BA%8C%E3%80%8D%E7%B4%AB%E8%8B%91-Solution%2F</url>
    <content type="text"><![CDATA[震惊！XZY竟然在ZJOI模拟赛时公然写代码造数据卡掉各种排序算法… 传送门原题来自UOJ，但各个子任务的分值略有不同。 UOJ83 题解这题是真的毒瘤QwQ。 Subtask #1观察一下计数排序法的代码，发现它在排序开始之前先把数组从$0$到$max(A_i)$清了一遍，那么只要给一个数，并且足够大即可。简直就是送分。 Subtask #2从第二个子任务开始，题目渐渐地毒瘤了起来。 首先你需要知道对于冒泡排序法，交换元素的次数等于逆序对的个数。 然后仔细分析代码，计算出冒泡排序法和计数排序法的具体复杂度，然后发现，只要构造一个长度为$1990​$的升序排列，然后选出$521​$对元素两两交换即可。此时冒泡刚好不会T，选排刚好T掉。 Subtask #3继续分析代码。发现快排没有随机化，那么就让每次选的基准数都是整个序列的最大或者最小值，然后手动二分得到$n​$的值应该为$1984​$。 Subtask #4对于冒泡排序法来说，一个降序的排列逆序对数最多，最容易T，但是对计数排序法就很不友好了。 然后再随便写几个数列试试看，发现类似于这样的序列很不错：2 2 2 1 1 1 0 0 0，手动多试几次值域和每个值出现的次数，就把这个点搞掉了。 Subtask #5和子任务4一样是要卡冒泡，同样构造一个类似的序列，然后手动胡乱修改几个数的出现次数，然后就过了。（大雾 Subtask #6woc最恶心的一个点，一定要好好分析一下随机排序法的代码。 首先发现随机函数是手写的，想到这里应该有玄机，赶紧仔细看看。 发现seed、RNG_a、RNG_b的初值都是一个奇怪的数字，在10进制下看不出啥玩意，打开计算器，转到二进制下看看。 然后发现RNG_a在二进制下是$1100101101010000000000001$，RNG_b是$100110100100000000000001$，后面都有一长串$0$和一个$1$。并且打乱数组时都是取随机值然后模$n$，然后想到如果$n$是$2$的正整数次幂的话就会有一些奇妙的性质：上面两个数字在模$n$意义下都等于$1​$。 考虑到最好应该让该程序打乱一遍数组就排序好，并且题目中时间上限给的十分准确，枚举$n$，发现$n=4096$时计时器的值刚好是$43026$，由此根据出题人心理学套路断定$n$一定等于$4096$。 然后再仔细观察，发现如果seed是一个确定的值，原序列各元素之间的大小关系可以确定。于是乎再枚举seed，发现$seed=2048$（模$n$的意义下）时倒推得到的原序列使得快排T掉了。可得$seed=2048$。 但是由于seed是一个根据输入序列生成的值，所以在确定原序列各元素之间的大小关系的情况下，关键在于如何构造一个合法的序列使得$seed=2048$。 所以可以先构造一个各元素值都尽量小的排列$A$，然后将所有大于$A[n]$的元素的值都加上个比如$10^6$，然后就可枚举$A[n]$，一点点把它的值变大，直到$seed=2048$。这样最后一个点就构造好了。 然后恭喜你获得荣誉勋章：毒瘤出题人。 代码Subtask #11//没有QwQ，手造 Subtask #21234567891011121314#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;int n,A[2000];int main()&#123; n=1990; printf("%d\n",n); for(int i=1;i&lt;=n;i++) A[i]=i; for(int i=1;i&lt;=521;i++) swap(A[i*2],A[i*2-1]); for(int i=1;i&lt;=n;i++) printf("%d%c",A[i],i==n?'\n':' '); return 0;&#125; Subtask #3123456789101112131415161718#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;int n,A[5000],counter;int main()&#123; n=1984; printf("%d\n",n); for(int i=1;i&lt;=n;i++) A[i]=i; for(int i=1;i&lt;=n;i++) &#123; int j=(i+1)/2; swap(A[i],A[j]); &#125; for(int i=1;i&lt;=n;i++) printf("%d%c",A[i],i==n?'\n':' '); return 0;&#125; Subtask #4其实后面少了几个0，可以手动补上，不补也没关系。 12345678910#include&lt;cstdio&gt;using namespace std;int main()&#123; printf("%d\n",1012); for(int i=30;i&gt;=0;i--) for(int j=1;j&lt;=32;j++) printf("%d ",i); return 0;&#125; Subtask #5用这个代码生成数据后还有手动乱搞一下QwQ。 12345678910#include&lt;cstdio&gt;using namespace std;int main()&#123; printf("%d\n",1015); for(int i=27;i&gt;=0;i--) for(int j=1;j&lt;=40;j++) printf("%d ",i); return 0;&#125; Subtask #612345678910111213141516171819202122232425262728293031323334#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;int n,A[5000],counter;unsigned int seed,RNG_a,RNG_b;void RNG_init()&#123; counter++; seed = 2166136261u; counter++; RNG_a = 26648577u; counter++; RNG_b = 10108929u;&#125;int main()&#123; freopen("Shion.in","wb",stdout); n=4096;seed=2166136261u; printf("%d\n",n); for(int i=1;i&lt;=n;i++) A[i]=i; for(int i=n;i;i--) &#123; int j=(i+2048)%4096+1; swap(A[i],A[j]); &#125; for(int i=1;i&lt;=n;i++) if(A[i]&gt;A[n]) A[i]+=1000000; for(int i=1;i&lt;n;i++) seed=(seed*16777619u)^A[i]; while(((seed*16777619u)^A[n])%(unsigned int)4096!=(unsigned int)2048) A[n]++; for(int i=1;i&lt;=n;i++) printf("%d%c",A[i],i==n?'\n':' '); return 0;&#125; 答案戳我呀^w^ 终于写完了QwQ，出题人真是毒瘤QwQ。]]></content>
      <categories>
        <category>分析代码</category>
      </categories>
      <tags>
        <tag>非传统题</tag>
        <tag>提交答案题</tag>
        <tag>排序</tag>
        <tag>分析代码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「AHOI2001」多项式乘法]]></title>
    <url>%2F2019%2F03%2F04%2F%E3%80%8CAHOI2001%E3%80%8D%E5%A4%9A%E9%A1%B9%E5%BC%8F%E4%B9%98%E6%B3%95-Solution%2F</url>
    <content type="text"><![CDATA[来水一发大模拟QwQ。 传送门洛谷P2553 题解好久没写这种处理字符串的大模拟了QwQ。 这题每个多项式的长度都很短，系数也很小，所以直接$O(n^2)$的暴力搞过去就行了。 数据范围大一点的话FFT即可。 注意可能有空格。 注意可能在一行中可能包含一个不完整的表达式（可能没有”*”或者”()”），注意应该什么也不要输出，也要注意不要RE或者怎么样了。 总而言之还是挺好写的QwQ。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include&lt;cstdio&gt;#include&lt;cstring&gt;using namespace std;int len,a1[50],a2[50],ans[100];char exp[1000];int main()&#123; while(gets(exp),exp[0]) &#123; len=strlen(exp);memset(a1,0,sizeof(a1));memset(a2,0,sizeof(a2));memset(ans,0,sizeof(ans)); int i=1; while(exp[i]!=')'&amp;&amp;i&lt;len) &#123; int x=0,z=0; while(exp[i]&lt;'0'||exp[i]&gt;'9') i++; x=exp[i]-'0'; if('0'&lt;=exp[i+1]&amp;&amp;exp[i+1]&lt;='9')&#123;i++;x=x*10+exp[i]-'0';&#125; i++; if(exp[i]=='a') &#123; i++;i++;z=exp[i]-'0'; if('0'&lt;=exp[i+1]&amp;&amp;exp[i+1]&lt;='9')&#123;i++;z=z*10+exp[i]-'0';&#125; i++; &#125; a1[z]+=x; &#125; i++; while(exp[i]!=')'&amp;&amp;i&lt;len) &#123; int x=0,z=0; while(exp[i]&lt;'0'||exp[i]&gt;'9') i++; x=exp[i]-'0'; if('0'&lt;=exp[i+1]&amp;&amp;exp[i+1]&lt;='9')&#123;i++;x=x*10+exp[i]-'0';&#125; i++; if(exp[i]=='a') &#123; i++;i++;z=exp[i]-'0'; if('0'&lt;=exp[i+1]&amp;&amp;exp[i+1]&lt;='9')&#123;i++;z=z*10+exp[i]-'0';&#125; i++; &#125; a2[z]+=x; &#125; for(int i=0;i&lt;=30;i++) for(int j=0;j&lt;=30;j++) ans[i+j]+=a1[i]*a2[j]; bool first=false; for(int j=60;j&gt;=0;j--) &#123; if(!ans[j]) continue; if(first) putchar('+'); else first=true; if(j&gt;0) printf("%da^%d",ans[j],j); else printf("%d",ans[j]); &#125; putchar('\n'); memset(exp,0,sizeof(exp)); &#125; return 0;&#125;]]></content>
      <categories>
        <category>模拟</category>
      </categories>
      <tags>
        <tag>多项式乘法</tag>
        <tag>FFT</tag>
        <tag>模拟</tag>
        <tag>字符串处理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「YNOI2016」掉进兔子洞]]></title>
    <url>%2F2019%2F02%2F25%2F%E3%80%8CYNOI2016%E3%80%8D%E6%8E%89%E8%BF%9B%E5%85%94%E5%AD%90%E6%B4%9E-Solution%2F</url>
    <content type="text"><![CDATA[震惊！我妻由乃掉进了兔子洞里… 传送门洛谷P4688 BZOJ4939 题解这题再YNOI里应该算简单的吧，毕竟代码挺短的。 根据题意，要求的答案就是三个区间的长度和减去三个区间的交集长度的三倍。 因为要求交集，自然而然想到用bitset。只要上莫队求出每个询问的三个区间的bitset，求交集即可。 但是这个交集还不是那么好求，要拐个弯QwQ。 先对原序列进行离散化，定义离散化之后的$A_i$表示原序列中有多少个数小于原$A_i$。 然后考虑一个区间，现在加入一个元素，怎么维护bitset。由于存在相同元素，所以bitset上可能有好多位都是留给与当前元素相同的元素的，那么就需要从第$A_i$个位置从左往右找到第一个空位把新元素按上去，这样进行&amp;运算的时候就没有问题了，找位置的时候事先记一下当前区间每个值已经出现多少次了，就能O(1)找到。 这样进行&amp;运算就没有什么问题了。 还有就是由于直接开$10^5$个长度为$10^5$的bitset会MLE，所以把所有询问分三次处理就好了。 感觉莫队+bitset的题常数都不小，蒟蒻我一般不吸氧过不了QwQ。 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include&lt;map&gt;#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;bitset&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;const int maxn=100005,maxm=34005;int n,tot,m,A[maxn],B[maxn],sum,S,Area[maxn],ans[maxn],cnt[maxn];map&lt;int,int&gt; C;bitset&lt;maxn&gt; col[maxm],tep;bool vis[maxm];inline int read()&#123; int ret=0,f=1;char ch=getchar(); while(ch&lt;'0'||ch&gt;'9')&#123;if(ch=='-')f=-f;ch=getchar();&#125; while(ch&gt;='0'&amp;&amp;ch&lt;='9')&#123;ret=ret*10+ch-'0';ch=getchar();&#125; return ret*f;&#125;struct Interval&#123; int L,R,id; bool operator &lt; (const Interval&amp; b)const&#123;return Area[L]&lt;Area[b.L]||(Area[L]==Area[b.L]&amp;&amp;((Area[L]&amp;1)?Area[R]&lt;Area[b.R]:Area[R]&gt;Area[b.R]));&#125;&#125;Q[maxm*3];inline void inc(int x)&#123;tep[x+cnt[x]]=1;cnt[x]++;&#125;inline void dec(int x)&#123;cnt[x]--;tep[x+cnt[x]]=0;&#125;inline void Solve()&#123; int num=0,L=1,R=1;tep[A[1]]=1;cnt[A[1]]++; for(int i=1;i&lt;=m&amp;&amp;i&lt;=34000;i++) &#123; num++;Q[num].L=read();Q[num].R=read();Q[num].id=i;ans[i]+=Q[num].R-Q[num].L+1; num++;Q[num].L=read();Q[num].R=read();Q[num].id=i;ans[i]+=Q[num].R-Q[num].L+1; num++;Q[num].L=read();Q[num].R=read();Q[num].id=i;ans[i]+=Q[num].R-Q[num].L+1; &#125; sort(Q+1,Q+1+num); for(int i=1;i&lt;=num;i++) &#123; while(L&gt;Q[i].L) inc(A[--L]); while(R&lt;Q[i].R) inc(A[++R]); while(L&lt;Q[i].L) dec(A[L++]); while(R&gt;Q[i].R) dec(A[R--]); if(vis[Q[i].id]) col[Q[i].id]&amp;=tep; else&#123;col[Q[i].id]=tep;vis[Q[i].id]=true;&#125; &#125; for(int i=1;i&lt;=m&amp;&amp;i&lt;=34000;i++) &#123; ans[i]-=col[i].count()*3; printf("%d\n",ans[i]); &#125; m-=34000;memset(ans,0,sizeof(ans));memset(cnt,0,sizeof(cnt));memset(vis,0,sizeof(vis));tep.reset();&#125;int main()&#123; n=read();m=read();S=sqrt(n)+1e-10; for(int i=1;i&lt;=n;i++) A[i]=B[i]=read(); for(int i=1;i&lt;=n;i++) Area[i]=(i-1)/S+1; sort(B+1,B+1+n); for(int i=1,j;i&lt;=n;i=j+1) &#123; j=i; while(j&lt;n&amp;&amp;B[j+1]==B[i]) j++; C[B[i]]=sum;sum+=j-i+1; &#125; for(int i=1;i&lt;=n;i++) A[i]=C[A[i]]; while(m&gt;0) Solve(); return 0;&#125;]]></content>
      <categories>
        <category>莫队</category>
      </categories>
      <tags>
        <tag>莫队</tag>
        <tag>bitset</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「ZJOI2019模拟赛 六」硬币]]></title>
    <url>%2F2019%2F02%2F18%2F%E3%80%8CZJOI2019%E6%A8%A1%E6%8B%9F%E8%B5%9B%20%E5%85%AD%E3%80%8D%E7%A1%AC%E5%B8%81-Solution%2F</url>
    <content type="text"><![CDATA[模拟赛爆炸祭QwQ… 题面硬币coin.cpp coin.in/.out 时间限制:1s 空间限制:512M 题目描述KK有一枚硬币，他想做如下实验： 他会不停抛掷这枚硬币，并且记录下每次硬币是哪面朝上，当出现连续两次都是正面朝上时，就停止实验。 设总共抛掷了 $M$ 次后停止实验（即第 $M$ 次和第 $M-1$ 次都是正面朝上，而之前没有出现过连续两次正面朝上），令 $P(n)$ 表示 $M$ 是 $n$ 的倍数的概率。 比如 $P(2)={3\over 5}，P(3)={9\over 31}$，可以发现 $P(n)$ 总是可以表示成一个分数。 现在KK想知道 $P(n)$ 对 $10^9+9$ 取模后的结果。 输入格式一行，一个数 $n$。 输出格式一行，表示 $P(n)$ 对 $10^9+9$ 取模后的结果。 样例数据input1 13 output1 1548387102 input2 1100 output2 1618264982 input3 1100000000000000000 output3 1346869049 数据规模与约定对于 $30\%$ 的数据 $n\le 100$ 对于 $50\%​$ 的数据 $n\le 1000000​$ 对于 $80\%​$ 的数据 $n\le 1000000000​$ 对于 $100\%​$ 的数据 $n\le 10^{18}​$ 小贴士对于 ${n\over m}​$ 及一个质数 $p​$，${n\over m}​$ 在模 $p​$ 意义下等于 $n\times m^{p-2}​$ $\sqrt{5}​$在模$10^9+9​$的意义下的值为$383008016​$。 题解这道题基本上就没有部分分，做出来了就100，否则就0分。然而蒟蒻我还是太菜了，所以我必定属于后者。然后这场模拟赛我就光荣地爆炸了QwQ 这题推起来其实挺烦的，但是在省选题里面好像应该算简单了的吧。看来我还是太菜了。 废话不多说，接下来马上进入愉快的推式子环节。woc哪里愉快了 设$C(i)$表示抛了$i$次硬币，没有连续两次正面朝上的方案数。 令$1$表示正面朝上，$0$表示反面朝上，那么$C(i)$也就是长度为$i$的不存在连续两个$1$的01串的个数。 假设我们已近求出了$C(i-1)​$和$C(i-2)​$，现在考虑如何来计算出$C(i)​$的值。比如$i=3​$。 长度为$2$的串一共有$4$个，分别是00、01、10、11，其中串11是不合法的，其余的都是合法的。把这些串复制两份，一份前面加0，一次前面加1，这样就能得到长度为3的8个01串。 如果再前面加0，那么原来合法的串依然合法，原来不合法的串依然不合法。所以可以先把$C(i-1)$先累加到$C(i)$上。 如果在前面加1，那么原来以1开头的串就都不合法了，原来以0开头的串合法性不变。原来一共有$C(i-2)$个0开头的合法串，这些串同样也要累加到$C(i)$上。 所以就有递推式：$C(i)=C(i-1)+C(i-2)​$，其中$C(1)=2,C(2)=3​$。所以这就是一个错了2位的斐波那契数列。 再设$F(i)$表示抛了$i$次硬币，恰好结束的概率。 那么就有$F(i)=\frac{C(i-3)}{2^{i-3}}*\frac{1}{8}​$。因为当且仅当前$i-3​$次都要合法，第$i-2​$反面朝上，最后两次都正面朝上才会停止。 所以 F(i)=\frac{C(i-3)}{2^{i-3}}*\frac{1}{8}=\frac{C(i-3)}{2^i}=\frac{Fib(i-1)}{2^i}再根据题意，可得 P(n)=F(n)+F(2n)+\cdots+F(\infty n)=\sum_{i=1}^{\infty}{\frac{Fib(in-1)}{2^{in}}}其中斐波那契数列有一个通项公式 Fib(n)=\frac{\sqrt{5}}{5}((\frac{1+\sqrt{5}}{2})^n-(\frac{1-\sqrt{5}}{2})^n)再设 \alpha=\frac{1+\sqrt{5}}{2},\beta=\frac{1-\sqrt{5}}{2}所以 P(n)=\sum_{i=1}^{\infty}{\frac{Fib(in-1)}{2^{in}}}= \sum_{i=1}^{\infty}{\frac{\sqrt{5}}{5}\cdot\frac{\alpha^{in-1}-\beta^{in-1}}{2^{in}}}然后发现上面那个式子并不好处理，再化简一下 \sum_{i=1}^{\infty}{\frac{\sqrt{5}}{5}\cdot\frac{\alpha^{in-1}-\beta^{in-1}}{2^{in}}}= \frac{\sqrt{5}}{5}\sum_{i=1}^{\infty}{\frac{\alpha^{in-1}}{2^{in}}}-\frac{\sqrt{5}}{5}\sum_{i=1}^{\infty}{\frac{\beta^{in-1}}{2^{in}}}= \frac{\sum_{i=1}^{\infty}{\frac{\alpha^{in-1}}{2^{in}}}- \sum_{i=1}^{\infty}{\frac{\beta^{in-1}}{2^{in}}}}{\sqrt{5}}回想一下，发现带有无穷的式子可以通过等比数列还搞，于是想办法把上式搞出等比数列 上式=\frac{\frac{1}{\alpha}\sum_{i=1}^{\infty}{\frac{\alpha^{in}}{2^{in}}}- \frac{1}{\beta}\sum_{i=1}^{\infty}{\frac{\beta^{in}}{2^{in}}}}{\sqrt{5}}然后$\sum{i=1}^{\infty}{\frac{\alpha^{in}}{2^{in}}}​$就是等比数列，想办法把它的值算出来，后面的$\sum{i=1}^{\infty}{\frac{\beta^{in}}{2^{in}}}​$也一样的。 \sum_{i=1}^{\infty}{\frac{\alpha^{in}}{2^{in}}}=\sum_{i=1}^{\infty}{(\frac{\alpha^{n}}{2^{n}})^{i}}\\ 设q=\frac{\alpha^{n}}{2^{n}}\\ 设S=\sum_{i=1}^{\infty}{(\frac{\alpha^{n}}{2^{n}})^{i}}=q^1+q^2+q^3+\cdots+q^{\infty}\\ 则qS=q^2+q^3+q^4+\cdots+q^{\infty}\\ 故(q-1)S=-q\\ S=\frac{q}{1-q}求出$S$之后再代回原始中就能求出$P(n)$的值了。 终于写完了QwQ… 代码推了一长串，代码是真的短QwQ 123456789101112131415161718192021222324252627282930#include&lt;cmath&gt;#include&lt;cstdio&gt;using namespace std;typedef long long LL;const LL TT=1000000009,sqrt5=383008016,inv2=500000005;LL n;LL QP(LL a,LL b)&#123; LL ret=1,w=a; while(b) &#123; if(b&amp;1) ret=ret*w%TT; w=w*w%TT;b&gt;&gt;=1; &#125; return ret;&#125;LL Sum(LL q)&#123; q=QP(q,n); return q*QP((1-q+TT)%TT,TT-2)%TT;&#125;int main()&#123; freopen("coin.in","r",stdin); freopen("coin.out","w",stdout); scanf("%lld",&amp;n); LL alpha=(1+sqrt5)*inv2%TT,beta=(1+TT-sqrt5)*inv2%TT; printf("%lld\n",(QP(sqrt5,TT-2)*(QP(alpha,TT-2)*Sum(alpha*inv2%TT)%TT-QP(beta,TT-2)*Sum(beta*inv2%TT)%TT)%TT+TT)%TT); return 0; &#125;]]></content>
      <categories>
        <category>概率数学</category>
      </categories>
      <tags>
        <tag>概率</tag>
        <tag>数学</tag>
        <tag>无限</tag>
        <tag>逆元</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「洛谷P1654/BZOJ4318」OSU！]]></title>
    <url>%2F2019%2F02%2F15%2F%E3%80%8C%E6%B4%9B%E8%B0%B7P1654%20BZOJ4318%E3%80%8DOSU!-Solution%2F</url>
    <content type="text"><![CDATA[这题代码是真的短，但我就是做不来QwQ… 传送门洛谷P1654 BZOJ4318 题解感觉这个期望DP真的挺有趣的。 设$X1_i$表示以$i$为结尾的连续$1$串的期望长度，$X2_i$表示 以$i$为结尾的连续$1$串长度的平方的期望，$F_i$表示$i$次操作后的期望得分。 首先来看看$X1$该怎么递推，第$i$次操作有$Pi$的概率成功，贡献为$X1{i-1}+1$；还有$1-P_i$的概率失败，贡献为$0$，所以 X1_i=(X1_{i-1}+1) \cdot Pi+0 \cdot(1-P_i)=(X1_{i-1}+1) \cdot Pi再来看$X2$，根据完全平方公式$(x+1)^2=x^2+2x+1$，同理可得 X2_i=(X2_{i-1}+2\cdot X1_{i-1}+1) \cdot P_i再根据完全立方公式$(x+1)^3=x^3+3x^2+3x+1$，同理可得 F_i=(F_{i-1}+3 \cdot X2_{i-1}+3 \cdot X1_{i-1}+1) \cdot P_i+F_{i-1}(1-P_i)\\ =F_{i-1}+(3 \cdot X2_{i-1}+3 \cdot X1_{i-1}+1) \cdot P_i然后$F_n$就是答案 。 然后，然后就…没了。 代码真的很短哎QwQ。 1234567891011121314151617#include&lt;cstdio&gt;using namespace std;const int maxn=100005;int n;double P[maxn],X1[maxn],X2[maxn],F[maxn];int main()&#123; scanf("%d",&amp;n); for(int i=1;i&lt;=n;i++) &#123; scanf("%lf",&amp;P[i]); X1[i]=(X1[i-1]+1)*P[i]; X2[i]=(X2[i-1]+2*X1[i-1]+1)*P[i]; F[i]=F[i-1]+(3*X2[i-1]+3*X1[i-1]+1)*P[i]; &#125; printf("%.1lf\n",F[n]); return 0;&#125;]]></content>
      <categories>
        <category>期望DP</category>
      </categories>
      <tags>
        <tag>概率</tag>
        <tag>期望</tag>
        <tag>期望DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「AHOI2017/HNOI2017」大佬]]></title>
    <url>%2F2019%2F02%2F13%2F%E3%80%8CAHOI2017%20HNOI2017%E3%80%8D%E5%A4%A7%E4%BD%AC-Solution%2F</url>
    <content type="text"><![CDATA[这题面，生动形象，饶有趣味，interesting！出题人呢？ 传送门洛谷P3724 BZOJ4828 题解先把又臭又长的题面读两遍，然后很显然，保证自己不死和把大佬怼死是两个不同的环节，两个问题，分别解决，互不干扰（这话咋这么耳熟呢）。 设$F[i][j]​$表示到了第$i​$天，自己的自信值为$j​$，最多可以多少天不刷水题。 那么就可以腾出$\max{i=1}^{n}{\max{j=0}^{mc}{F[i][j]}}​$天来专门怼大佬。 注意不是$\max_{j=0}^{mc}{F[n][j]}​$，可能还没到第$n​$天就可以把大佬怼死，但是到了第$n​$天不可能不被大佬怼死。 那么问题就转化为：给你$D​$天，每天可以执行操作1、3、4或5，问你能不能把大佬的自信值怼到$0​$？ 注意是怼到$0​$，不能单纯刷DP取最大值，那样可能把大佬的自信值怼到负，而且可以怼的自信值不一定连续。 设一种只用操作3、4、5的怼大佬方案为$(Hurt，Day)​$表示用了$Day​$天对大佬产生了$Hurt​$点伤害，发现数据范围并不大，所以就可以用BFS把所有方案都列出来。至于到底有多少种方案，玄学，反正数组开大点就好了。$Hash​$判重，直接调STL里的map的话时效会差一些。（但是我懒，所以调了map） 然后把所有怼大佬的方案按照伤害排序，用两个指针，一头一尾扫过去就好了，注意两个方案的伤害之和不能超过大佬的自信值，且剩下位怼完的自信值可以用剩余的天数通过操作1把大佬怼死就行了。 代码稍微有点长QwQ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091#include&lt;map&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;typedef long long LL;const int maxn=105,inf=0x3F3F3F3F;int n,m,mc,a[maxn],w[maxn],D,F[maxn][maxn],tot,T[2000005];inline int read()&#123; int ret=0,f=1;char ch=getchar(); while(ch&lt;'0'||ch&gt;'9')&#123;if(ch=='-')f=-f;ch=getchar();&#125; while(ch&gt;='0'&amp;&amp;ch&lt;='9')&#123;ret=ret*10+ch-'0';ch=getchar();&#125; return ret*f;&#125;inline void GetFightDays() //刷DP计算天数&#123; memset(F,-1,sizeof(F));F[0][mc]=0; for(int i=1;i&lt;=n;i++) &#123; for(int j=a[i];j&lt;=mc;j++) //注意不要越界 &#123; F[i][j-a[i]]=max(F[i][j-a[i]],F[i-1][j]+1); int x=min(mc,j-a[i]+w[i] ); F[i][x]=max(F[i][x],F[i-1][j]); &#125; &#125; for(int i=1;i&lt;=n;i++) for(int j=0;j&lt;=mc;j++) if(F[i][j]&gt;D) D=F[i][j];&#125;struct Node&#123;int F,L;&#125;Q[2000005];map&lt;int,map&lt;int,int&gt; &gt; Day;struct Plan&#123; int Hurt,Days; bool operator &lt; (const Plan&amp; b)const&#123;return Hurt&lt;b.Hurt;&#125;&#125;P[2000005];inline void BFS()&#123; int hed=0,til=1,ddd; Q[1]=(Node)&#123;1,0&#125;;Day[1][0]=T[1]=1;//刷BFS搞出所有可能的方案 while(hed!=til) &#123; hed++;ddd=Day[Q[hed].F][Q[hed].L]; if(ddd&gt;=D) continue; if(!Day[Q[hed].F][Q[hed].L+1]) &#123; til++;Q[til].F=Q[hed].F;Q[til].L=Q[hed].L+1; Day[Q[til].F][Q[til].L]=T[til]=ddd+1; &#125; if((LL)Q[hed].F*Q[hed].L&lt;=100000000&amp;&amp;!Day[Q[hed].F*Q[hed].L][Q[hed].L]) &#123; til++;Q[til].F=Q[hed].F*Q[hed].L;Q[til].L=Q[hed].L; Day[Q[til].F][Q[til].L]=T[til]=ddd+1; &#125; &#125; P[++tot]=(Plan)&#123;0,0&#125;; for(int i=1;i&lt;=til;i++) P[++tot]=(Plan)&#123;Q[i].F,Day[Q[i].F][Q[i].L]&#125;; sort(P+1,P+1+tot);&#125;int Check(int C)&#123; int j=1,mi=inf; for(int i=tot;i;i--) &#123; while(i&gt;j&amp;&amp;P[i].Hurt+P[j].Hurt&lt;=C) &#123; mi=min(mi,P[j].Days-P[j].Hurt); j++; &#125; if(D&gt;=C-P[i].Hurt+P[i].Days+mi) return 1; &#125; return 0;&#125;int main()&#123; n=read();m=read();mc=read(); for(int i=1;i&lt;=n;i++) a[i]=read(); for(int i=1;i&lt;=n;i++) w[i]=read(); GetFightDays(); BFS(); while(m--) &#123; int Ci=read(); printf("%d\n",Check(Ci)); &#125; return 0;&#125;]]></content>
      <categories>
        <category>BFS</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>BFS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「洛谷P5108」仰望半月的夜空]]></title>
    <url>%2F2019%2F02%2F11%2F%E3%80%8C%E6%B4%9B%E8%B0%B7P5108%E3%80%8D%E4%BB%B0%E6%9C%9B%E5%8D%8A%E6%9C%88%E7%9A%84%E5%A4%9C%E7%A9%BA-Solution%2F</url>
    <content type="text"><![CDATA[这是一个标算与瞎搞的故事… 传送门洛谷P5108 题解蒟蒻我人生的第一道1次过样例并AC的黑题。（然而写的并不是标算，这题貌似也没有达到黑题的难度） 这题的标算是后缀数组，然鹅蒟蒻我选择了瞎搞QwQ。 此题瞎搞的关键点在于找出题目中隐藏的单调性。（大雾） 首先，如果先考虑长度为$1$的子串，再考虑长度为$2$的，长度为$3$的…那么分别一共有$n$个、$n-1$个、$n-2$个。 并不好搞。 所以倒着来处理。（汗 长度为$n$的子串可以由$1$开头、长度为$n-2$的子串可以由2开头…每次可能的开头增加一个。 并且其中有一定的单调性：对于合法的开头$i,j$，如果当前$i$比$j$优，那么之后$j$永远不可能比$i$优。 所以构造一个单调栈$stk[]$，每次直接把新增的合法开头扔进栈顶，然后不断比较当前长度下$stk[top]$和$stk[top-1]$。如果此时$stk[top]$不比$stk[top-1]$优，直接弹掉它，维护栈的单调性。 维护操作结束后，栈顶就是当前最优解。 但是还有一个关键问题没有解决：如何快速比较两个较长字符串的大小？ 既然原字符串是静态的，那么可以通过Hash+二分找出两个字符串的最长相同前缀，然后比较下一位即可。 瞎搞完成 ，总时间复杂度为$\Theta(n\log n)$。 然后… ZS：嗯哼？后缀数组的题让你Hash+二分过了？看我拍一宿造数据卡掉你！！！ 蒟蒻我：老师我写了双Hash！！！ ZS：嗯哼！喂？是中国人民解放军国防科技大学吗？麻烦你们把天河二号借我用一宿… 然后就没有然后了QwQ… 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include&lt;cstdio&gt;using namespace std;typedef long long LL;const int maxn=300005;int sig,n,S[maxn],top,stk[maxn],ans[maxn];char tep[maxn];inline int read()&#123; int ret=0,f=1;char ch=getchar(); while(ch&lt;'0'||ch&gt;'9')&#123;if(ch=='-')f=-f;ch=getchar();&#125; while(ch&gt;='0'&amp;&amp;ch&lt;='9')&#123;ret=ret*10+ch-'0';ch=getchar();&#125; return ret*f;&#125;struct Hash&#123; int Base,TT,Pow[maxn],Val[maxn]; void init(int b,int m) &#123; Base=b;TT=m;Pow[0]=1; for(int i=1;i&lt;=n;i++) Pow[i]=(LL)Pow[i-1]*Base%TT; for(int i=1;i&lt;=n;i++) Val[i]=((LL)Val[i-1]*Base+S[i])%TT; &#125; inline int GetHashValue(int L,int R)&#123;return ((Val[R]-(LL)Val[L-1]*Pow[R-L+1])%TT+TT)%TT;&#125;&#125;H1,H2;inline bool IsStringSame(int L,int R,int S,int T)&#123;return H1.GetHashValue(L,R)==H1.GetHashValue(S,T)&amp;&amp;H2.GetHashValue(L,R)==H2.GetHashValue(S,T);&#125;inline bool StrCmp(int S1,int S2,int len)&#123; int L=0,R=len,mid; while(L&lt;=R) &#123; mid=L+R&gt;&gt;1; IsStringSame(S1,S1+mid-1,S2,S2+mid-1)?L=mid+1:R=mid-1; &#125; if(R==len) return true; return S[S1+R]&gt;=S[S2+R];&#125;int main()&#123; sig=read();n=read(); if(sig==26) &#123; scanf("%s",tep+1); for(int i=1;i&lt;=n;i++) S[i]=tep[i]-'a'; &#125; else for(int i=1;i&lt;=n;i++) S[i]=read(); H1.init(19630217,1000000007);H2.init(19260817,1000000009); for(int len=n;len;len--) &#123; top++;stk[top]=n-len+1; while(top&gt;1&amp;&amp;StrCmp(stk[top],stk[top-1],len)) top--; ans[len]=stk[top]; &#125; for(int i=1;i&lt;=n;i++) printf("%d%c",ans[i],i==n?'\n':' '); return 0;&#125;]]></content>
      <categories>
        <category>单调栈</category>
      </categories>
      <tags>
        <tag>哈希</tag>
        <tag>二分</tag>
        <tag>单调栈</tag>
        <tag>后缀数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[高斯消元法解线性方程组]]></title>
    <url>%2F2019%2F02%2F07%2F%E9%AB%98%E6%96%AF%E6%B6%88%E5%85%83%E6%B3%95%E8%A7%A3%E7%BA%BF%E6%80%A7%E6%96%B9%E7%A8%8B%E7%BB%84-Algorithm%2F</url>
    <content type="text"><![CDATA[骚年？高斯消元了解一下！！！ 引入问题昨天，蒟蒻我遇到了一道题（传送门）。需要解一个n元非齐次线性方程组，才发现蒟蒻我这些玩意儿都忘得差不多了，吓得我赶紧掏出线性代数小紫书补一补，然后马上写个博客压压惊。 什么？您不知道什么是n元非齐次线性方程组？就是n元一次方程组啊！ 什么？您还是不知道？那肯定是dalao您又在嘲讽蒟蒻我了。请dalao您自行Ctrl+W！！！ 写得可能有不周到或者有问题的地方，还请dalao们多多指教。 理论基础比如说，有这样一个由$n$个方程组成的$n$元线性方程组： \begin{cases} a_{11}x_1+a_{12}x_2+\cdots+a_{1n}x_n=b_1\\ a_{21}x_1+a_{22}x_2+\cdots+a_{2n}x_n=b_2\\ \vdots\\ a_{n1}x_1+a_{n2}x_2+\cdots+a_{nn}x_n=b_n\\ \end{cases}我们可以把它表示成矩阵乘法的形式： \begin{Bmatrix} {a_{11}}&{a_{12}}&{\cdots}&{a_{1n}}\\ {a_{21}}&{a_{22}}&{\cdots}&{a_{2n}}\\ {\vdots}&{\vdots}&{\ddots}&{\vdots}\\ {a_{n1}}&{a_{n2}}&{\cdots}&{a_{nn}}\\ \end{Bmatrix} * \begin{Bmatrix} {x_1}\\ {x_2}\\ {\vdots}\\ {x_n}\\ \end{Bmatrix} = \begin{Bmatrix} {b_1}\\ {b_2}\\ {\vdots}\\ {b_n}\\ \end{Bmatrix}有这样几个有用的矩阵： A=(a_{ij}), x= \begin{Bmatrix} {x_1}\\ {x_2}\\ {\vdots}\\ {x_n}\\ \end{Bmatrix}, b= \begin{Bmatrix} {b_1}\\ {b_2}\\ {\vdots}\\ {b_n}\\ \end{Bmatrix}, B= \begin{Bmatrix} {a_{11}}&{a_{12}}&{\cdots}&{a_{1n}}&{b_1}\\ {a_{21}}&{a_{22}}&{\cdots}&{a_{2n}}&{b_2}\\ {\vdots}&{\vdots}&{\ddots}&{\vdots}&{\vdots}\\ {a_{n1}}&{a_{n2}}&{\cdots}&{a_{nn}}&{b_n}\\ \end{Bmatrix}其中$A$称为系数矩阵，$x$称为未知数矩阵，$b$称为常数项矩阵，$B$称为增广矩阵。 如果系数矩阵是形如下面这个样子上三角矩阵（即对角线以下都为0），那么就很爽了： \begin{Bmatrix} {a_{11}}&{a_{12}}&{\cdots}&{a_{1n}}\\ {0}&{a_{22}}&{\cdots}&{a_{2n}}\\ {\vdots}&{\vdots}&{\ddots}&{\vdots}\\ {0}&{0}&{\cdots}&{a_{nn}}\\ \end{Bmatrix}其中$a{nn}$的值就是$x_n$的值，这样就解出了一个未知数的值，然后代入上一个方程中，就能解出$x{n-1}$的值然后一直往上代入并求解，这样方程组就解出来了耶！ 但是很显然这么好的事情并不是每次都有（特别是对于我这种脸黑的蒟蒻来说`）。 所以我们就要想办法把系数矩阵变成这个样子，高斯消元就是干这个的。 我们就先把增广矩阵拎出来，其他的扔到一边腌制半个小时待用不管了。 我们可以把增广矩阵的一行乘以任意一个系数然后加到另一行，方程组的解不变。 其实就是相当于把原方程组的一个方程乘以一个系数再加到另一个方程组上。 我们可以把第一行的元素乘以一个系数加到第二行，乘以另一个系数加到第三行……一直加到第$n$行。 然后就可以把矩阵变成这样： \begin{Bmatrix} {a_{11}}&{a_{12}}&{\cdots}&{a_{1n}}&{b_1}\\ {0}&{a_{22}'}&{\cdots}&{a_{2n}'}&{b_2'}\\ {\vdots}&{\vdots}&{\ddots}&{\vdots}&{\vdots}\\ {0}&{a_{n2}'}&{\cdots}&{a_{nn}'}&{b_n'}\\ \end{Bmatrix}然后再把操作后的矩阵的第二行乘以一个系数加到第三行、第四行重复上面的操作，然后矩阵就会变成这样： \begin{Bmatrix} {a_{11}}&{a_{12}}&{\cdots}&{a_{1n}}&{b_1}\\ {0}&{a_{22}'}&{\cdots}&{a_{2n}'}&{b_2'}\\ {\vdots}&{\vdots}&{\ddots}&{\vdots}&{\vdots}\\ {0}&{0}&{\cdots}&{a_{nn}''}&{b_n''}\\ \end{Bmatrix}再重复上面的操作，最终矩阵就会变成理想状态了。然后依次代入消元即可。 需要注意的是，如果系数矩阵的对角线上有$0$的话是会出事的，记得特殊处理一下。 然后就没有然后了，理论部分就是这样。 代码实现详见我的上一篇博客 其他参考资料 ： 工程数学——线性代数 第六版 同济大学数学系。 话说MathJax的数学公式用起来真是赏心悦目。]]></content>
      <categories>
        <category>高斯消元</category>
      </categories>
      <tags>
        <tag>高斯消元</tag>
        <tag>数学</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「JSOI2008」球形空间产生器]]></title>
    <url>%2F2019%2F02%2F06%2F%E3%80%8CJSOI2008%E3%80%8D%E7%90%83%E5%BD%A2%E7%A9%BA%E9%97%B4%E4%BA%A7%E7%94%9F%E5%99%A8-Solution%2F</url>
    <content type="text"><![CDATA[纳尼？n维空间？什么鬼？？？ 传送门洛谷P4035 BZOJ1013 题解根据题目的说明，设球心的坐标为$Oj(j \in [1,n])$，$n+1$个点的坐标为$X{ij}(i \in[1,n+1],j\in{1,n})$，$R$为半径，那么就有$n+1$个这样的式子： \sum_{j=1}^{n}{(O_j-X_{ij})^2}=R^2将$R$消去，平方展开，移项后，可以得到$n$个这样的方程： \sum_{j=1}^{n}{2\cdot (X_{i+1j}-X_{ij})}\cdot O_j=\sum_{j=1}^{n}{X_{i+1j}^2-X_{ij}^2}狠狠盯着方程几秒钟，然后你就会发现方程中只有$O_j$是未知数，其他都是常数，所以这$n​$个方程构成了一个n元非齐次线性方程组（说人话叫做n元一次方程组）。 怎么解呢？ 上高斯消元啊啊啊！！！ 才发现什么矩阵行列式之类的东西都忘得差不多了，吓得我赶紧掏出了线性代数小紫书 那么 ，怎么用高斯消元法 解线性方程组呢？且听下回分解请左拐至…！ 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;int n;double a[15][15],A[15][15];double ABS(double x)&#123;return x&lt;0?-x:x;&#125;inline void Gauss() //高斯消元解方程&#123; for(int i=1;i&lt;=n;i++) &#123; int now=i; for(int j=i+1;j&lt;=n;j++) if(ABS(A[j][i]&gt;A[now][i])) now=j; if(now!=i) for(int j=i;j&lt;=n+1;j++) swap(A[now][j],A[i][j]); for(int k=i+1;k&lt;=n;k++) &#123; double t=A[k][i]/A[i][i]; for(int j=i;j&lt;=n+1;j++) A[k][j]-=A[i][j]*t; &#125; &#125; for(int i=n;i;i--) &#123; for(int j=i+1;j&lt;=n;j++) A[i][n+1]-=A[j][n+1]*A[i][j]; A[i][n+1]/=A[i][i]; &#125;&#125;int main()&#123; scanf("%d",&amp;n); for(int i=1;i&lt;=n+1;i++) for(int j=1;j&lt;=n;j++) scanf("%lf",&amp;a[i][j]); for(int i=1;i&lt;=n;i++) &#123; for(int j=1;j&lt;=n;j++) &#123; A[i][j]=2*(a[i+1][j]-a[i][j]); A[i][n+1]+=a[i+1][j]*a[i+1][j]-a[i][j]*a[i][j]; &#125; &#125; //A数组是该n元非齐次线性方程组的增广矩阵 Gauss(); for(int i=1;i&lt;=n;i++) printf("%.3lf%c",A[i][n+1],i==n?'\n':' '); return 0;&#125;]]></content>
      <categories>
        <category>高斯消元</category>
      </categories>
      <tags>
        <tag>高斯消元</tag>
        <tag>解方程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「SCOI2008」奖励关]]></title>
    <url>%2F2019%2F02%2F05%2F%E3%80%8CSCOI2008%E3%80%8D%E5%A5%96%E5%8A%B1%E5%85%B3-Solution%2F</url>
    <content type="text"><![CDATA[又是状压又是期望的，本蒟蒻最不熟了QwQ。 传送门洛谷P2473 BZOJ1076 题解由于种种原因，这题的DP是倒着推的。 设$F[i][s]$表示现在是第$i$关，已经吃的宝物的状态为$s$，吃到最后的得分期望。 由于每一关中每个宝物的概率都相同，所以累加每个宝物的贡献然后除以$n$即可。 转移方程，若可以吃第$j (j \in [1,n])$个宝物，可以选择吃或者不吃 F[i][s]+=max(F[i+1][s],F[i+1][s|(1]]></content>
      <categories>
        <category>状压期望DP</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>状态压缩</tag>
        <tag>概率与期望</tag>
        <tag>期望DP</tag>
        <tag>状压DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「SCOI2009」粉刷匠]]></title>
    <url>%2F2019%2F02%2F04%2F%E3%80%8CSCOI2009%E3%80%8D%E7%B2%89%E5%88%B7%E5%8C%A0-Solution%2F</url>
    <content type="text"><![CDATA[周政是个粉刷匠，粉刷本领强！他把自己的小白脸，刷得黑又脏！ 传送门洛谷P4158 BZOJ1296 题解本蒟蒻难得1A的省选题，虽然很老。 瞅了一眼数据范围，挺小的，直接上DP瞎搞！！！（汗 设$F[i][j][k]​$表示对于第$i​$行的前$j​$列，涂了$k​$次颜料，最多能刷对几个格子。 那么初始值$F[i][j][k]=F[i][j-1][k]​$； 转移方程： F[i][j][k]=\max_{l=0}^{j-1}{F[i][l][k-1]+sum[i][j]-sum[i][l]} \tag{1} F[i][j][k]=\max_{l=0}^{j-1}{F[i][l][k-1]+j-l-sum[i][j]+sum[i][l]} \tag{2}第一个式子表示$[l+1,j]$涂蓝色，第二个表示涂红色。 上式中的$sum[i][j]$表示第$i$行前$j$个格子中有几个希望被染成蓝色，即颜色的前缀和。 所以$F[i][m][k]​$就表示第$i​$行涂$k​$次最多能涂对几个格子。 预处理出了上式之后，然后再DP一趟，就能得出答案了呢（雾 令$G[i][j]​$表示对于前$i​$行，涂了$j​$次颜料，最多能涂对多少个格子。 那么很显然又有转移方程： G[i][j]=\max_{k=0}^{min(m,j)}{G[i-1][j-k]+F[i][m][k]} \tag{3}这趟DP刷完之后，终于得到了答案，即$G[n​$][T]。 就没有然后了QwQ 代码123456789101112131415161718192021222324252627282930313233343536373839#include&lt;cstdio&gt;using namespace std;const int maxn=55,maxt=2505;int n,m,T,F[maxn][maxn][maxn],sum[maxn][maxn],G[maxn][maxt];char GetChar()&#123; char ch=getchar(); while(ch!='0'&amp;&amp;ch!='1') ch=getchar(); return ch;&#125;int main()&#123; scanf("%d%d%d",&amp;n,&amp;m,&amp;T); for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=m;j++) sum[i][j]=sum[i][j-1]+(int)(GetChar()=='1'); for(int i=1;i&lt;=n;i++) &#123; for(int j=1;j&lt;=m;j++) &#123; for(int k=1;k&lt;=m;k++) &#123; F[i][j][k]=F[i][j-1][k]; for(int l=0;l&lt;j;l++) &#123; if(F[i][l][k-1]+sum[i][j]-sum[i][l]&gt;F[i][j][k]) F[i][j][k]=F[i][l][k-1]+sum[i][j]-sum[i][l]; if(F[i][l][k-1]+j-l-sum[i][j]+sum[i][l]&gt;F[i][j][k]) F[i][j][k]=F[i][l][k-1]+j-l-sum[i][j]+sum[i][l]; &#125; &#125; &#125; &#125; for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=T;j++) for(int k=0;k&lt;=m&amp;&amp;k&lt;=j;k++) if(G[i-1][j-k]+F[i][m][k]&gt;G[i][j]) G[i][j]=G[i-1][j-k]+F[i][m][k]; printf("%d\n",G[n][T]); return 0;&#125;]]></content>
      <categories>
        <category>DP</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>三维DP</tag>
        <tag>动态规划</tag>
        <tag>双DP</tag>
        <tag>二维DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「HNOI2008」GT考试]]></title>
    <url>%2F2019%2F02%2F03%2F%E3%80%8CHNOI2008%E3%80%8DGT%E8%80%83%E8%AF%95-Solution%2F</url>
    <content type="text"><![CDATA[继续学数数喽QwQ… 传送门洛谷P3193 BZOJ1009 题解很显然这是一道优化DP数数题 ，可惜我又不会QwQ。 （此处省略0x3F3F3F3F字的思考过程） 令$f[i][j]​$表示长串匹配到第$i​$位，短串匹配到第$j​$位的合法方案数； $g[k][j]$表示短串匹配到第$j$位时，长串再加上一个字符使得最多能匹配$k$位的方案数。 那么就有 f[i][j]=\sum_{k=0}^{m-1}{f[i-1][k]*g[k][j]}最后的答案就是 \sum_{i=0}^{m-1}{f[n][i]}观察一下DP转移方程，发现$g$数组是固定的，可以通过看毛片KMP或者暴力预处理出来（抱歉我这里真的没有毛片看，但是据说隔壁巨佬知道哪里有）。 再狠狠瞅几眼转移方程，艾玛！这不是一个矩阵乘法的式子吗！ 令矩阵$F[i]$的第一行为$f[i][j]​$，那么就有 F[i]=F[i-1]*G所以 F[n]=F[0]*G^n且又知道$f[0][0]=1$、最后答案为$F[n]​$第一行元素之和。 所以这题就解完了。 代码本蒟蒻因为矩阵重载乘法运算符是忘了return调了半天QwQ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include&lt;cstdio&gt;#include&lt;cstring&gt;using namespace std;int n,m,K,nxt[25],ans;char S[25];struct Matrix //矩阵类&#123; int A[25][25]; Matrix()&#123;memset(A,0,sizeof(A));&#125; Matrix operator * (const Matrix&amp; b) //矩阵乘法 &#123; Matrix c; for(int i=0;i&lt;m;i++) &#123; for(int j=0;j&lt;m;j++) &#123; for(int k=0;k&lt;m;k++) &#123; c.A[i][j]+=A[i][k]*b.A[k][j]; c.A[i][j]%=K; //记得mod &#125; &#125; &#125; return c; &#125;&#125;G,F;inline void KMP() //KMP构造矩阵G&#123; for(int i=2;i&lt;=m;i++) &#123; int j=nxt[i-1]; while(j&amp;&amp;S[i]!=S[j+1]) j=nxt[j]; if(S[i]==S[j+1]) nxt[i]=j+1; &#125; for(int i=0;i&lt;m;i++) &#123; for(int j='0';j&lt;='9';j++) &#123; int k=i; while(k&amp;&amp;S[k+1]!=j) k=nxt[k]; if(S[k+1]==j) k++; if(k&lt;m) G.A[i][k]++; &#125; &#125;&#125;Matrix QP(const Matrix&amp; a,int b) //矩阵快速幂&#123; Matrix ret=a,w=a;b--; while(b) &#123; if(b&amp;1) ret=ret*w; w=w*w;b&gt;&gt;=1; &#125; return ret;&#125;int main()&#123; scanf("%d%d%d%s",&amp;n,&amp;m,&amp;K,S+1); KMP();F.A[0][0]=1;F=F*QP(G,n); for(int i=0;i&lt;m;i++) ans=(ans+F.A[0][i])%K; printf("%d\n",ans); return 0;&#125;]]></content>
      <categories>
        <category>矩阵加速DP</category>
      </categories>
      <tags>
        <tag>数数</tag>
        <tag>DP</tag>
        <tag>快速幂</tag>
        <tag>矩阵加速</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「AHOI2009」中国象棋]]></title>
    <url>%2F2019%2F01%2F31%2F%E3%80%8CAHOI2009%E3%80%8D%E4%B8%AD%E5%9B%BD%E8%B1%A1%E6%A3%8B-Solution%2F</url>
    <content type="text"><![CDATA[数数万岁… 前言早晨起床，打开电脑，上了洛谷，打了个卡，发现智能推荐里面有几道上古时代的省选题。随便戳开了一道，发现是个应该是个DP数数题，而我数数又很差，正想补补，于是就很愉快的做起了此题… 传送门洛谷P2051 BZOJ1801 题解感觉2010年之前的省选题都不怎么难、代码量都不大(对于个别题目当我没说)… 首先很显然，每一行每一列里，如果炮的个数都≤2，那么都是合法的啦！ 看了一眼，数据范围很亲切，然后就自然而然地想出了这样一个DP：（汗 F[i][j][k] 表示放了前i行，有j列放了2个炮，k列放了1个炮，那么就有m-i-j列没有放炮首先是初始值$F[0][0][0]=1​$。 然后考虑怎么从第$i-1$行转移过来。 如果第$i$行一个炮也不放，那么就有$F[i][j][k]=F[i-1][j][k]$。 如果放一个，那么有两种情况： 放在空的列上： $F[i][j][k]+=F[i-1][j][k-1]*(m-j-k+1)​$； 放在只放了1个炮的列上： $F[i][j][k]+=F[i-1][j-1][k+1]*(k+1)​$。 如果放两个炮，那么有三种情况： 两个都放在空的列上：$F[i][j][k]+=F[i-1][j][k-2]\cdot(m-j-k+2)\cdot(m-j-k+1)/2$； 一个放在空列，一个放在只有一个的列上：$F[i][j][k]+=F[i-1][j-1][k]\cdot k\cdot(m-j-k+1)$； 两个都放在只有一个的列上：$F[i][j][k]+=F[i-1][j-2][k+2]\cdot(k+2)\cdot(k+1)/2$。 最后的答案： \sum_{1=0}^{m}{\sum_{j=0}^{m-i}{F[n][i][j]}}然后这题就做完了QwQ。 代码123456789101112131415161718192021222324252627282930#include&lt;cstdio&gt;using namespace std;typedef long long LL;const int maxn=105,TT=9999973;int n,m,F[maxn][maxn][maxn],ans;int main()&#123; scanf("%d%d",&amp;n,&amp;m);F[0][0][0]=1; for(int i=1;i&lt;=n;i++) &#123; for(int j=0;j&lt;=m;j++) &#123; for(int k=0;j+k&lt;=m;k++) &#123; F[i][j][k]=F[i-1][j][k];//这题的模数比较小，有些地方不需要马上模，可以写好看一点 if(k&gt;=1) F[i][j][k]+=F[i-1][j][k-1]*(m-j-k+1); if(j&gt;=1) F[i][j][k]+=F[i-1][j-1][k+1]*(k+1); if(k&gt;=2) F[i][j][k]+=F[i-1][j][k-2]*(LL)(m-j-k+2)*(m-j-k+1)/2%TT; if(j&gt;=1) F[i][j][k]+=F[i-1][j-1][k]*(LL)k*(m-j-k+1)%TT; if(j&gt;=2) F[i][j][k]+=F[i-1][j-2][k+2]*(LL)(k+2)*(k+1)/2%TT; F[i][j][k]%=TT; &#125; &#125; &#125; for(int j=0;j&lt;=m;j++) for(int k=0;j+k&lt;=m;k++) ans=(ans+F[n][j][k])%TT; printf("%d\n",ans); return 0;&#125;]]></content>
      <categories>
        <category>DP</category>
      </categories>
      <tags>
        <tag>数数</tag>
        <tag>DP</tag>
        <tag>递推</tag>
        <tag>三维DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「FJOI2007」轮状病毒]]></title>
    <url>%2F2019%2F01%2F30%2F%E3%80%8CFJOI2007%E3%80%8D%E8%BD%AE%E7%8A%B6%E7%97%85%E6%AF%92-Solution%2F</url>
    <content type="text"><![CDATA[数数题怎么这么讨厌呀QwQ… 传送门洛谷P2144 BZOJ1002 题解这种数数题当然要先找规律呀poi！ 通过手玩或者暴力，可以得到以下表格： n ans 1 1 2 5 3 16 4 45 5 121 6 320 咦？当$n$为奇数时，$ans$都是完全平方数哇！！！ 那么当$n$为偶数时呢？ 哟，$ans$加上4之后也都是完全平方数呢！！！ 把这些完全平方数开个方试试看！！！ 就得到了这样的一个序列：1 3 4 7 11 18… 呀呀呀！这不就是一个变形的斐波那契数列么？ 并且$n​$很小，直接上高精度就好了呢poi。 然后这题就做完了QwQ… 别问我为什么有这样的规律，我也不知道QwQ… 码完代码测样例，才发现高精度都写挂了，我好菜啊QwQ 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;const int maxn=105;int n;struct BigInt //封装好的高精度&#123; int a[50],len; BigInt()&#123;len=0;memset(a,0,sizeof(a));&#125; BigInt(int x) &#123; len=0;memset(a,0,sizeof(a)); while(x)&#123;len++;a[len]=x%10;x/=10;&#125; &#125; BigInt operator + (const BigInt&amp; b) &#123; BigInt c; c.len=max(len,b.len); for(int i=1;i&lt;=c.len;i++) &#123; c.a[i]+=a[i]+b.a[i]; c.a[i+1]+=c.a[i]/10; c.a[i]%=10; &#125; if(c.a[c.len+1]) c.len++; return c; &#125; BigInt operator * (const BigInt&amp; b) &#123; BigInt c; c.len=len+b.len-1; for(int i=1;i&lt;=len;i++) &#123; for(int j=1;j&lt;=b.len;j++) &#123; c.a[i+j-1]+=a[i]*b.a[j]; c.a[i+j]+=c.a[i+j-1]/10; c.a[i+j-1]%=10; &#125; &#125; if(c.a[c.len+1]) c.len++; return c; &#125; BigInt operator - (const int&amp; b) //这个减法只能减去10以内的数 &#123; BigInt c=*this; c.a[1]-=b; for(int i=1;i&lt;=c.len&amp;&amp;c.a[i]&lt;0;i++) &#123; c.a[i]+=10; c.a[i+1]--; &#125; while(!c.a[c.len]) c.len--; return c; &#125; inline void Print() &#123; for(int i=len;i;i--) printf("%d",a[i]); printf("\n"); &#125;&#125;F[maxn],ans;int main()&#123; scanf("%d",&amp;n);F[1]=1;F[2]=3; for(int i=3;i&lt;=n;i++) F[i]=F[i-1]+F[i-2]; ans=F[n]*F[n]; if(n%2==0) ans=ans-4; //n为偶数时记得减去4哟 ans.Print(); return 0;&#125;]]></content>
      <categories>
        <category>递推</category>
      </categories>
      <tags>
        <tag>数数</tag>
        <tag>DP</tag>
        <tag>递推</tag>
        <tag>高精度</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「SCOI2009」windy数]]></title>
    <url>%2F2019%2F01%2F30%2F%E3%80%8CSCOI2009%E3%80%8Dwindy%E6%95%B0-Solution%2F</url>
    <content type="text"><![CDATA[分块打表大法好！打表万岁！dalao保佑我打表进省队！（逃 传送门洛谷P2657 BZOJ1026 题解很显然，这题正解是数位DP，但是我觉得上分块打表会更好玩一些！ 设块大为$S$，我们可以先写一个暴力，计算出S、2S、3S、4S……内一共有多少个windy数，把这个表事先打出来。由于$A、B$都比较小，打这个表不会用很长时间。蒟蒻我的机子还不错，八框框的i5 CPU，最高可以睿频到3.4GHz，用了四十多秒就跑完了。然后根据容斥原理，最后的答案是$Solve(B)-Solve(A-1)$，其中$Solve(x)$用于求解共有多少个windy数$\in[1,x]$。且必有$x \in [kS,(k+1)S]$。$Solve(kS)$已经事先打过表了，暴力枚举并检验$[kS+1,x]$中有多少个windy数即可。为了减少最终代码长度，令$S=10^6$或$10^7​$即可。 代码还好，不是很长呢poi。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include&lt;cstdio&gt;using namespace std;const int table[2005]=&#123;0,202174,338305,476808,615022,753274,891526,1029740,1168243,1304374,1459689,1459689,1459689,1459689,1597903,1736155,1874407,2012621,2151124,2287255,2442570,2597885,2597885,2597885,2597885,2736137,2874389,3012603,3151106,3287237,3442552,3597867,3733998,3733998,3733998,3733998,3872250,4010464,4148967,4285098,4440413,4595728,4731859,4870362,4870362,4870362,4870362,5008576,5147079,5283210,5438525,5593840,5729971,5868474,6006688,6006688,6006688,6006688,6145191,6281322,6436637,6591952,6728083,6866586,7004800,7143052,7143052,7143052,7143052,7279183,7434498,7589813,7725944,7864447,8002661,8140913,8279165,8279165,8279165,8279165,8434480,8589795,8725926,8864429,9002643,9140895,9279147,9417361,9417361,9417361,9417361,9572676,9708807,9847310,9985524,10123776,10262028,10400242,10538745,10538745,10538745,10538745,10538745,10538745,10538745,10538745,10538745,10538745,10538745,10538745,10538745,10538745,10538745,10538745,10538745,10538745,10538745,10538745,10538745,10538745,10538745,10538745,10538745,10538745,10538745,10538745,10538745,10538745,10538745,10538745,10538745,10694060,10830191,10830191,10830191,10830191,10968443,11106657,11245160,11381291,11536606,11691921,11828052,11966555,11966555,11966555,11966555,12104769,12243272,12379403,12534718,12690033,12826164,12964667,13102881,13102881,13102881,13102881,13241384,13377515,13532830,13688145,13824276,13962779,14100993,14239245,14239245,14239245,14239245,14375376,14530691,14686006,14822137,14960640,15098854,15237106,15375358,15375358,15375358,15375358,15530673,15685988,15822119,15960622,16098836,16237088,16375340,16513554,16513554,16513554,16513554,16668869,16805000,16943503,17081717,17219969,17358221,17496435,17634938,17634938,17634938,17634938,17634938,17773441,17911655,18049907,18188159,18326373,18464876,18601007,18756322,18756322,18756322,18756322,18756322,18756322,18756322,18756322,18756322,18756322,18756322,18756322,18756322,18756322,18756322,18756322,18756322,18756322,18756322,18756322,18756322,18756322,18756322,18756322,18756322,18756322,18756322,18756322,18756322,18756322,18756322,18911637,19047768,19186271,19186271,19186271,19186271,19324485,19462988,19599119,19754434,19909749,20045880,20184383,20322597,20322597,20322597,20322597,20461100,20597231,20752546,20907861,21043992,21182495,21320709,21458961,21458961,21458961,21458961,21595092,21750407,21905722,22041853,22180356,22318570,22456822,22595074,22595074,22595074,22595074,22750389,22905704,23041835,23180338,23318552,23456804,23595056,23733270,23733270,23733270,23733270,23888585,24024716,24163219,24301433,24439685,24577937,24716151,24854654,24854654,24854654,24854654,24854654,24993157,25131371,25269623,25407875,25546089,25684592,25820723,25976038,25976038,25976038,25976038,26114252,26252504,26390756,26528970,26667473,26803604,26958919,26958919,26958919,26958919,26958919,26958919,26958919,26958919,26958919,26958919,26958919,26958919,26958919,26958919,26958919,26958919,26958919,26958919,26958919,26958919,26958919,26958919,26958919,26958919,26958919,26958919,26958919,26958919,26958919,26958919,26958919,27114234,27250365,27388868,27527082,27527082,27527082,27527082,27665585,27801716,27957031,28112346,28248477,28386980,28525194,28663446,28663446,28663446,28663446,28799577,28954892,29110207,29246338,29384841,29523055,29661307,29799559,29799559,29799559,29799559,29954874,30110189,30246320,30384823,30523037,30661289,30799541,30937755,30937755,30937755,30937755,31093070,31229201,31367704,31505918,31644170,31782422,31920636,32059139,32059139,32059139,32059139,32059139,32197642,32335856,32474108,32612360,32750574,32889077,33025208,33180523,33180523,33180523,33180523,33318737,33456989,33595241,33733455,33871958,34008089,34163404,34318719,34318719,34318719,34318719,34456971,34595223,34733437,34871940,35008071,35163386,35163386,35163386,35163386,35163386,35163386,35163386,35163386,35163386,35163386,35163386,35163386,35163386,35163386,35163386,35163386,35163386,35163386,35163386,35163386,35163386,35163386,35163386,35163386,35163386,35163386,35163386,35163386,35163386,35163386,35163386,35318701,35454832,35593335,35731549,35869801,35869801,35869801,35869801,36005932,36161247,36316562,36452693,36591196,36729410,36867662,37005914,37005914,37005914,37005914,37161229,37316544,37452675,37591178,37729392,37867644,38005896,38144110,38144110,38144110,38144110,38299425,38435556,38574059,38712273,38850525,38988777,39126991,39265494,39265494,39265494,39265494,39265494,39403997,39542211,39680463,39818715,39956929,40095432,40231563,40386878,40386878,40386878,40386878,40525092,40663344,40801596,40939810,41078313,41214444,41369759,41525074,41525074,41525074,41525074,41663326,41801578,41939792,42078295,42214426,42369741,42525056,42661187,42661187,42661187,42661187,42799439,42937653,43076156,43212287,43367602,43367602,43367602,43367602,43367602,43367602,43367602,43367602,43367602,43367602,43367602,43367602,43367602,43367602,43367602,43367602,43367602,43367602,43367602,43367602,43367602,43367602,43367602,43367602,43367602,43367602,43367602,43367602,43367602,43367602,43367602,43522917,43659048,43797551,43935765,44074017,44212269,44212269,44212269,44212269,44367584,44522899,44659030,44797533,44935747,45073999,45212251,45350465,45350465,45350465,45350465,45505780,45641911,45780414,45918628,46056880,46195132,46333346,46471849,46471849,46471849,46471849,46471849,46610352,46748566,46886818,47025070,47163284,47301787,47437918,47593233,47593233,47593233,47593233,47731447,47869699,48007951,48146165,48284668,48420799,48576114,48731429,48731429,48731429,48731429,48869681,49007933,49146147,49284650,49420781,49576096,49731411,49867542,49867542,49867542,49867542,50005794,50144008,50282511,50418642,50573957,50729272,50865403,51003906,51003906,51003906,51003906,51142120,51280623,51416754,51572069,51572069,51572069,51572069,51572069,51572069,51572069,51572069,51572069,51572069,51572069,51572069,51572069,51572069,51572069,51572069,51572069,51572069,51572069,51572069,51572069,51572069,51572069,51572069,51572069,51572069,51572069,51572069,51572069,51572069,51572069,51727384,51863515,52002018,52140232,52278484,52416736,52554950,52554950,52554950,52554950,52710265,52846396,52984899,53123113,53261365,53399617,53537831,53676334,53676334,53676334,53676334,53676334,53814837,53953051,54091303,54229555,54367769,54506272,54642403,54797718,54797718,54797718,54797718,54935932,55074184,55212436,55350650,55489153,55625284,55780599,55935914,55935914,55935914,55935914,56074166,56212418,56350632,56489135,56625266,56780581,56935896,57072027,57072027,57072027,57072027,57210279,57348493,57486996,57623127,57778442,57933757,58069888,58208391,58208391,58208391,58208391,58346605,58485108,58621239,58776554,58931869,59068000,59206503,59344717,59344717,59344717,59344717,59483220,59619351,59774666,59774666,59774666,59774666,59774666,59774666,59774666,59774666,59774666,59774666,59774666,59774666,59774666,59774666,59774666,59774666,59774666,59774666,59774666,59774666,59774666,59774666,59774666,59774666,59774666,59774666,59774666,59774666,59774666,59774666,59774666,59929981,60066112,60204615,60342829,60481081,60619333,60757547,60896050,60896050,60896050,60896050,60896050,61034553,61172767,61311019,61449271,61587485,61725988,61862119,62017434,62017434,62017434,62017434,62155648,62293900,62432152,62570366,62708869,62845000,63000315,63155630,63155630,63155630,63155630,63293882,63432134,63570348,63708851,63844982,64000297,64155612,64291743,64291743,64291743,64291743,64429995,64568209,64706712,64842843,64998158,65153473,65289604,65428107,65428107,65428107,65428107,65566321,65704824,65840955,65996270,66151585,66287716,66426219,66564433,66564433,66564433,66564433,66702936,66839067,66994382,67149697,67285828,67424331,67562545,67700797,67700797,67700797,67700797,67836928,67992243,67992243,67992243,67992243,67992243,67992243,67992243,67992243,67992243,67992243,67992243,67992243,67992243,67992243,67992243,67992243,67992243,67992243,67992243,67992243,67992243,67992243,67992243,67992243,67992243,67992243,67992243,67992243,67992243,67992243,67992243,67992243,67992243,68130746,68268960,68407212,68545464,68683678,68822181,68958312,69113627,69113627,69113627,69113627,69251841,69390093,69528345,69666559,69805062,69941193,70096508,70251823,70251823,70251823,70251823,70390075,70528327,70666541,70805044,70941175,71096490,71251805,71387936,71387936,71387936,71387936,71526188,71664402,71802905,71939036,72094351,72249666,72385797,72524300,72524300,72524300,72524300,72662514,72801017,72937148,73092463,73247778,73383909,73522412,73660626,73660626,73660626,73660626,73799129,73935260,74090575,74245890,74382021,74520524,74658738,74796990,74796990,74796990,74796990,74933121,75088436,75243751,75379882,75518385,75656599,75794851,75933103,75933103,75933103,75933103,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76226921,76365135,76503387,76641639,76779853,76918356,77054487,77209802,77209802,77209802,77209802,77348016,77486268,77624520,77762734,77901237,78037368,78192683,78192683,78192683,78192683,78192683,78192683,78192683,78192683,78192683,78192683,78192683,78192683,78192683,78192683,78192683,78192683,78192683,78192683,78192683,78192683,78192683,78192683,78192683,78192683,78192683,78192683,78192683,78192683,78192683,78192683,78192683,78347998,78484129,78622632,78760846,78760846,78760846,78760846,78899349,79035480,79190795,79346110,79482241,79620744,79758958,79897210,79897210,79897210,79897210,80033341,80188656,80343971,80480102,80618605,80756819,80895071,81033323,81033323,81033323,81033323,81188638,81343953,81480084,81618587,81756801,81895053,82033305,82171519,82171519,82171519,82171519,82326834,82462965,82601468,82739682,82877934,83016186,83154400,83292903,83292903,83292903,83292903,83292903,83431406,83569620,83707872,83846124,83984338,84122841,84258972,84414287,84414287,84414287,84414287,84552501,84690753,84829005,84967219,85105722,85241853,85397168,85552483,85552483,85552483,85552483,85690735,85828987,85967201,86105704,86241835,86397150,86397150,86397150,86397150,86397150,86397150,86397150,86397150,86397150,86397150,86397150,86397150,86397150,86397150,86397150,86397150,86397150,86397150,86397150,86397150,86397150,86397150,86397150,86397150,86397150,86397150,86397150,86397150,86397150,86397150,86397150,86552465,86688596,86827099,86965313,87103565,87103565,87103565,87103565,87239696,87395011,87550326,87686457,87824960,87963174,88101426,88239678,88239678,88239678,88239678,88394993,88550308,88686439,88824942,88963156,89101408,89239660,89377874,89377874,89377874,89377874,89533189,89669320,89807823,89946037,90084289,90222541,90360755,90499258,90499258,90499258,90499258,90499258,90637761,90775975,90914227,91052479,91190693,91329196,91465327,91620642,91620642,91620642,91620642,91758856,91897108,92035360,92173574,92312077,92448208,92603523,92758838,92758838,92758838,92758838,92897090,93035342,93173556,93312059,93448190,93603505,93758820,93894951,93894951,93894951,93894951,94033203,94171417,94309920,94446051,94601366,94601366,94601366,94601366,94601366,94601366,94601366,94601366,94601366,94601366,94601366,94601366,94601366,94601366,94601366,94601366,94601366,94601366,94601366,94601366,94601366,94601366,94601366,94601366,94601366,94601366,94601366,94601366,94601366,94601366,94601366,94756681,94892812,95031315,95169529,95307781,95446033,95446033,95446033,95446033,95601348,95756663,95892794,96031297,96169511,96307763,96446015,96584229,96584229,96584229,96584229,96739544,96875675,97014178,97152392,97290644,97428896,97567110,97705613,97705613,97705613,97705613,97705613,97844116,97982330,98120582,98258834,98397048,98535551,98671682,98826997,98826997,98826997,98826997,98965211,99103463,99241715,99379929,99518432,99654563,99809878,99965193,99965193,99965193,99965193,100103445,100241697,100379911,100518414,100654545,100809860,100965175,101101306,101101306,101101306,101101306,101239558,101377772,101516275,101652406,101807721,101963036,102099167,102237670,102237670,102237670,102237670,102375884,102514387,102650518,102805833,102805833,102805833,102805833,102805833,102805833,102805833,102805833,102805833,102805833,102805833,102805833,102805833,102805833,102805833,102805833,102805833,102805833,102805833,102805833,102805833,102805833,102805833,102805833,102805833,102805833,102805833,102805833,102805833,102805833,102805833,102961148,103097279,103235782,103373996,103512248,103650500,103788714,103788714,103788714,103788714,103944029,104080160,104218663,104356877,104495129,104633381,104771595,104910098,104910098,104910098,104910098,104910098,105048601,105186815,105325067,105463319,105601533,105740036,105876167,106031482,106031482,106031482,106031482,106169696,106307948,106446200,106584414,106722917,106859048,107014363,107169678,107169678,107169678,107169678,107307930,107446182,107584396,107722899,107859030,108014345,108169660,108305791,108305791,108305791,108305791,108444043,108582257,108720760,108856891,109012206,109167521,109303652,109442155,109442155,109442155,109442155,109580369,109718872,109855003,110010318,110165633,110301764,110440267,110578481,110578481,110578481,110578481,110716984,110853115,111008430,111008430,111008430,111008430,111008430,111008430,111008430,111008430,111008430,111008430,111008430,111008430,111008430,111008430,111008430,111008430,111008430,111008430,111008430,111008430,111008430,111008430,111008430,111008430,111008430,111008430,111008430,111008430,111008430,111008430,111008430,111163745,111299876,111438379,111576593,111714845,111853097,111991311,112129814,112129814,112129814,112129814,112129814,112268317,112406531,112544783,112683035,112821249,112959752,113095883,113251198,113251198,113251198,113251198,113389412,113527664,113665916,113804130,113942633,114078764,114234079,114389394,114389394,114389394,114389394,114527646,114665898,114804112,114942615,115078746,115234061,115389376,115525507,115525507,115525507,115525507,115663759,115801973,115940476,116076607,116231922,116387237,116523368,116661871,116661871,116661871,116661871,116800085,116938588,117074719,117230034,117385349,117521480,117659983,117798197,117798197,117798197,117798197,117936700,118072831,118228146,118383461,118519592,118658095,118796309,118934561,118934561,118934561,118934561,119070692,119226007,119226007,119226007,119226007,119226007,119226007,119226007,119226007,119226007,119226007,119226007,119226007,119226007,119226007,119226007,119226007,119226007,119226007,119226007,119226007,119226007,119226007,119226007,119226007,119226007,119226007,119226007,119226007,119226007,119226007,119226007,119226007,119226007,119364510,119502724,119640976,119779228,119917442,120055945,120192076,120347391,120347391,120347391,120347391,120485605,120623857,120762109,120900323,121038826,121174957,121330272,121485587,121485587,121485587,121485587,121623839,121762091,121900305,122038808,122174939,122330254,122485569,122621700,122621700,122621700,122621700,122759952,122898166,123036669,123172800,123328115,123483430,123619561,123758064,123758064,123758064,123758064,123896278,124034781,124170912,124326227,124481542,124617673,124756176,124894390,124894390,124894390,124894390,125032893,125169024,125324339,125479654,125615785,125754288,125892502,126030754,126030754,126030754,126030754,126166885,126322200,126477515,126613646,126752149,126890363,127028615,127166867,127166867,127166867,127166867,127322182,127322182,127322182,127322182,127322182,127322182,127322182,127322182,127322182,127322182,127322182,127322182,127322182,127322182,127322182,127322182,127322182,127322182,127322182,127322182,127322182&#125;;int A,B;inline int read()&#123; int ret=0,f=1;char ch=getchar(); while(ch&lt;'0'||ch&gt;'9')&#123;if(ch=='-')f=-f;ch=getchar();&#125; while(ch&gt;='0'&amp;&amp;ch&lt;='9')&#123;ret=ret*10+ch-'0';ch=getchar();&#125; return ret*f;&#125;int ABS(int x)&#123;return x&lt;0?-x:x;&#125;inline bool check(int x)&#123; static int A[15],len; len=0; while(x)&#123;A[++len]=x%10;x/=10;&#125; for(int i=1;i&lt;len;i++) if(ABS(A[i+1]-A[i])&lt;2) return false; return true;&#125;inline void MakeTable()&#123; freopen("Table.txt","w",stdout); register int i,ans=0; for(i=1;i&lt;=2000000000;i++) &#123; if(check(i)) ans++; if(i%1000000==0) printf("%d,",ans); &#125;&#125;inline int Solve(int n)&#123; int ret=table[n/1000000]; for(int i=n/1000000*1000000+1;i&lt;=n;i++) if(check(i)) ret++; return ret;&#125;int main()&#123;// MakeTable(); scanf("%d%d",&amp;A,&amp;B); printf("%d\n",Solve(B)-Solve(A-1)); return 0;&#125;]]></content>
      <categories>
        <category>分块打表</category>
      </categories>
      <tags>
        <tag>数位DP</tag>
        <tag>分块</tag>
        <tag>打表</tag>
        <tag>分块打表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「HNOI2005」狡猾的商人]]></title>
    <url>%2F2019%2F01%2F29%2F%E3%80%8CHNOI2005%E3%80%8D%E7%8B%A1%E7%8C%BE%E7%9A%84%E5%95%86%E4%BA%BA-Solution%2F</url>
    <content type="text"><![CDATA[贪心大法好QwQ！ 传送门洛谷P2294 BZOJ1202 题解这题有好多种解法，可以上差分约束、并查集之类的。 但是贪心大法好啊！！！ 把所有偷看到的信息按左端点排序，然后从前到后两两比较。 如果左端点相同 比较右端点 如果右端点相同 比较权值，如果不相同直接输出false 如果右端点不相同 将重叠部分抵消掉，权值相减得到一个新的信息，扔回去，用堆维护 如果左端点不同 把前面一个信息扔掉即可，不用管 直到最后，堆空了，没有出现问题，那么输出true就好了。 代码其实这题挺水的 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include&lt;queue&gt;#include&lt;vector&gt;#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;int T,n,m;bool fal;inline int read()&#123; int ret=0,f=1;char ch=getchar(); while(ch&lt;'0'||ch&gt;'9')&#123;if(ch=='-')f=-f;ch=getchar();&#125; while(ch&gt;='0'&amp;&amp;ch&lt;='9')&#123;ret=ret*10+ch-'0';ch=getchar();&#125; return ret*f;&#125;struct Node&#123; int L,R,w; bool operator &lt; (const Node&amp; b)const&#123;return L&lt;b.L||(L==b.L&amp;&amp;R&lt;b.R);&#125; bool operator &gt; (const Node&amp; b)const&#123;return L&gt;b.L||(L==b.L&amp;&amp;R&gt;b.R);&#125;&#125;tep1,tep2;priority_queue&lt;Node,vector&lt;Node&gt;,greater&lt;Node&gt; &gt; H;int main()&#123; T=read(); while(T--) &#123; while(H.size()) H.pop(); n=read();m=read();fal=false; for(int i=1;i&lt;=m;i++) &#123; tep1.L=read();tep1.R=read();tep1.w=read(); H.push(tep1); &#125; tep1=H.top();H.pop(); while(H.size()) &#123; tep2=H.top();H.pop(); if(tep1.L==tep2.L) &#123; if(tep1.R==tep2.R) &#123; if(tep1.w!=tep2.w) &#123;printf("false\n");fal=true;break;&#125; &#125; else if(tep1.R!=tep2.R) H.push((Node)&#123;tep1.R+1,tep2.R,tep2.w-tep1.w&#125;); &#125; tep1=tep2; &#125; if(!fal) printf("true\n"); &#125; return 0;&#125;]]></content>
      <categories>
        <category>贪心</category>
      </categories>
      <tags>
        <tag>贪心</tag>
        <tag>并查集</tag>
        <tag>查分约束</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「HNOI2006」马步距离]]></title>
    <url>%2F2019%2F01%2F28%2F%E3%80%8CHNOI2006%E3%80%8D%E9%A9%AC%E6%AD%A5%E8%B7%9D%E7%A6%BB-Solution%2F</url>
    <content type="text"><![CDATA[这题有点水QwQ… 传送门洛谷P2060 BZOJ1193 题解首先很显然不能直接贪心，直接贪心有可能WA，所以要写个DFS之类的东西来搜。 但是数据稍微有点大QwQ，搜不出来。 不难发现，当距离比较远时直接贪心地奔着目标走是肯定没问题的。 所以距离远时贪心，距离近时爆搜就行了QwQ。 其实手玩就能把表打出来。 代码打表万岁 123456789101112131415161718192021222324252627#include&lt;cstdio&gt;using namespace std;const int f[7][7]=&#123; &#123;0,3,2,3,2&#125;, &#123;3,2,1,2,3&#125;, &#123;2,1,4,3,2&#125;, &#123;3,2,3,2,3&#125;, &#123;2,3,2,3,4&#125;&#125;;int xp,yp,xs,ys,x,y,ans;int ABS(int x)&#123;return x&lt;0?-x:x;&#125;int main()&#123; scanf("%d%d%d%d",&amp;xp,&amp;yp,&amp;xs,&amp;ys); x=ABS(xp-xs);y=ABS(yp-ys); while(x&gt;4||y&gt;4) &#123; if(x&lt;y)&#123;x--;y-=2;&#125; else&#123;x-=2;y--;&#125; if(x&lt;0) x=-x;if(y&lt;0) y=-y; ans++; &#125; ans+=f[x][y]; printf("%d\n",ans); return 0;&#125;]]></content>
      <categories>
        <category>贪心</category>
      </categories>
      <tags>
        <tag>贪心</tag>
        <tag>DFS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「BJOI2014」想法]]></title>
    <url>%2F2019%2F01%2F24%2F%E3%80%8CBJOI2014%E3%80%8D%E6%83%B3%E6%B3%95-Solution%2F</url>
    <content type="text"><![CDATA[什么鬼？省选也出这种玄学随机算法题？ 传送门洛谷P4581 题解首先这题一看就很不可解。 所以上随机算法（人家题面都告诉你了QwQ）。 写之前先膜拜一下dalao，保佑AC。 sto 黄霖 orz 对于一个节点，将所用能走到它的叶子节点都存下来是不现实的，所以我们只存$k$个。并且我们要先为每个叶子节点i随机一个权值$W_i$，满足$W_i \in [1,RANDMAX]$。对于每个非叶子节点，我们需要存下所有能走到个节点的叶子节点的权值的前$k$小。设这个节点的答案为$ans$，第$k$小权值为$F_k​$根据期望可得 \frac{F_k}{RANDMAX}=\frac{k}{ans}故有 ans=\frac{k*RANDMAX}{F_k}令$k=50$，多为叶子节点随机几套权值求平均值，吸个氧，放个大悲咒，选个好种子，你就能AC了。 代码这是真的玄学QwQ 1234567891011121314151617181920212223242526272829303132333435363738394041424344#include&lt;cstdio&gt;#include&lt;cstdlib&gt;using namespace std;typedef long long LL;const int maxn=1000005,k=50;int n,m,son[maxn][2],w[maxn],num[maxn],f[maxn][55];LL ans[maxn];inline int read()&#123; int ret=0,f=1;char ch=getchar(); while(ch&lt;'0'||ch&gt;'9')&#123;if(ch=='-')f=-f;ch=getchar();&#125; while(ch&gt;='0'&amp;&amp;ch&lt;='9')&#123;ret=ret*10+ch-'0';ch=getchar();&#125; return ret*f;&#125;inline void Merge(int s1,int s2,int now) //从两个儿子节点合并过来&#123; register int i=1,j=1;num[now]=k; for(register int p=1;p&lt;=k;p++) &#123; while(f[s1][i]==f[now][p-1]&amp;&amp;i&lt;=num[s1]) i++; //注意去重 while(f[s2][j]==f[now][p-1]&amp;&amp;j&lt;=num[s2]) j++; if(i&gt;num[s1]&amp;&amp;j&gt;num[s2])&#123;num[now]=p-1;break;&#125; if(i&lt;=num[s1]&amp;&amp;(f[s1][i]&lt;f[s2][j]||j&gt;num[s2]))&#123;f[now][p]=f[s1][i];i++;&#125; else if(j&lt;=num[s2])&#123;f[now][p]=f[s2][j];j++;&#125; &#125;&#125;int main()&#123; srand(20050429); n=read();m=read(); for(register int i=m+1;i&lt;=n;i++)&#123;son[i][0]=read();son[i][1]=read();&#125; for(int r=1;r&lt;=4;r++) &#123; for(register int i=1;i&lt;=n;i++)&#123;w[i]=rand();while(!w[i])w[i]=rand();&#125; for(register int i=1;i&lt;=m;i++)&#123;f[i][1]=w[i];num[i]=1;&#125; for(register int i=m+1;i&lt;=n;i++) &#123; Merge(son[i][0],son[i][1],i); if(num[i]&lt;k) ans[i]=num[i]*4; //如果还没到k个就不用根据期望计算了 else ans[i]+=(LL)k*RAND_MAX/f[i][k]; &#125; &#125; for(int i=m+1;i&lt;=n;i++) printf("%lld\n",ans[i]/4); return 0;&#125;]]></content>
      <categories>
        <category>随机算法</category>
      </categories>
      <tags>
        <tag>随机算法</tag>
        <tag>DAG</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「洛谷P2617」Dynamic Rankings]]></title>
    <url>%2F2019%2F01%2F23%2F%E3%80%8C%E6%B4%9B%E8%B0%B7P2617%E3%80%8DDynamic-Rankings%2F</url>
    <content type="text"><![CDATA[标算又是树套树？写不来QwQ… 传送门BZOJ(是个权限题QwQ) 洛谷P2617 题解据说这题可以用带修主席树、树套树、整体二分解。由于蒟蒻我实在太菜了QwQ，只好选择了整体二分。 把刚原始序列理解为n个添加操作，将修改操作理解为一个删除操作和一个添加操作。然后直接上整体二分，解法类似于「ZJOI2013」K大数查询。并且由于每次只需要修改一个位置的信息，所以用普通树状数组就行了呢poi，快得飞起（尽管我自带大常数QwQ）。 代码整体二分又好写又好理解呢poi 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283#include&lt;cstdio&gt;using namespace std;const int maxn=100005;int n,m,tot,cnt,ans[maxn],A[maxn];inline int read()&#123; int ret=0,f=1;char ch=getchar(); while(ch&lt;'0'||ch&gt;'9')&#123;if(ch=='-')f=-f;ch=getchar();&#125; while(ch&gt;='0'&amp;&amp;ch&lt;='9')&#123;ret=ret*10+ch-'0';ch=getchar();&#125; return ret*f;&#125;struct BIT //封装好的树状数组&#123; int Tree[maxn]; void Update(int pos,int delta)&#123;while(pos&lt;=n)&#123;Tree[pos]+=delta;pos+=pos&amp;-pos;&#125;&#125; int Query(int pos)&#123;int ret=0;while(pos&gt;0)&#123;ret+=Tree[pos];pos-=pos&amp;-pos;&#125;return ret;&#125;&#125;Tr;struct Command&#123;int typ,idx,num,delta,L,R,k,id;&#125;Q[maxn*4],Q1[maxn*4],Q2[maxn*4];char GetChar() //读取操作类型，排除无用字符&#123; char ch=getchar(); while(ch!='C'&amp;&amp;ch!='Q') ch=getchar(); return ch;&#125;void BinarySearch(int L,int R,int S,int T) //整体二分&#123; if(L&gt;R||S&gt;T) return; int mid=L+R&gt;&gt;1,til1=0,til2=0; if(L==R) &#123; for(int i=S;i&lt;=T;i++) if(Q[i].typ) ans[Q[i].id]=mid; return; &#125; for(int i=S;i&lt;=T;i++) &#123; if(!Q[i].typ) &#123; if(Q[i].num&lt;=mid) &#123; Tr.Update(Q[i].idx,Q[i].delta); Q1[++til1]=Q[i]; &#125; else Q2[++til2]=Q[i]; &#125; else &#123; int cnt=Tr.Query(Q[i].R)-Tr.Query(Q[i].L-1); if(cnt&lt;Q[i].k) &#123; Q[i].k-=cnt; Q2[++til2]=Q[i]; &#125; else Q1[++til1]=Q[i]; &#125; &#125; for(int i=S;i&lt;=T;i++) //别忘了还原树状数组哟poi if(!Q[i].typ) if(Q[i].num&lt;=mid) Tr.Update(Q[i].idx,-Q[i].delta); for(int i=1;i&lt;=til1;i++) Q[S+i-1]=Q1[i]; for(int i=1;i&lt;=til2;i++) Q[S+til1+i-1]=Q2[i]; BinarySearch(L,mid,S,S+til1-1); BinarySearch(mid+1,R,S+til1,T);&#125;int main()&#123; n=read();m=read(); for(int i=1;i&lt;=n;i++)&#123;tot++;Q[tot].idx=i;Q[tot].num=A[i]=read();Q[tot].delta=1;&#125; for(int i=1;i&lt;=m;i++) &#123; if(GetChar()=='Q')&#123;tot++;cnt++;Q[tot].typ=1;Q[tot].L=read();Q[tot].R=read();Q[tot].k=read();Q[tot].id=cnt;&#125; else &#123; tot++;Q[tot].idx=read();Q[tot].num=read();Q[tot].delta=1; tot++;Q[tot].idx=Q[tot-1].idx;Q[tot].num=A[Q[tot-1].idx];A[Q[tot-1].idx]=Q[tot-1].num;Q[tot].delta=-1; &#125; &#125; BinarySearch(0,1000000000,1,tot); for(int i=1;i&lt;=cnt;i++) printf("%d\n",ans[i]); return 0;&#125;]]></content>
      <categories>
        <category>整体二分</category>
      </categories>
      <tags>
        <tag>主席树</tag>
        <tag>树状数组</tag>
        <tag>整体二分</tag>
        <tag>树套树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「国家集训队」聪聪可可]]></title>
    <url>%2F2019%2F01%2F16%2F%E3%80%8C%E5%9B%BD%E5%AE%B6%E9%9B%86%E8%AE%AD%E9%98%9F%E3%80%8D%E8%81%AA%E8%81%AA%E5%8F%AF%E5%8F%AF%2F</url>
    <content type="text"><![CDATA[我数数最差了QwQ… 传送门洛谷P2634 BZOJ2152 题解很显然这是一道假的概率题。而是一道数数题，只要数出路径长度为3的倍数的点对的数量就行了呢poi。 隔壁dalao说这是一道点分治裸题，但是我还是觉得树形DP更好写一些QwQ。 定义$F_{ij}(j \in \lbrace 0,1,2 \rbrace)$表示节点$i$的子树中，到i的距离$\mod 3=j$的节点个数。如果当前遍历到的节点为i，我们需要计算出$i$及其子树中满足最短路径经过节点$i$且满足路径长是3的倍数的节点个数，累计到答案里最后除以$n^2$并约分就好了呢poi。 注意起点和终点可以相同，计算时小心点，不要算重复也不要漏算了哟poi。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243#include&lt;cstdio&gt;using namespace std;const int maxn=20005;int n,tot,lnk[maxn],son[maxn*2],w[maxn*2],nxt[maxn*2],F[maxn][3],ans1,ans2;inline int read()&#123; int ret=0,f=1;char ch=getchar(); while(ch&lt;'0'||ch&gt;'9')&#123;if(ch=='-')f=-f;ch=getchar();&#125; while(ch&gt;='0'&amp;&amp;ch&lt;='9')&#123;ret=ret*10+ch-'0';ch=getchar();&#125; return ret*f;&#125;inline void add_e(int x,int y,int z)&#123;tot++;son[tot]=y;w[tot]=z;nxt[tot]=lnk[x];lnk[x]=tot;&#125;int gcd(int x,int y)&#123;return !y?x:gcd(y,x%y);&#125;void DFS(int now,int fa)&#123; F[now][0]=1; for(int i=lnk[now];i;i=nxt[i]) &#123; if(son[i]!=fa) &#123; DFS(son[i],now); for(int j=0;j&lt;3;j++) ans1+=F[son[i]][j]*F[now][((3-j-w[i])%3+3)%3]*2; for(int j=0;j&lt;3;j++) F[now][(j+w[i])%3]+=F[son[i]][j]; &#125; &#125;&#125;int main()&#123; n=read(); for(int i=1;i&lt;n;i++) &#123; int a=read(),b=read(),c=read(); add_e(a,b,c);add_e(b,a,c); &#125; DFS(1,0); ans1+=n;ans2=n*n; int gys=gcd(ans1,ans2); ans1/=gys;ans2/=gys; printf("%d/%d\n",ans1,ans2); return 0;&#125;]]></content>
      <categories>
        <category>树形DP</category>
      </categories>
      <tags>
        <tag>数数</tag>
        <tag>DP</tag>
        <tag>树形DP</tag>
        <tag>DFS</tag>
        <tag>概率</tag>
        <tag>点分治</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「洛谷P5059」中国象棋]]></title>
    <url>%2F2019%2F01%2F16%2F%E3%80%8C%E6%B4%9B%E8%B0%B7P5059%E3%80%8D%E4%B8%AD%E5%9B%BD%E8%B1%A1%E6%A3%8B%2F</url>
    <content type="text"><![CDATA[又是数数题QwQ… 传送门洛谷P5059 题解首先注意题目中说的是有$n^2$个格子，也就是$(n+1)^2$个格点。 以下是出题人的推导： 首先我们可以发现每一行是独立的，所以只需要处理一行的答案即可 设$F[i][0]$表示一行中摆了$i$个位置且第$i$个位置不摆放棋子的方案数 设$F[i][1]$表示一行中摆了$i$个位置且第$i$个位置摆放棋子的方案数 设$Ans[i]$表示$F[i][0]+F[i][1]$ 那么忽略第二个限制可以发现有: $F[i][0]=F[i-1][0]+F[i-1][1]$ $F[i][1]=F[i-1][0]$ 所以有 $Ans[i]$ $=F[i][0]+F[i][1]$ $=2F[i-1][0]+F[i-1][1]$ $=(F[i-1][0]+F[i-1][1])+(F[i-2][0]+F[i-2][1])$ $=Ans[i-1]+Ans[i-2]$ 好了很显然这是一个斐波那契数列。自己再推一下，注意一下细节，不难发现最后的答案就是 (Fib_{n+3}-n-2)^{n+1}矩阵加快速幂就可以在$\Theta(\log n)$的复杂内求解。 还有一个问题，由于n和P都非常大，直接乘long long也会boom。所以这里用了一个类似于快速幂的方法来求$(a*b)\mod P$的值。虽然复杂度多了一只log，但是很好写，并且避免了高精度又臭又长的代码和大常数复杂度。 代码还挺好写的呢poi。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include&lt;cstdio&gt;using namespace std;typedef long long LL;LL n,P;LL Multiply(LL x,LL y) //两个10^18级别的数在模P意义下的乘法&#123; LL ret=0,w=x; while(y) &#123; if(y&amp;1) ret=(ret+w)%P; w=(w+w)%P;y&gt;&gt;=1; &#125; return ret;&#125;struct Matrix&#123; LL a[2][2]; Matrix()&#123;a[0][0]=a[0][1]=a[1][0]=a[1][1]=0;&#125; Matrix operator * (Matrix b) //矩阵乘法 &#123; Matrix c; for(int i=0;i&lt;2;i++) for(int j=0;j&lt;2;j++) for(int k=0;k&lt;2;k++) c.a[i][j]=(c.a[i][j]+Multiply(a[k][j],b.a[i][k]))%P; return c; &#125;&#125;ans,mat,tep;LL QP(LL a,LL b) //普通快速幂&#123; LL ret=1,w=a; while(b) &#123; if(b&amp;1) ret=Multiply(ret,w); w=Multiply(w,w);b&gt;&gt;=1; &#125; return ret;&#125;int main()&#123; scanf("%lld%lld",&amp;n,&amp;P); ans.a[0][0]=ans.a[0][1]=mat.a[0][0]=mat.a[0][1]=mat.a[1][0]=1; LL b=n+1;tep=mat; while(b) //矩阵加速斐波那契数列 &#123; if(b&amp;1) mat=mat*tep; tep=tep*tep;b&gt;&gt;=1; &#125; ans=ans*mat; printf("%lld\n",QP(((ans.a[0][0]-n-2)%P+P)%P,n+1)); return 0;&#125;]]></content>
      <categories>
        <category>矩阵加速DP</category>
      </categories>
      <tags>
        <tag>数数</tag>
        <tag>DP</tag>
        <tag>快速幂</tag>
        <tag>矩阵加速</tag>
        <tag>斐波那契数列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「JSOI2004」平衡点/吊打XXX]]></title>
    <url>%2F2019%2F01%2F15%2F%E3%80%8CJSOI2004%E3%80%8D%E5%B9%B3%E8%A1%A1%E7%82%B9%20%E5%90%8A%E6%89%93XXX-Solution%2F</url>
    <content type="text"><![CDATA[这是一个欧皇与非酋的故事…… 引言很久很久以前，有一位欧皇叫做黄霖，他热衷于各种随机算法，而且每次都能AC，直到有一天，他看到了张老师（ZS，我的启蒙老师，他水平很高，造数据能力特强）出的一份卷子： 黄霖：嗯！T1模拟退火能AC！T2模拟退火也能AC！T3模拟退火照样AC！ 张老师（冷笑）：嗯哼？三题都写模拟退火？有分吗？ 然后就没有然后了呢poi… 传送门洛谷P1337 题解这是一道物理题。 首先根据最小势能原理，当整个系统的势能最小时，系统平衡。不要问我为什么QwQ，我物理不好呢poi 虽然这题的正解不是模拟退火，但是用这题来当模拟退火的经典题还是很不错的呢poi。 首先我们钦定一个点作为绳结所在的位置作为初始答案，然后计算势能。 每次都在当前答案点附近的一个区域内rand一个点，区域大小由当前温度决定，如果这个点更优（势能更小），那么久接收这个点作为答案。否则有一定的概率接收新答案（概率计算方法很玄学，但是温度越小接收的概率越大）。 然后将温度乘以一个降温系数（降温系数是一个小于1的正数，这一步即退火），然后进行下一次答案搜索。 当温度降到几乎为0时停止就行了呢poi。 退火技巧首先可以多退几次。 降温系数要根据题目细调，太大了会导致时效差，太小可能搜不到最优解QwQ。 初始温度也要根据情况给定，可以用一些历史上特殊的日子，比如某dalao的生日来做初始温度呢poi。 种子也建议用某dalao的生日，或脸滚键盘，最好不要用初始值。 没事时多放放大悲咒，往生咒，般若波罗蜜多心经之类的音乐，你将得到佛祖的保佑。 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;cstdlib&gt;using namespace std;const int maxn=1005;const double delta=0.995; //降温系数int n,X[maxn],Y[maxn],W[maxn];double ansx,ansy,anse;inline int read()&#123; int ret=0,f=1;char ch=getchar(); while(ch&lt;'0'||ch&gt;'9')&#123;if(ch=='-')f=-f;ch=getchar();&#125; while(ch&gt;='0'&amp;&amp;ch&lt;='9')&#123;ret=ret*10+ch-'0';ch=getchar();&#125; return ret*f;&#125;inline double PotentialEnergy(double nowx,double nowy) //计算势能&#123; double ret=0; for(int i=1;i&lt;=n;i++) ret+=sqrt((X[i]-nowx)*(X[i]-nowx)+(Y[i]-nowy)*(Y[i]-nowy))*W[i]; return ret;&#125;inline void SimulateAnneal(double T)&#123; double nowx=ansx,nowy=ansy; while(T&gt;1e-14) &#123; double tempx=nowx+(rand()*2-RAND_MAX)*T; double tempy=nowy+(rand()*2-RAND_MAX)*T; double PE=PotentialEnergy(tempx,tempy); if(PE&lt;anse) //如果更优就马上接受 &#123; ansx=tempx;ansy=tempy; nowx=tempx;nowy=tempy; anse=PE; &#125; else if(exp((anse-PE)/T)*RAND_MAX&gt;rand())&#123;nowx=tempx;nowy=tempy;&#125; //否则有一定概率接收 T*=delta; //降温 &#125;&#125;inline void Solve()&#123; anse=PotentialEnergy(ansx,ansy); SimulateAnneal(2005); //多刷几次，记得洗把脸 SimulateAnneal(1926); SimulateAnneal(1949); SimulateAnneal(1978);&#125;int main()&#123; srand(20050429);//2005年4月29日dalao LTL出生，dalao会为你带来好运 n=read(); for(int i=1;i&lt;=n;i++)&#123;X[i]=read();Y[i]=read();W[i]=read();&#125; Solve(); printf("%.3lf %.3lf\n",ansx,ansy); return 0;&#125;]]></content>
      <categories>
        <category>模拟退火</category>
      </categories>
      <tags>
        <tag>随机算法</tag>
        <tag>模拟退火</tag>
        <tag>物理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「USACO2015JAN」草鉴定Grass Cownoisseur]]></title>
    <url>%2F2019%2F01%2F14%2F%E3%80%8CUSACO2015JAN%E3%80%8D%E8%8D%89%E9%89%B4%E5%AE%9AGrass-Cownoisseur%20-Solution%2F</url>
    <content type="text"><![CDATA[骚年，快来看！奶牛Bessie又在吃草了QwQ。 传送门洛谷P3119 题解单向道路？求一次能遍历到的最大点的数量？二话不说先上个Tarjan缩个点压压惊poi。 如果没有逆行这种操作，那么很显然起点所在强联通分量点的个数就是答案。 可是Bessie就是Bessie，总要搞点事情出来才符合她的性格。 于是乎我们缩点之后正反建图，刷两趟SPFA求每个点到起点的最长路。 然后枚举缩完点的图上的一条边，用来搞事情逆行。设当前枚举到的边为$(u,v)$，那么$u$在正建的图上到起点的最长路加上$v$在反建图上到起点的最长路就是逆行这条边时的最优解。在所有边里刷个最大值就行了呢poi。 有几个坑： 在最后计算答案时起点的权值会被算两次，记得减去一个。 枚举用于逆行的边时需要确保可以走到这条边并且走到这条边后可以走回起点。 由于需要建三套图(没缩过点的一套正建图一套反建图一套)，不要把数组名搞混了。此时封装可能是个好办法（但是会长一些，所以我没封装）。 其实总体上讲这题的想法并不难，但是代码有点难码QwQ。 于是乎这题就解完了。时间复杂度为$\Theta(n)$。 代码我觉得我写的挺简洁的poi。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687#include&lt;cstdio&gt;#include&lt;cstring&gt;using namespace std;const int maxn=100005;int n,m,tot[3],lnk[3][maxn],son[3][maxn],nxt[3][maxn],w[maxn],idx,dfn[maxn],low[maxn],top,stack[maxn],cnt,id[maxn],dist[3][maxn],que[maxn],ans;bool vis[maxn];inline int read()&#123; int ret=0,f=1;char ch=getchar(); while(ch&lt;'0'||ch&gt;'9')&#123;if(ch=='-')f=-f;ch=getchar();&#125; while(ch&gt;='0'&amp;&amp;ch&lt;='9')&#123;ret=ret*10+ch-'0';ch=getchar();&#125; return ret*f;&#125;inline void add_e(int x,int y,int id)&#123;tot[id]++;son[id][tot[id]]=y;nxt[id][tot[id]]=lnk[id][x];lnk[id][x]=tot[id];&#125;void Tarjan(int now)&#123; idx++;top++;vis[now]=true; dfn[now]=low[now]=idx;stack[top]=now; for(int i=lnk[0][now];i;i=nxt[0][i]) &#123; if(!dfn[son[0][i]]) &#123; Tarjan(son[0][i]); if(low[son[0][i]]&lt;low[now]) low[now]=low[son[0][i]]; &#125; else if(vis[son[0][i]]&amp;&amp;dfn[son[0][i]]&lt;low[now]) low[now]=dfn[son[0][i]]; &#125; if(dfn[now]==low[now]) &#123; cnt++; do &#123; id[stack[top]]=cnt;w[cnt]++; vis[stack[top]]=false;top--; &#125;while(stack[top+1]!=now); &#125;&#125;inline void SPFA(int id)&#123; memset(vis,false,sizeof(vis)); int hed=0,til=1; que[1]=::id[1];vis[que[1]]=true;dist[id][que[1]]=w[que[1]]; while(hed!=til) &#123; hed=(hed+1)%maxn;vis[que[hed]]=false; for(int j=lnk[id][que[hed]];j;j=nxt[id][j]) &#123; if(dist[id][que[hed]]+w[son[id][j]]&gt;dist[id][son[id][j]]) &#123; dist[id][son[id][j]]=dist[id][que[hed]]+w[son[id][j]]; if(!vis[son[id][j]]) &#123; vis[son[id][j]]=true; til=(til+1)%maxn; que[til]=son[id][j]; &#125; &#125; &#125; &#125;&#125;int main()&#123; n=read();m=read(); for(int i=1;i&lt;=m;i++) &#123; int a=read(),b=read(); add_e(a,b,0); &#125; for(int i=1;i&lt;=n;i++) if(!dfn[i]) Tarjan(i); for(int i=1;i&lt;=n;i++) &#123; for(int j=lnk[0][i];j;j=nxt[0][j]) &#123; if(id[i]!=id[son[0][j]]) &#123; add_e(id[i],id[son[0][j]],1); add_e(id[son[0][j]],id[i],2); &#125; &#125; &#125; SPFA(1);SPFA(2); for(int i=1;i&lt;=cnt;i++) for(int j=lnk[2][i];j;j=nxt[2][j]) if(dist[1][i]&amp;&amp;dist[2][son[2][j]]&amp;&amp;dist[1][i]+dist[2][son[2][j]]-w[id[1]]&gt;ans) ans=dist[1][i]+dist[2][son[2][j]]-w[id[1]]; printf("%d\n",ans); return 0;&#125;]]></content>
      <categories>
        <category>强联通分量</category>
      </categories>
      <tags>
        <tag>DAG</tag>
        <tag>最短路</tag>
        <tag>Tarjan</tag>
        <tag>强联通分量</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「HNOI2016」树]]></title>
    <url>%2F2019%2F01%2F05%2F%E3%80%8CHNOI2016%E3%80%8D%E6%A0%91-Solution%2F</url>
    <content type="text"><![CDATA[骚年，来看看这棵 真•树套树 吧！ 传送门洛谷 BZOJ 题解蒟蒻我定睛一看，一共有$10^{10}$个点，立马把蒟蒻我给吓到了QwQ。显然这是一道毒瘤题。我深深地感受到了出题人的恶意(然而我还是太菜了，像XHW这种dalao就可以想着要把出题人阿掉，我却不行)。 既然有这么多点，肯定是存不下的。因为每次操作都是copy一整颗子树，所以我们可以用一种叫做 真•树套树 的方法来解决呢poi。 我们构造大树时，令每一个大节点都对应模板树中的一整棵子树，并对新树重新编号，就像这样（样例）： 然后我们定义两个大节点之间的边的变权为两个大节点所包含的树的树根之间的距离。如上图中大节点1和2之间的边权为2,1与3之间的边权为3。 每一个大节点还需要存储以下信息： S[],T[]：该大节点包含的小节点的编号区间的起点和终点，如上图节点1的编号区间是[1,5]，节点2是[6,8]，节点3是[9,9]。 pre[]：该大节点对应的是模板树中哪一个节点的子树，如pre[1]=1，pre[2]=4，pre[3]=3。 lnk[]：该大节点挂在大树中的哪一个节点底下，如lnk[2]=3，lnk[3]=2。 以及常见的倍增LCA所需的信息。 还需要写几个函数： int GetRoot(long long u);用于查找小节点u所在的大节点。构造好S[],T[0]后，二分即可实现。 int GetPre(long long u);用于查找小节点u在模板树中对应的是哪个节点。假设小节点u在大节点rt里，那么根据题意，我们要找的就是rt对应的模板树的子树中该子树编号第$u-S[rt]+1$小的节点。这个我们可以把模板树一巴掌拍扁求个DFS序，然后用主席树解决（不会主席树的童鞋戳这里）。 int GetDist(int u,int v);用于求模板树上的节点u,v之间的距离。LCA解决。 然后就可以开始考虑如何计算答案了。 计算答案的主要思想就是在大树上通过倍增LCA求解，但是与普通LCA不同的是，不能纯粹地就在大树上LCA，需要注意很多细节。比如当再跳一步就跳到最近的大节点公共祖先时，不能马上往上跳，而需要往上跳一小步后转到模板树上去LCA。因为计算答案的细节，劳资%@#@￥%(文明靠大家)地交了4次才AC(不过好像也不算多)。 这样这题就解完了。时空复杂度都是大约$\Theta(超大常数*n\log n)$呢poi。 总结&amp;反思这是一道十分毒瘤的代码题(但是在某些dalao眼里就是送分题)，思维难度一般，但蒟蒻我前前后后一共花了3个多小时才AC(听说隔壁XCW一看题就秒掉了)QwQ。这道题很好地反映出蒟蒻我的代码实现能力还是太差，可能是由于做题太少的缘故。我虽然很菜，但是如果ZJOI2019真的出了像这样的一道题(或者类似于猪国杀什么的)，空有想法却没时间写代码和调试，那可就亏大发了QwQ。 代码蒟蒻我为了避免变量重名，于是开了两个namespace（不知代码是更好看了还是更丑了）。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;typedef long long LL;const int maxn=100005,LOG=20;int Q;inline LL read()&#123; LL ret=0,f=1;char ch=getchar(); while(ch&lt;'0'||ch&gt;'9')&#123;if(ch=='-')f=-f;ch=getchar();&#125; while(ch&gt;='0'&amp;&amp;ch&lt;='9')&#123;ret=ret*10+ch-'0';ch=getchar();&#125; return ret*f;&#125;struct ChairmanTree //封装好的主席树&#123; int tot,T[maxn]; struct Node&#123;int L,R,Sum;&#125;Tree[maxn*LOG]; int Build(int L,int R) &#123; int rt=++tot,mid=L+R&gt;&gt;1; if(L&gt;=R) return rt; Tree[rt].L=Build(L,mid); Tree[rt].R=Build(mid+1,R); if(rt==1) T[0]=rt; return rt; &#125; int Update(int num,int pre,int L,int R) &#123; int rt=++tot,mid=L+R&gt;&gt;1; Tree[rt].L=Tree[pre].L;Tree[rt].R=Tree[pre].R;Tree[rt].Sum=Tree[pre].Sum+1; if(L&gt;=R) return rt; if(num&lt;=mid) Tree[rt].L=Update(num,Tree[pre].L,L,mid); else Tree[rt].R=Update(num,Tree[pre].R,mid+1,R); return rt; &#125; int Query(int u,int v,int k,int L,int R) &#123; int mid=L+R&gt;&gt;1,x=Tree[Tree[v].L].Sum-Tree[Tree[u].L].Sum; if(L==R) return mid; if(x&gt;=k) return Query(Tree[u].L,Tree[v].L,k,L,mid); else return Query(Tree[u].R,Tree[v].R,k-x,mid+1,R); &#125;&#125;CT;namespace TemplateTree //模板树&#123; int n,father[maxn][LOG],dep[maxn],idx,que[maxn],S[maxn],T[maxn],tot,lnk[maxn],son[maxn*2],nxt[maxn*2]; inline void add_e(int x,int y)&#123;tot++;son[tot]=y;nxt[tot]=lnk[x];lnk[x]=tot;&#125; void Build(int now,int fa) //把树上的一些信息构造好 &#123; S[now]=++idx;que[idx]=now;father[now][0]=fa;dep[now]=dep[fa]+1; for(int i=1;i&lt;=16;i++) father[now][i]=father[father[now][i-1]][i-1]; for(int i=lnk[now];i;i=nxt[i]) if(son[i]!=fa) Build(son[i],now); T[now]=idx; &#125; inline void BuildCT() //初始化主席树 &#123; CT.Build(1,n); for(int i=1;i&lt;=n;i++) CT.T[i]=CT.Update(que[i],CT.T[i-1],1,n); &#125; inline void Input() //读入数据 &#123; for(int i=1;i&lt;n;i++) &#123; int a=read(),b=read(); add_e(a,b);add_e(b,a); &#125; Build(1,0);BuildCT(); &#125; int GetDist(int u,int v) //LCA求亮点间距离 &#123; int ret=0; if(dep[u]&lt;dep[v]) swap(u,v); for(int i=16;i&gt;=0;i--) if(dep[father[u][i]]&gt;=dep[v])&#123;ret+=(1&lt;&lt;i);u=father[u][i];&#125; for(int i=16;i&gt;=0;i--) if(father[u][i]!=father[v][i])&#123;ret+=(1&lt;&lt;i+1);u=father[u][i];v=father[v][i];&#125; if(u==v) return ret; return ret+2; &#125;&#125;namespace BigTree //大树&#123; int n,m,father[maxn][LOG],dep[maxn],pre[maxn];LL dist[maxn][LOG],S[maxn],T[maxn],lnk[maxn],cnt; inline int GetRoot(LL u) &#123; int L=1,R=n,mid; while(L&lt;=R) &#123; mid=L+R&gt;&gt;1; S[mid]&lt;=u?L=mid+1:R=mid-1; &#125; return R; &#125; inline int GetPre(LL u) &#123; int rt=GetRoot(u); return CT.Query(CT.T[TemplateTree::S[pre[rt]]-1],CT.T[TemplateTree::T[pre[rt]]],u-S[rt]+1,1,TemplateTree::n); &#125; inline void Build() //初始化大树 &#123; n=1;dep[1]=1;pre[1]=1;S[1]=1;T[1]=TemplateTree::n;cnt=T[1]; for(int i=1;i&lt;=m;i++) &#123; int fr=read();LL to=read();int rt=GetRoot(to); n++;dep[n]=dep[rt]+1;lnk[n]=to;pre[n]=fr;S[n]=cnt+1;T[n]=cnt+TemplateTree::T[fr]-TemplateTree::S[fr]+1;cnt=T[n]; father[n][0]=rt;dist[n][0]=TemplateTree::dep[GetPre(to)]-TemplateTree::dep[pre[rt]]+1; for(int j=1;j&lt;=16;j++)&#123;father[n][j]=father[father[n][j-1]][j-1];dist[n][j]=dist[n][j-1]+dist[father[n][j-1]][j-1];&#125; &#125; &#125; inline LL Solve(LL u,LL v) //计算答案(写的真丑QwQ) &#123; LL ret=0;int rtu=GetRoot(u),rtv=GetRoot(v); if(rtu==rtv) return TemplateTree::GetDist(GetPre(u),GetPre(v)); if(dep[rtu]&lt;dep[rtv])&#123;swap(u,v);swap(rtu,rtv);&#125; ret+=TemplateTree::dep[GetPre(u)]-TemplateTree::dep[pre[rtu]];u=rtu; for(int i=16;i&gt;=0;i--) if(dep[father[u][i]]&gt;dep[rtv])&#123;ret+=dist[u][i];u=father[u][i];&#125; if(GetRoot(lnk[u])==rtv) return ret+1+TemplateTree::GetDist(GetPre(lnk[u]),GetPre(v)); ret+=TemplateTree::dep[GetPre(v)]-TemplateTree::dep[pre[rtv]];v=rtv; if(dep[u]&gt;dep[v])&#123;ret+=dist[u][0];u=father[u][0];&#125; for(int i=16;i&gt;=0;i--) if(father[u][i]!=father[v][i])&#123;ret+=dist[u][i]+dist[v][i];u=father[u][i];v=father[v][i];&#125; u=lnk[u];v=lnk[v];ret+=2; return ret+TemplateTree::GetDist(GetPre(u),GetPre(v)); &#125;&#125;int main() //好简洁的主函数&#123; TemplateTree::n=read();BigTree::m=read();Q=read(); TemplateTree::Input();BigTree::Build(); while(Q--) printf("%lld\n",BigTree::Solve(read(),read())); return 0;&#125;]]></content>
      <categories>
        <category>树上问题</category>
      </categories>
      <tags>
        <tag>树上问题</tag>
        <tag>LCA</tag>
        <tag>主席树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[主席树（可持久化线段树）]]></title>
    <url>%2F2019%2F01%2F04%2F%E4%B8%BB%E5%B8%AD%E6%A0%91%EF%BC%88%E5%8F%AF%E6%8C%81%E4%B9%85%E5%8C%96%E7%BA%BF%E6%AE%B5%E6%A0%91%EF%BC%89%2F</url>
    <content type="text"><![CDATA[骚年，你需要一棵主席树！它会赐予你力量！ 传送门洛谷的主席树模板题 正文引入问题我们可能时常会遇到这样的一类问题：给定一个序列$A$和若干组询问，每次给定一个区间$[L,R]$和一个参数$k$，问序列上该区间中第$k$大的元素是多少。 对于这类问题，暴力算法显而易见(但是会T飞)。一个很好的解决办法就是用主席树(其实洛谷上的这道模板题不强制在线，分块+莫队可以AC，还跑得贼快)。 说一句题外话，主席树这种数据结构据说是一位名字缩写是HJT的神仙在考场上现场yy出来的，而HJT正是新中国历史上一位著名主席的名字缩写，因此得名。 考虑初始版本首先请确保你已经掌握普通线段树的写法，不会的童鞋请自行Ctrl+W。 我们建$n$权值棵线段树，第$i$棵线段树需要维护序列$A_1$~$A_i$中，每个权值出现的次数。比如说第$i$棵线段树上的一个节点管辖的权值区间是$[S,T]$，该节点需要储存满足$A_j\inS,T$的元素$A_j$的个数。可以将这些线段树一开始就构造好。 当进行询问的时候，如果当前的询问区间是$[L,R]$那么我们就把第$L-1$棵线段树和第$R$棵线段树拎出来，根据容斥的原理，将两棵线段树每个节点的权值相减就能得到一颗有我们想要用的包含$A_L$~$A_R$的信息的权值线段树。 然后我们就在这棵线段树上计算答案。 首先先遍历树根，假设当前节点管辖的权值区间是$[L,R]$，权值在该区间内的元素的个数和是$sum$。 如果$sum\leq k$，那么遍历当前节点的左儿子。 否则将$k$的值减去$sum$，然后遍历右儿子。 循环以上步骤，直到$L=R$，此时的$L$就是答案。 完善初始版本说真的，初始版本又难码又慢，比暴力算法还垃圾QwQ 现在考虑完善一下初始版本，让它成为一棵真正的主席树！ 首先在询问的时候，不需要每次都重构一棵线段树，用两个指针同时在两棵线段树上遍历，查个数的时候再相减就行了。 其次，如果真的开$n$棵完整的权值线段树，内存不炸才怪QwQ。 我们发现，第$i$棵权值线段树是在继承第$i-1$棵的信息的基础上，再添加第$i$个元素的信息。而根据线段树的性质，每进行一次修改，最多只会改变$\log n$个节点的信息。所以我们动态开点，在开第$i$棵线段树时，只新开修改过的节点，并把新开的节点直接接到没有修改过的已有节点上就可以了QwQ。骚年，你感受到了可持久化的力量了吗？ 还有，由于元素的权值可能很大，我们需要将原序列先离散化。 这样，我们就成功地把时间复杂度和空间复杂度都下压至$\Theta(n\log n)$的水平。主席树万岁！ 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include&lt;map&gt;#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;const int maxn=200005,LOG=20;int n,m,cnt,A[maxn],B[maxn];map&lt;int,int&gt; H;inline int read()&#123; int ret=0,f=1;char ch=getchar(); while(ch&lt;'0'||ch&gt;'9')&#123;if(ch=='-')f=-f;ch=getchar();&#125; while(ch&gt;='0'&amp;&amp;ch&lt;='9')&#123;ret=ret*10+ch-'0';ch=getchar();&#125; return ret*f;&#125;struct ChairmanTree //封装大法好&#123; int tot,T[maxn]; struct Node&#123;int L,R,Sum;&#125;Tree[maxn*LOG]; int Build(int L,int R) //在开始添加信息之前，先初始化 &#123; int rt=++tot,mid=L+R&gt;&gt;1; if(L&gt;=R) return rt; Tree[rt].L=Build(L,mid); Tree[rt].R=Build(mid+1,R); if(rt==1) T[0]=rt; return rt; &#125; int Update(int num,int pre,int L,int R) //添加信息 &#123; int rt=++tot,mid=L+R&gt;&gt;1; Tree[rt].L=Tree[pre].L;Tree[rt].R=Tree[pre].R;Tree[rt].Sum=Tree[pre].Sum+1; if(L&gt;=R) return rt; if(num&lt;=mid) Tree[rt].L=Update(num,Tree[pre].L,L,mid); else Tree[rt].R=Update(num,Tree[pre].R,mid+1,R); return rt; &#125; int Query(int u,int v,int k,int L,int R) //询问 &#123; int mid=L+R&gt;&gt;1,x=Tree[Tree[v].L].Sum-Tree[Tree[u].L].Sum; if(L==R) return mid; //找到了 if(x&gt;=k) return Query(Tree[u].L,Tree[v].L,k,L,mid); //分类讨论 else return Query(Tree[u].R,Tree[v].R,k-x,mid+1,R); &#125;&#125;CT;int main()&#123; n=read();m=read(); for(int i=1;i&lt;=n;i++) A[i]=B[i]=read(); sort(B+1,B+1+n);cnt=unique(B+1,B+1+n)-B-1; //离散化 for(int i=1;i&lt;=cnt;i++) H[B[i]]=i; CT.Build(1,cnt); for(int i=1;i&lt;=n;i++) CT.T[i]=CT.Update(H[A[i]],CT.T[i-1],1,cnt); while(m--) &#123; int L=read(),R=read(),k=read(); printf("%d\n",B[CT.Query(CT.T[L-1],CT.T[R],k,1,cnt)]); &#125; return 0;&#125; 其他其实主席树也可以维护带修改操作的序列，但是蒟蒻我现在还不会QwQ。]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>线段树</tag>
        <tag>主席树</tag>
        <tag>可持久化</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[XZY的女装flag(捂脸]]></title>
    <url>%2F2018%2F12%2F31%2FXZY%E7%9A%84%E5%A5%B3%E8%A3%85flag%2F</url>
    <content type="text"><![CDATA[由于一些原因，本文禁止访问，除非你能猜到密码 Incorrect Password! No content to display! U2FsdGVkX1+yMHSaMH773KQqNeYT2C/zP1IpjTZkKNXe8kIa3MpFBZVzIhB/ryLIA7h8UuiTA/DN2iwtdpEEAFgFfXVNQ0P+NI5MyNiiinY9i5ABGJEC2f7AhrIhtv/NtvWwmEe1b4Ro6EYvKoRzPRNPJf8hxOZwZQbap8n6Em4VLaNi5ay98P5uYdAfqfHaPSZex6v8j26OgbUwQUXClJKC0YOM9RqiWHUmivRYdm/dB8hTU9gA9FV7siZZV1MMFCR8shVTeC5GVwstDj32ackAARglTdladD06gcvVjKjo43PG44SweLPu4ACGeUPV/giz+SJ8SQi/Zk6JqsKteVdpmLfBFoSYpqXFloHFRzIzLAvYz76OFYMWsJEeoVTjoBBJ7wssBMQ6pJMibmteIQ1/iTfwo+Y+TTBMN+zb7YYSUAxxJijcK09SMJIt03yR2GkPZypEtOIDKhvNxYu26cmRYRwD6CROP0kvSVDr5gz06ntT8yD3P46HkxGyrSJP3G8pHghzzleV/Udv1UrzMRu9GnrwOOAyUC+kU8+sK+VRJ7qTnykXUBAxT0DxS9T3t71a7tnf3AoyWhiR1Oa0B2/P7EyQ7/xKZILkpwGv3fXEuAmwdgfjYKtdTb96LmGTIDX4H3AUYfJOZNEyu2uWUvk8GCMDXfA/jp435/bvCW3/UuZycv2+Dh0q+fmSBtrCbWd9iAZs7L31XiwP5t9o/UMvZaU7EjUlm+QjzUfxUQ6oXBg1kXSn8q/caeM1kwnnFLYMTis2YNn4JDtToPvCZWEzVrqlGMeVVRHEiLK0fbIG6BHIvwDyy4VP7hplpDPgbu4fcuw1bC3tHRp8qJR5Bl5JK7LtjSj9KXVEP4oHiciI63tAetbFz4vmnP1+O1e2alpGZVMCCuruwVFLApJaJ4Zk+KpHx0ayNQJrmVSez/WV092Y2WK3E3D1daUbkh2KxgxdM/XAPxdH/V7fpYpF/nZdp3nQfn5pcG5uuNsPa8mrXhJr60Nt6QS5k84ylt2a3jlLNkcZ89Iys8zbR7pAGAZjcVMDuUUJVdA/AQgh9c/HCFJdzZGdB+8Ezl30A8j4BfPJo2EuSviCO11WmyyUs9PW4xphavY8x7ZwClwMG1/OrCccKBWz3l7qmtlCJK6mhtY4FqhIuaEgFx5p8MRdlJs2NoBaaM4vH/HgguA4SCzqJ3/tXnycV5gMNOZcBiWoxkgwlGD6z07iptjfBmC/VJ/FxjH40AlvgmbplHgxTZ0I/MbYH/Qjkjq8qbczLCv2/dLv6cOtIJc5VDOjZPQNaQui8ySMPJlFtDaVjmB3ME1OP7HUjaqsmudhD4PWN1OSJxZpFisJ3nX/SQNuIm36B9Vhh6AKX0pruqEsftkArBNczYdcgwUrJYmQJOQ+SML/MfMHNyVrFIAOhSPbnP8h1p/nh7nsfH8U9QZ61CHTzF0uJvIrJtqwHbA7T00HCaFwC9h2u6eYzgVBmIWrBT3u2XaD4LN2JiFp+tE7pxgRXyAs6Q1NKE7CvYA+IdMg43wfCWUptra8SpvrQliM82XVVSDv3fUDgpZv5dXb6pMR2prQ59xFQNTxafV5Thal8CYlJf8a5V4VxALjVKF93YZycukFELaWbtL/pM8isfpXQ/kiY97u3V0FJxBHJY3xZyu0iFAsNH1nmgVlxnatpR9J85+kP383FrQMJTXzx03xFIBCUcb1xF0VYPhNX27HmiJuAVnj+0vDy/79hUCVOiG9YKXTgBW6rrhonVN3GsAzpLe2eBh1dT2Wkc+avia4uHcC3EPiWcvV7Rw7BkAxHgytHOHTNmgXRz56ygdDogmHdEw94jC194+5NeiO5GiXUUIRbWLd11HlkMaC/hx2oHC9Efss667yE91X1ZcRCYWLJcXq1Nh2EMYuVjcmXEld/9uKYU1jBGBDFdt9JBZ/ArBBqylMNM9RPHAPgPhFe5kP/4ORhgjyXkwTB3828b0Mvfv95gFvcUgvCS7FptgxptFSEtogv8vLkbja8NpkKdYiksuInP+CTBZRgQWanwi/iaT7PMUnzQJmZbw/WYVxBP9mb0zFf9y1ly9AD+S11ppjVi5xlmWn5H4mvn8SFV7LreK3+KnV5qo6Pjd7YN/PpxgHFD8Fx74jhUpzp1E4vVOh5lJdEXqMgsDVBf9ESZqfQFK+YSrjRUrf2zFLCeB/q7NWK+I40lFzwliEJm1e0/vXQsO/NlOk2PeIsSWd+sKpVg4sm6UZbBkPkbVYaX3CRBKdJc3WKsWx0mm4bg4dsWF/Wvmuxy76DfAH8lgVEg0ja/UZuR2dGZ4xF8LSylioUQ40jg5K7eHWehjsFDGi1TIsKK5ytAgPddgsoaFVoTxxYftZqdgQKD+/BbaoU5egOjSyzKXymbxVcF8WkV9QXw7O8YhphLGLJZ9Cx2J1F6QHsH++qEp5mma0eXArid5A9e9Zwg+ZejWU961sZrqqbHWp60T3uYtymP+/8swA+jmNmtqRpy6dVMJuvVemoKPjhnn17ksdl9RPoc7g6vSgK+6JmtaQhiOx2tkWUyNKgmLnBtmfpO5sGZru/fOzAg5rtahY16X/NwB9Q9nebyFoxcFQdAhl2c5/2R1Xp4pOea1RxxV7wh7/JupRT+TQxWL5xVMhm2XUdVDRzoXeHeE/caatGGYooosnkZVnqWfUizhqdyhio3qCNijacBcb0K2npSGTIc4Z2gAQITrcTFZRhaLQ9hbAUU5I97BR14iOd1D+euHKnblF10DqmpT1XTF2rHoNp9JgHPYgxAjGMYmJO6WDQoiT5JZjy1F4chvJMltDJe2Vn5wqp4YJUyM7tbQI328RwUqp/448HO+3Qi5amXsholxqut6L5YvmWDFE0xgEn6fGLi0/iemcgmA9EdXnLuk4mov23dlrq+ORqDKyBlj8asqTv7wEVdFdS2lOqV2w2DdnLy48/+AORDv+5cQayqFUWcSQfmIIp7ZLydBqqlJ+EdQiDH0WxgFflJcVTZmmfCqSs+NZx55W3vJXVo+BPoAdCP2wEfhGf2KG70lMgqZHL7Xjn94MyInpE3x64LjaLOxrIAaWkZVz1lUqcp0AXjzQbKT3Fmsu2kJlQgUpdyR6tfHVJlZ8n2FQkF2dLEK3ehJ7J2zREQvWCML/uIVhjlVlbUTHcvfeaNeOY7wgURq5XxKCsjTb8nx/MAzxnWrF+ExRZwn8Oo5A5FpqdX+3NPnlKFbY5+8yE9isE7QzpgrnW9I6F7j3mA1kgcmjLghYXaTrA5QQWtmrPLBagb0VynOpybAkwoVZlBbRelIv1wiiqspBaypbZVMK9302rK6Ov3vuwGKBd1gDUn0FPdknGNY9uJ56833ht9e9wT3CW0XBhuiJj5GvqT+/wLXmcAWf3wxQ9qSHGRMuMpnyzfACh1wmdIPwToGUULT2ImOxJ2vOxo0irYhfnaOGodJqgubGTQpj35IYKuIzwSZ9VhlZgKf96xKPhigXBuFWkCqZmSlvsA0Y8u8vB4ImPgWWSSI0vOLiduEfCnqTIHbD2Y+MVl+BXWcHlPm+tNBfvhCBZJJfAinx+osNV7MOxjtXQPymQgkym7Eu+37tycNPOAKhYSR3GzOe3hyodVOxBVgw/vgZMLN3rF/oFzX6mQBsNunOaAL4bQNU3MTY4Aa+6unltB9UzApCPue2w/L941FBFxTtcAgkHY4eG9mLf+IRa+pcU0OSI/6C8tMeu6URG2/GM0W4O5Gib0jfsxMuB9UgUnmXD35kXrFopMqtFoCi9OYPQvJdsI39PdqqQ3Fwih/o7SbzKof1kYAYERaS5kZJj/MSnd9BHsy4TmVK/NF00w/3Ailp0G5FdEc3VUktwKi1neXydIlwkqU24dK6dzIO5SN2VehpArbggUui3YsfTyKXXR7vBRR6vaB+CkODghQMD1KVHXi8np2L0njZzRfJUBOGwU8B78/AjO+UNf6wriGdpqPJ3JenJWvyvZ15mW43N9Z/B2kK82C9SBLtVe7vgSZ6wI6qP5aFcCBq+9L2y5I46kajJJOcGnCjjZUmDDjjUXGXcNP/0+Bw2fLBtYM+bMlTcefkPoJWp1G4lPxVpFv4V16t8QB3n9v6+xgwsQAsg1aMyTILlih4sLsnVcMUHvcTEiE/YZPr0aAFXtQjx2zXcLLphZS0pfoUxVV1kpQsX3ZNnPBoFjJ4wnT8m6lGD09AcDSN+Q9/gKNtpNTcL5bQ/1QWsAUIDaJPmv6mPhwOP+Pzo9mFPpqhSi/yHVOzxsDj4tKQKw20IhiJgJDC24VldhuakrJ22QCOnTa8mPATVPCWnkd8+uzE9GUbSwf9s5BC6KuNI41pXM1km0l8De00dGnuG1tUpTZAyEMuehcj0jpoKBQUsyc6x2cstnaFd5+1pzkBuruLM35Xiz7Hf7zzP9tvM/dywZhrR0JTEWYH6zIkLy6LCnhMhOPijqiUpIGLPJNdFZ7QENz7b7zGbfXT/WrcQVZoDbEgkEh7FGTdyZSNGc0rKoH8CBxPFt0LOGdCDBGD6rJKDiGNTyeH85lQyTc6Kxp64LQkrTmyv6DyxsHmOEd7C3y6Hji229zl520ZL6RuPuMRuDop83C1hH8hUfgeIjsIscpMAnBAOx6DM2rnWK6SzqXjg1DvDvmz+voTmzukK8KcXAyqdlE/GeCTknzbPrOaudNAmhffGmmm4OzJcuaQR2wkewAY01yoQdMldqAQUGJs/mXzm/XPXORtzm/zpzU2EqgHNMlKZr553JszfqU9Tlu64ewhcBZSd/waSuFVhoB1ewmH0m/eIgjJ+3E8GYsib+P1/Jgqg8OLGwvBAjEWq3kh5Wx9rjA7vXmcP4Vj5tsvIYWzdcgRKU23qE4VYHWFIeBwjsOHEgXMNaTEMSotFvWTnuSdhJ/8ctYjcQqe727ipco7nxxxqApKKKSPsz/wkOtTwLtqNRIYmWdn+5iCiW60dghvovaKKqMSTbT5E3TjUxq/CGxLin7XvBmCop6TlDOMso20jHPiqQ9JBVgV8ypdydky3MhTpeyl9VibtZLcwAqQKi8eQbEfpqjgKwfCu4nteONBe2FUg5fZQL8bQFFEKsZyQyuTk2bNkdHdEF7Kp0G6VaPhfDWv9rF+d4djutknJSx425QYKKGD/elsDjl75mCugNvRDj6JnNZgVtSSmlx8b3SEyAP8tbqEVu0q81kqNMmO1di41gLhk/QSHQ7PxeYxp2ZOCIW1yFlnVFTaHjJGzU5vzWeetxUhITTnq0lLj3jTbR15A7SzU06WG1w7za5daiAf/1E/+Nax5Yq6adodd1j32QJL6dUI/twqiBbhBolt8Bj0M6cBV2Bz14ym1wLc1OnsYoGrFjpVRx34ugXEieB/ClSUXFmmtpdguWA2BdzLegt62AQWuNML7nKT1PQTYeLIas8aXstqmKGe8llOuZGuu+MilcN9NT5YTYCRY/+23F3fPIYQlRqb5f/9WrgsGrILPEdVl3F2f24zfwer64Zt1IR20anZlydbnn0HmJ1OCDGSOjAOMFJun0bT0q6dCG9bQfCIAXUHrlkvAdouUbQijyublmrc+sT64IRCXzai+S9pY+Rk8nyJBAWYcG8Q2/aZzrIfszvRSEQil0oA3j5tmr4qEjLcooO6L3R0IDvC9EUxyEUh3nr/2G0AxrnPxv17XwgnqPGZT5MCtSsn75wvAzRgczOFE8Qa54YzFxZRHioGploQ+38OYyYna8Y19AB2AoiYfa7uxkrCrrDJjk5O6sj1JoyZbouoTkfjD18nBJRLCn8AiMOwVZxDDiDkpkM5aYULn/giZfkSXP1kdrVWjEuRGvbJ3cYsFAjCytAeNEiCSUoFJRMCvwmlekX29M0mSyeo3nCOM2DlVdXWuUvXMA9cSAq55n3wjZPE0W3krPtr3VGJBg4l6GRSPl6ya+Oiun8hNLT4PDXVIo2ClJRoGdmeuWrz/9EWOoyo2lcZEYTLRfVyj7wpk7Ps+OAkfWs6KMvoxNlE2krjHrbVLYW8y1lT2aAap0hThilFGJlUz3hVcErBjr2n1cZaqyDTNxdTK5ZjX4JRgOaSq5WDM+rV0d8MhNaWYL2ZJfaQaEOcKm4fMjcYQ5YrcOixQ6ALOUovSC98T1zOe+iIbnAs2/QOQNcP2Q86NDVxCCK9sbW9tVVdYV5/mzwc4CzScjaDpY7NI6ZgnTGqcBuRzFLVrLQyS0e15/nMX4r+WxKgQJihjJTHU4P6E9AZU5vyXDTCfEhUusA22k4e1xRzc05To32LP/u+aKzHsS/Vv8qeSoLImQ//KQI6VXt2K48cy585ELmRUSOILeh9XGRWhzYFHNV3x+yR4sC4gXSiYGvT1S3dRVKxPxHHCQqPEfmyRnfHIZtYMRCqS2QEx2QXH6Xz8dkGdiVskHT6piEcZZPda2caAp07Za8B8RUD26SHtfEOgygavCOPpX1Rw8nBYhl8oJ4/duFQGCoJuyFHnQszVddSapmbSLSDhpY4W8qZfDzbgary34jKZjDTuZHJBiAvcsjsGeh4ANHucyUyIwIo7Ei07Vd4fJAhGWbl6hIUaxGqSc+4DHZnVdf/YRD6KOP8Xbg/SoXT4JUJkCWtulp3qa1F0/K36AL3Bm999YntQbmPSeYFu+HXn0kBJAv/Ei3Y7idt4Swk+GIdPsErT6cWt93izaDxeX9fBnb9K854ukowGf8s26g5RH+flMtlCJJqm2je/qi+/vmX4ikDYUhwhTDkR9LDek//MN4E1Rm+9CQfCpKh04V/fNrggTlxkCUB/Xyyc8Seax6nPl9KE5zgUSObBmWh6zFdI+7Vud6LC9QQqtqp4ujJSBVERCbjVAyQSVphJSKBEpgHi3WnvwNoCiL5qNAXaCRnBFLlkLcKcIUSQQVgnpf20eZxqF0VJT+QzYV7nT7eal9gd8vrLzOWub5Q/XS2oUBg7Cm3omfe+wpn1sWmoGJNwlH4YpZWKqI/7+cStuDfhjRzCC78fKsGDSH+QC+AwHPkfwIk4cWoEV2dtLVC+RDiyZgwf3lFprVk59b99M+DMPUi4ELwUoXace8MvK7gNmxX8xPWGYL0aBsCbRhF3D6ppF7R9FmYqL+PnOKbQWugUM1zwmZm2tgT8zTlN2BZidIP3h2Ys0QehESwM0NS+QG6O9E1uwfqAn5sQq6En+ZJKLTTSVgovykd2MT24TtMzRsEa8PMOat498ngIv0caih4Hy3b7wJ13LqWRPTdQL8Pt402Da8pbMaK8Yp37m124agTs6XC8JCPYUSdLSXUPmL5isWFeSXh9jZsn6MOvy7qzXSQ5GrajxPLg/nGpgvB+JYEbd59SSKQEBlS3oqpjjqjWc6lhLMxfmuC2Ut3wLgx42AFg0aHqLenEanrZLWtgGXVe7cIeHCqr1VSIZupJA05Divv8B+adSZLmsZbGvrDEZZd4w3VeRMRyeGG2Shoa3lpjtYyf+w5DtFsSZCRjPeGVU4l88lPmilEzM6U+Q+3mmGMVzgQ5WEWE1lEW2+3WV5pjqbr54VqwifAa7ENXmyRSKxkAAFItm4vYvypFMbqIxydFS0l6CGpvYVohVmDh4uzKp5KsGdaAzxbvRlnl4mSJXD2ZnzOn7kw1ZKr2YW2ihPjemf1/LefaLeTUe4jHuIg+oxOWc/AxWmdwLZ7JLmK+zY=]]></content>
      <categories>
        <category>公告</category>
      </categories>
      <tags>
        <tag>flag</tag>
        <tag>女装</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「国家集训队」数颜色/维护队列]]></title>
    <url>%2F2018%2F12%2F27%2F%E3%80%8C%E5%9B%BD%E5%AE%B6%E9%9B%86%E8%AE%AD%E9%98%9F%E3%80%8D%E6%95%B0%E9%A2%9C%E8%89%B2%20%E7%BB%B4%E6%8A%A4%E9%98%9F%E5%88%97%2F</url>
    <content type="text"><![CDATA[什么？维护序列的题？当然是上莫队啦poi！ 传送门洛谷传送门 BZOJ传送门 题解很显然这是一道莫队的题呢poi！ 但是有修改操作QwQ。 怎么办呢poi？ 当然是写一个资瓷修改的莫队啦！(好像都是废话) 首先我们要把所有操作分成两坨，一坨修改操作，一坨询问操作。 并且我们需要预处理出进行每一个修改操作之前这个要修改的位置上的颜色。 还要预处理出进行每一个询问操作时已近完成了几个修改操作。 然后在莫队的时候，如果当前已经进行了的修改操作的个数与当前询问操作所记录的已经进行了的修改操作数不一致，暴力更新一下就行了呢poi！ 据说这样带修改的莫队只要把块的大小设置为$n^\frac{2}{3}$就能将时间内复杂度控制在可接受的范围内呢poi。 其他的按照普通莫队写就行啦poi！ 还有洛谷上这题数据比较强，如果不按玄学方法排序要吸个氧才能AC(也有可能是蒟蒻我的常数太大了QwQ)。 代码其实还挺好写的呢poi 还有不要问我为什么那么喜欢poi呢poi 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;const int maxn=50005;int n,m,m1,m2,S,A[maxn],B[maxn],Area[maxn],ans[maxn],L,R,now,ncnt,hsh[1000005];inline int read()&#123; int ret=0,f=1;char ch=getchar(); while(ch&lt;'0'||ch&gt;'9')&#123;if(ch=='-')f=-f;ch=getchar();&#125; while(ch&gt;='0'&amp;&amp;ch&lt;='9')&#123;ret=ret*10+ch-'0';ch=getchar();&#125; return ret*f;&#125;char GetChar()&#123; char ch=getchar(); while(ch!='Q'&amp;&amp;ch!='R') ch=getchar(); return ch;&#125;struct Query&#123; int L,R,id,cnt; bool operator &lt; (const Query&amp; b)const&#123;return Area[L]&lt;Area[b.L]||(Area[L]==Area[b.L]&amp;&amp;((Area[L]&amp;1)?R&gt;b.R:R&lt;b.R));&#125;&#125;Q[maxn];struct Update&#123;int P,C,lst;&#125;U[maxn];inline void inc(int num)&#123;if(!hsh[num]++) now++;&#125;inline void dec(int num)&#123;if(!--hsh[num]) now--;&#125;int main()&#123; n=read();m=read();S=pow(n,0.666666)+1e-10; for(int i=1;i&lt;=n;i++) Area[i]=(i-1)/S+1; for(int i=1;i&lt;=n;i++) A[i]=B[i]=read(); for(int i=1;i&lt;=m;i++) &#123; if(GetChar()=='Q')&#123;Q[++m1].L=read();Q[m1].R=read();Q[m1].id=m1;Q[m1].cnt=m2;&#125; else&#123;U[++m2].P=read();U[m2].C=read();U[m2].lst=B[U[m2].P];B[U[m2].P]=U[m2].C;&#125; &#125; sort(Q+1,Q+1+m1); L=1;R=1;hsh[A[1]]++;now=1; for(int i=1;i&lt;=m1;i++) &#123; while(R&lt;Q[i].R) inc(A[++R]); while(L&gt;Q[i].L) inc(A[--L]); while(R&gt;Q[i].R) dec(A[R--]); while(L&lt;Q[i].L) dec(A[L++]); while(ncnt&gt;Q[i].cnt) &#123; A[U[ncnt].P]=U[ncnt].lst; if(L&lt;=U[ncnt].P&amp;&amp;U[ncnt].P&lt;=R)&#123;dec(U[ncnt].C);inc(U[ncnt].lst);&#125; ncnt--; &#125; while(ncnt&lt;Q[i].cnt) &#123; ncnt++; A[U[ncnt].P]=U[ncnt].C; if(L&lt;=U[ncnt].P&amp;&amp;U[ncnt].P&lt;=R)&#123;inc(U[ncnt].C);dec(U[ncnt].lst);&#125; &#125; ans[Q[i].id]=now; &#125; for(int i=1;i&lt;=m1;i++) printf("%d\n",ans[i]); return 0;&#125;]]></content>
      <categories>
        <category>莫队</category>
      </categories>
      <tags>
        <tag>莫队</tag>
        <tag>分块</tag>
        <tag>带修改莫队</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「ZJOI2013」K大数查询|整体二分]]></title>
    <url>%2F2018%2F12%2F26%2F%E3%80%8CZJOI2013%E3%80%8DK%E5%A4%A7%E6%95%B0%E6%9F%A5%E8%AF%A2%20%E6%95%B4%E4%BD%93%E4%BA%8C%E5%88%86%2F</url>
    <content type="text"><![CDATA[什么？树套树？不存在的。 传送门洛谷传送门 BZOJ传送门 在您开始阅读本题解之前，蒟蒻我建议您先把题面多看几遍，并仔细阅读样例和样例说明。 我才不会告诉你蒟蒻我就是因为看错题面然后白忙活了一个小时。 题解据说本题可以用树套树解，但是树套树这种东西常数稍微一大就TLE，这位dalao的树套树就咕掉了。而且树套树对于蒟蒻我来说太*难了，所以我们需要整体二分这种东西。 首先确保您已经掌握普通二分的写法，不会普通二分的请自行Ctrl+w。 整体二分的主要思想就是把这一大坨询问一起处理。 首先让我们来考虑只有一个询问操作的情况： 二分权值(即答案)，每次分到一个$mid$，我们就把这个询问之前所有的有贡献的添加操作(即$c$值大于$mid$的添加操作)用一个支持区间修改的树状数组或者线段树预处理，然后我们就可以很快地得到区间$[a,b]$中权值大于$mid$的数的个数$tot$。如果$tot$小于这个询问操作的$c$值，那么我们就把$c$值减去$tot$，然后把之前产生过贡献的添加操作扔掉删除，并修改二分的边界值继续二分；否则直接修改二分的边界值继续二分即可。 好了现在再来考虑有一坨询问的情况。 方便起见，我们把询问操作和添加操作一起处理。设当前二分的值是$mid$，二分的权值区间是$[L,R]$要处理的操作区间是$[s,t]$。那我们先遍历一遍操作区间，如果当前遍历到的是有贡献的添加操作，就更新一下线段树；若果是询问操作，就在线段树上查询一下该询问区间内权值大于$mid$的个数$tot$，根据$tot$是否大于$c$并把操作分成两堆，然后递归分别处理两堆，直到$L=R$时$mid$就是当前所有询问操作的答案。(添加操作也要根据$c$值是否大于$mid$也一起分成两堆) 注意将操作分堆时每一堆内不要打乱操作的顺序。 时间复杂度$\Theta(n\log^2{n})$，常数是真的小QwQ。 代码貌似真的比树套树好懂 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697#include&lt;cstdio&gt;using namespace std;typedef long long LL;const int maxn=50005;int n,m,cnt,ans[maxn];inline LL read()&#123; LL ret=0,f=1;char ch=getchar(); while(ch&lt;'0'||ch&gt;'9')&#123;if(ch=='-')f=-f;ch=getchar();&#125; while(ch&gt;='0'&amp;&amp;ch&lt;='9')&#123;ret=ret*10+ch-'0';ch=getchar();&#125; return ret*f;&#125;struct Command&#123; int typ,L,R,id;LL C;&#125;Q[maxn],Q1[maxn],Q2[maxn];struct SegmentTree //一个普普通通的线段树&#123;private: struct Node&#123;LL Sum,Tag;&#125;Tree[maxn*4]; void PushUp(int rt)&#123;Tree[rt].Sum=Tree[rt*2].Sum+Tree[rt*2+1].Sum;&#125; void PushDown(int rt,int LC,int RC) &#123; Tree[rt*2].Tag+=Tree[rt].Tag;Tree[rt*2+1].Tag+=Tree[rt].Tag; Tree[rt*2].Sum+=LC*Tree[rt].Tag;Tree[rt*2+1].Sum+=RC*Tree[rt].Tag; Tree[rt].Tag=0; &#125;public: void RangeUpdate(int LL,int RR,int delta,int L=1,int R=n,int rt=1) &#123; if(LL&lt;=L&amp;&amp;R&lt;=RR)&#123;Tree[rt].Sum+=(R-L+1)*delta;Tree[rt].Tag+=delta;return;&#125; int M=L+R&gt;&gt;1; PushDown(rt,M-L+1,R-M); if(LL&lt;=M) RangeUpdate(LL,RR,delta,L,M,rt*2); if(M&lt;RR) RangeUpdate(LL,RR,delta,M+1,R,rt*2+1); PushUp(rt); &#125; LL RangeQuery(int LL,int RR,int L=1,int R=n,int rt=1) &#123; if(LL&lt;=L&amp;&amp;R&lt;=RR) return Tree[rt].Sum; int M=L+R&gt;&gt;1;::LL ret=0; PushDown(rt,M-L+1,R-M); if(LL&lt;=M) ret+=RangeQuery(LL,RR,L,M,rt*2); if(M&lt;RR) ret+=RangeQuery(LL,RR,M+1,R,rt*2+1); return ret; &#125;&#125;S;void BinarySearch(int L,int R,int s,int t) //整体二分&#123; if(L&gt;R||s&gt;t) return; int mid=L+R&gt;&gt;1,len1=0,len2=0; if(L==R) &#123; for(int i=s;i&lt;=t;i++) if(Q[i].typ==2) //只有询问操作才需要回答 ans[Q[i].id]=mid; return; &#125; for(int i=s;i&lt;=t;i++) &#123; if(Q[i].typ==1) &#123; if(Q[i].C&gt;mid) &#123; S.RangeUpdate(Q[i].L,Q[i].R,1); Q1[++len1]=Q[i]; //操作分堆 &#125; else Q2[++len2]=Q[i]; &#125; else &#123; LL tot=S.RangeQuery(Q[i].L,Q[i].R); if(Q[i].C&lt;=tot) Q1[++len1]=Q[i]; //操作分堆 else&#123;Q2[++len2]=Q[i];Q2[len2].C-=tot;&#125; &#125; &#125; for(int i=s;i&lt;=t;i++) //撤销操作，清空线段树 if(Q[i].typ==1&amp;&amp;Q[i].C&gt;mid) S.RangeUpdate(Q[i].L,Q[i].R,-1); int j=s; for(int i=1;i&lt;=len1;i++,j++) Q[j]=Q1[i]; for(int i=1;i&lt;=len2;i++,j++) Q[j]=Q2[i]; BinarySearch(L,mid,s+len1,t);BinarySearch(mid+1,R,s,s+len1-1);&#125;int main()&#123; n=read();m=read(); for(int i=1;i&lt;=m;i++) &#123; Q[i].typ=read(); if(Q[i].typ==2) Q[i].id=++cnt; Q[i].L=read();Q[i].R=read();Q[i].C=read(); &#125; BinarySearch(-n,n,1,m); for(int i=1;i&lt;=cnt;i++) printf("%d\n",ans[i]); return 0;&#125;]]></content>
      <categories>
        <category>整体二分</category>
      </categories>
      <tags>
        <tag>整体二分</tag>
        <tag>树套树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「HNOI2010」弹飞绵羊]]></title>
    <url>%2F2018%2F12%2F24%2F%E3%80%8CHNOI2010%E3%80%8D%E5%BC%B9%E9%A3%9E%E7%BB%B5%E7%BE%8A-Solution%2F</url>
    <content type="text"><![CDATA[什么？LCT？不存在的。蒟蒻我怎么可能会LCT。 传送门洛谷传送门(咕咕咕) 爆炸BZOJ传送门 题解听说这题的标算是LCT？我这么菜！怎么可能会LCT！！！看了一眼数据范围，很亲切啊！二话不说直接上分块！ 首先，按照分块的套路，把$n$个弹力装置分成若干个块(块的大小取$\sqrt{n}$即可)。然后需要提前构造好两个数组： 1：$step[]$。$step[i]$表示落到第i个弹力装置上的绵羊还需几次才能跳到下一个块里（或者被弹飞）。 2：$pos[]$。$pos[i]$表示落到第i个弹力装置上的绵羊在被弹出当前块后会被弹到哪一个位置上。 这两个数组可以一开始从后往前在$\Theta(n*\sqrt{n})$的时间复杂度内构造出来。(我才不会告诉你我写这个是为了测试markdown的数学公式)询问的时候借助这两个数组就可以在$\Theta(\sqrt{n})$的时间复杂度内通过模拟计算出答案。 然后让我们再来考虑修改的问题。 自己思考一下，不难发现，修改了一个弹力系数之后，只有该块内的两个数组的值可能发生改变，然后从后往前暴力更新一下即可。 代码比LCT短了不少 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include&lt;cmath&gt;#include&lt;cstdio&gt;using namespace std;const int maxn=200005;int n,m,S,Area[maxn],K[maxn],step[maxn],pos[maxn];inline int read()&#123; int ret=0,f=1;char ch=getchar(); while(ch&lt;'0'||ch&gt;'9')&#123;if(ch=='-')f=-f;ch=getchar();&#125; while(ch&gt;='0'&amp;&amp;ch&lt;='9')&#123;ret=ret*10+ch-'0';ch=getchar();&#125; return ret*f;&#125;inline void Solve(int s)&#123; int p=s+K[s],ret=1; while(Area[p]==Area[s])&#123;p=p+K[p];ret++;&#125; step[s]=ret;pos[s]=p;&#125;inline void Update(int s)&#123; int p=s+K[s],ret=1; while(Area[p]==Area[s])&#123;p=p+K[p];ret++;&#125; step[s]=ret;pos[s]=p; for(int i=s-1;Area[i]==Area[s];i--) if(Area[i+K[i]]==Area[i]) &#123;step[i]=step[i+K[i]]+1;pos[i]=pos[i+K[i]];&#125;&#125;inline void Query(int s)&#123; int p=s,ret=0; while(p&lt;=n)&#123;ret+=step[p];p=pos[p];&#125; printf("%d\n",ret);&#125;int main()&#123; n=read();S=sqrt(n)+1e-10; for(int i=1;i&lt;=n;i++) Area[i]=(i-1)/S+1; for(int i=1;i&lt;=n;i++) K[i]=read(); for(int i=n;i&gt;=1;i--) Solve(i); m=read(); while(m--) &#123; int a=read(),b=read()+1; if(a==1) Query(b); else&#123;int c=read();K[b]=c;Update(b);&#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>分块</category>
      </categories>
      <tags>
        <tag>分块</tag>
        <tag>LCT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[公告]]></title>
    <url>%2F2018%2F12%2F22%2F%E5%85%AC%E5%91%8A%2F</url>
    <content type="text"><![CDATA[什么？女装发blog？不存在的… 欢迎访问蒟蒻我的blog. 蒟蒻我万年不更新的Blog终于在网站开通后n个星期准备开始更新了。。。 蒟蒻我和巨佬XXC女装的事，想必各位dalao都知道了。 关于女装，可说来话长了。是这么一回事： NOIP2018 day2考完出场，ZJ初三小蒟蒻我感觉两腿绵软无力，很显然我这只蒟蒻是考boom了。day2 T1我傻逼样得想用一种奇妙的方法来解决这棵基环外向树，然后写了两个小时还没有结果，CCF给的大样例也过不了。出了考场和各位大佬一起交流了一下才发现暴力枚举删掉的边然后重构图即可。因为T1没做出来，T2的45分结论分也没拿到。自己估摸了一下，不该丢的分一共丢了85分，预估不翻车的情况下分数为应该379，省一GG… 事后，蒟蒻我写了一首诗来表达自己内心的想法(我有一句mmp不知当不当讲)： 于是乎，我便当众立了一个flag：我CCF评出来400分以上就那啥！ 然鹅等到CCF出成绩的那天，由于CCF的数据非常友好，我总分399(CCF万岁) 但是成绩出来之后，跟各位dalao一讨论，参考了一下CCF的文件，发现蒟蒻我省一仍然没有太大希望qwq。 于是乎，我又当众立了一个flag：我省一就那啥！ 12.04，CCF发布获奖名单，我惊奇地发现CCF修改了省一获奖名额的分配方案。CCF万岁万岁万万岁。蒟蒻我先是高兴了一会儿，然后想起了之前立的flag… 我&amp;^%￥#T@(文明你我他) 然后就没有然后了… 为了不让Matsusaki这位dalao破费，我决定等XXC巨佬女装后把衣服借来用用。 听说我已近被安排上了？好像就在81022018年12月30/31号？ XXC巨佬的blog(据说这里会放上他她的女装图)]]></content>
      <categories>
        <category>公告</category>
      </categories>
      <tags>
        <tag>女装</tag>
        <tag>公告</tag>
      </tags>
  </entry>
</search>
