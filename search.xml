<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[「HNOI2006」马步距离]]></title>
    <url>%2F2019%2F01%2F28%2F%E3%80%8CHNOI2006%E3%80%8D%E9%A9%AC%E6%AD%A5%E8%B7%9D%E7%A6%BB-Solution%2F</url>
    <content type="text"><![CDATA[这题有点水QwQ… 传送门洛谷P2060 BZOJ1193 题解首先很显然不能直接贪心，直接贪心有可能WA，所以要写个DFS之类的东西来搜。 但是数据稍微有点大QwQ，搜不出来。 不难发现，当距离比较远时直接贪心地奔着目标走是肯定没问题的。 所以距离远时贪心，距离近时爆搜就行了QwQ。 其实手玩就能把表打出来。 代码打表万岁 123456789101112131415161718192021222324252627#include&lt;cstdio&gt;using namespace std;const int f[7][7]=&#123; &#123;0,3,2,3,2&#125;, &#123;3,2,1,2,3&#125;, &#123;2,1,4,3,2&#125;, &#123;3,2,3,2,3&#125;, &#123;2,3,2,3,4&#125;&#125;;int xp,yp,xs,ys,x,y,ans;int ABS(int x)&#123;return x&lt;0?-x:x;&#125;int main()&#123; scanf("%d%d%d%d",&amp;xp,&amp;yp,&amp;xs,&amp;ys); x=ABS(xp-xs);y=ABS(yp-ys); while(x&gt;4||y&gt;4) &#123; if(x&lt;y)&#123;x--;y-=2;&#125; else&#123;x-=2;y--;&#125; if(x&lt;0) x=-x;if(y&lt;0) y=-y; ans++; &#125; ans+=f[x][y]; printf("%d\n",ans); return 0;&#125;]]></content>
      <categories>
        <category>贪心</category>
      </categories>
      <tags>
        <tag>贪心</tag>
        <tag>DFS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「BJOI2014」想法]]></title>
    <url>%2F2019%2F01%2F24%2F%E3%80%8CBJOI2014%E3%80%8D%E6%83%B3%E6%B3%95-Solution%2F</url>
    <content type="text"><![CDATA[什么鬼？省选也出这种玄学随机算法题？ 传送门洛谷P4581 题解首先这题一看就很不可解。 所以上随机算法（人家题面都告诉你了QwQ）。 写之前先膜拜一下dalao，保佑AC。 sto 黄霖 orz 对于一个节点，将所用能走到它的叶子节点都存下来是不现实的，所以我们只存$k$个。并且我们要先为每个叶子节点i随机一个权值$W_i$，满足$W_i \in [1,RANDMAX]$。对于每个非叶子节点，我们需要存下所有能走到个节点的叶子节点的权值的前$k$小。设这个节点的答案为$ans$，第$k$小权值为$F_k​$根据期望可得$$\frac{F_k}{RANDMAX}=\frac{k}{ans}$$故有$$ans=\frac{k*RANDMAX}{F_k}$$令$k=50$，多为叶子节点随机几套权值求平均值，吸个氧，放个大悲咒，选个好种子，你就能AC了。 代码这是真的玄学QwQ 1234567891011121314151617181920212223242526272829303132333435363738394041424344#include&lt;cstdio&gt;#include&lt;cstdlib&gt;using namespace std;typedef long long LL;const int maxn=1000005,k=50;int n,m,son[maxn][2],w[maxn],num[maxn],f[maxn][55];LL ans[maxn];inline int read()&#123; int ret=0,f=1;char ch=getchar(); while(ch&lt;'0'||ch&gt;'9')&#123;if(ch=='-')f=-f;ch=getchar();&#125; while(ch&gt;='0'&amp;&amp;ch&lt;='9')&#123;ret=ret*10+ch-'0';ch=getchar();&#125; return ret*f;&#125;inline void Merge(int s1,int s2,int now) //从两个儿子节点合并过来&#123; register int i=1,j=1;num[now]=k; for(register int p=1;p&lt;=k;p++) &#123; while(f[s1][i]==f[now][p-1]&amp;&amp;i&lt;=num[s1]) i++; //注意去重 while(f[s2][j]==f[now][p-1]&amp;&amp;j&lt;=num[s2]) j++; if(i&gt;num[s1]&amp;&amp;j&gt;num[s2])&#123;num[now]=p-1;break;&#125; if(i&lt;=num[s1]&amp;&amp;(f[s1][i]&lt;f[s2][j]||j&gt;num[s2]))&#123;f[now][p]=f[s1][i];i++;&#125; else if(j&lt;=num[s2])&#123;f[now][p]=f[s2][j];j++;&#125; &#125;&#125;int main()&#123; srand(20050429); n=read();m=read(); for(register int i=m+1;i&lt;=n;i++)&#123;son[i][0]=read();son[i][1]=read();&#125; for(int r=1;r&lt;=4;r++) &#123; for(register int i=1;i&lt;=n;i++)&#123;w[i]=rand();while(!w[i])w[i]=rand();&#125; for(register int i=1;i&lt;=m;i++)&#123;f[i][1]=w[i];num[i]=1;&#125; for(register int i=m+1;i&lt;=n;i++) &#123; Merge(son[i][0],son[i][1],i); if(num[i]&lt;k) ans[i]=num[i]*4; //如果还没到k个就不用根据期望计算了 else ans[i]+=(LL)k*RAND_MAX/f[i][k]; &#125; &#125; for(int i=m+1;i&lt;=n;i++) printf("%lld\n",ans[i]/4); return 0;&#125;]]></content>
      <categories>
        <category>随机算法</category>
      </categories>
      <tags>
        <tag>随机算法</tag>
        <tag>DAG</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「洛谷P2617」Dynamic Rankings]]></title>
    <url>%2F2019%2F01%2F23%2F%E3%80%8C%E6%B4%9B%E8%B0%B7P2617%E3%80%8DDynamic-Rankings%2F</url>
    <content type="text"><![CDATA[标算又是树套树？写不来QwQ… 传送门BZOJ(是个权限题QwQ) 洛谷P2617 题解据说这题可以用带修主席树、树套树、整体二分解。由于蒟蒻我实在太菜了QwQ，只好选择了整体二分。 把刚原始序列理解为n个添加操作，将修改操作理解为一个删除操作和一个添加操作。然后直接上整体二分，解法类似于「ZJOI2013」K大数查询。并且由于每次只需要修改一个位置的信息，所以用普通树状数组就行了呢poi，快得飞起（尽管我自带大常数QwQ）。 代码整体二分又好写又好理解呢poi 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283#include&lt;cstdio&gt;using namespace std;const int maxn=100005;int n,m,tot,cnt,ans[maxn],A[maxn];inline int read()&#123; int ret=0,f=1;char ch=getchar(); while(ch&lt;'0'||ch&gt;'9')&#123;if(ch=='-')f=-f;ch=getchar();&#125; while(ch&gt;='0'&amp;&amp;ch&lt;='9')&#123;ret=ret*10+ch-'0';ch=getchar();&#125; return ret*f;&#125;struct BIT //封装好的树状数组&#123; int Tree[maxn]; void Update(int pos,int delta)&#123;while(pos&lt;=n)&#123;Tree[pos]+=delta;pos+=pos&amp;-pos;&#125;&#125; int Query(int pos)&#123;int ret=0;while(pos&gt;0)&#123;ret+=Tree[pos];pos-=pos&amp;-pos;&#125;return ret;&#125;&#125;Tr;struct Command&#123;int typ,idx,num,delta,L,R,k,id;&#125;Q[maxn*4],Q1[maxn*4],Q2[maxn*4];char GetChar() //读取操作类型，排除无用字符&#123; char ch=getchar(); while(ch!='C'&amp;&amp;ch!='Q') ch=getchar(); return ch;&#125;void BinarySearch(int L,int R,int S,int T) //整体二分&#123; if(L&gt;R||S&gt;T) return; int mid=L+R&gt;&gt;1,til1=0,til2=0; if(L==R) &#123; for(int i=S;i&lt;=T;i++) if(Q[i].typ) ans[Q[i].id]=mid; return; &#125; for(int i=S;i&lt;=T;i++) &#123; if(!Q[i].typ) &#123; if(Q[i].num&lt;=mid) &#123; Tr.Update(Q[i].idx,Q[i].delta); Q1[++til1]=Q[i]; &#125; else Q2[++til2]=Q[i]; &#125; else &#123; int cnt=Tr.Query(Q[i].R)-Tr.Query(Q[i].L-1); if(cnt&lt;Q[i].k) &#123; Q[i].k-=cnt; Q2[++til2]=Q[i]; &#125; else Q1[++til1]=Q[i]; &#125; &#125; for(int i=S;i&lt;=T;i++) //别忘了还原树状数组哟poi if(!Q[i].typ) if(Q[i].num&lt;=mid) Tr.Update(Q[i].idx,-Q[i].delta); for(int i=1;i&lt;=til1;i++) Q[S+i-1]=Q1[i]; for(int i=1;i&lt;=til2;i++) Q[S+til1+i-1]=Q2[i]; BinarySearch(L,mid,S,S+til1-1); BinarySearch(mid+1,R,S+til1,T);&#125;int main()&#123; n=read();m=read(); for(int i=1;i&lt;=n;i++)&#123;tot++;Q[tot].idx=i;Q[tot].num=A[i]=read();Q[tot].delta=1;&#125; for(int i=1;i&lt;=m;i++) &#123; if(GetChar()=='Q')&#123;tot++;cnt++;Q[tot].typ=1;Q[tot].L=read();Q[tot].R=read();Q[tot].k=read();Q[tot].id=cnt;&#125; else &#123; tot++;Q[tot].idx=read();Q[tot].num=read();Q[tot].delta=1; tot++;Q[tot].idx=Q[tot-1].idx;Q[tot].num=A[Q[tot-1].idx];A[Q[tot-1].idx]=Q[tot-1].num;Q[tot].delta=-1; &#125; &#125; BinarySearch(0,1000000000,1,tot); for(int i=1;i&lt;=cnt;i++) printf("%d\n",ans[i]); return 0;&#125;]]></content>
      <categories>
        <category>整体二分</category>
      </categories>
      <tags>
        <tag>主席树</tag>
        <tag>整体二分</tag>
        <tag>树套树</tag>
        <tag>树状数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「国家集训队」聪聪可可]]></title>
    <url>%2F2019%2F01%2F16%2F%E3%80%8C%E5%9B%BD%E5%AE%B6%E9%9B%86%E8%AE%AD%E9%98%9F%E3%80%8D%E8%81%AA%E8%81%AA%E5%8F%AF%E5%8F%AF%2F</url>
    <content type="text"><![CDATA[我数数最差了QwQ… 传送门洛谷P2634 BZOJ2152 题解很显然这是一道假的概率题。而是一道数数题，只要数出路径长度为3的倍数的点对的数量就行了呢poi。 隔壁dalao说这是一道点分治裸题，但是我还是觉得树形DP更好写一些QwQ。 定义$F_{ij}(j \in \lbrace 0,1,2 \rbrace)$表示节点$i$的子树中，到i的距离$\mod 3=j$的节点个数。如果当前遍历到的节点为i，我们需要计算出$i$及其子树中满足最短路径经过节点$i$且满足路径长是3的倍数的节点个数，累计到答案里最后除以$n^2$并约分就好了呢poi。 注意起点和终点可以相同，计算时小心点，不要算重复也不要漏算了哟poi。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243#include&lt;cstdio&gt;using namespace std;const int maxn=20005;int n,tot,lnk[maxn],son[maxn*2],w[maxn*2],nxt[maxn*2],F[maxn][3],ans1,ans2;inline int read()&#123; int ret=0,f=1;char ch=getchar(); while(ch&lt;'0'||ch&gt;'9')&#123;if(ch=='-')f=-f;ch=getchar();&#125; while(ch&gt;='0'&amp;&amp;ch&lt;='9')&#123;ret=ret*10+ch-'0';ch=getchar();&#125; return ret*f;&#125;inline void add_e(int x,int y,int z)&#123;tot++;son[tot]=y;w[tot]=z;nxt[tot]=lnk[x];lnk[x]=tot;&#125;int gcd(int x,int y)&#123;return !y?x:gcd(y,x%y);&#125;void DFS(int now,int fa)&#123; F[now][0]=1; for(int i=lnk[now];i;i=nxt[i]) &#123; if(son[i]!=fa) &#123; DFS(son[i],now); for(int j=0;j&lt;3;j++) ans1+=F[son[i]][j]*F[now][((3-j-w[i])%3+3)%3]*2; for(int j=0;j&lt;3;j++) F[now][(j+w[i])%3]+=F[son[i]][j]; &#125; &#125;&#125;int main()&#123; n=read(); for(int i=1;i&lt;n;i++) &#123; int a=read(),b=read(),c=read(); add_e(a,b,c);add_e(b,a,c); &#125; DFS(1,0); ans1+=n;ans2=n*n; int gys=gcd(ans1,ans2); ans1/=gys;ans2/=gys; printf("%d/%d\n",ans1,ans2); return 0;&#125;]]></content>
      <categories>
        <category>树形DP</category>
      </categories>
      <tags>
        <tag>DFS</tag>
        <tag>DP</tag>
        <tag>树形DP</tag>
        <tag>点分治</tag>
        <tag>数数</tag>
        <tag>概率</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「洛谷P5059」中国象棋]]></title>
    <url>%2F2019%2F01%2F16%2F%E3%80%8C%E6%B4%9B%E8%B0%B7P5059%E3%80%8D%E4%B8%AD%E5%9B%BD%E8%B1%A1%E6%A3%8B%2F</url>
    <content type="text"><![CDATA[又是数数题QwQ… 传送门洛谷P5059 题解首先注意题目中说的是有$n^2$个格子，也就是$(n+1)^2$个格点。 以下是出题人的推导： 首先我们可以发现每一行是独立的，所以只需要处理一行的答案即可 设$F[i][0]$表示一行中摆了$i$个位置且第$i$个位置不摆放棋子的方案数 设$F[i][1]$表示一行中摆了$i$个位置且第$i$个位置摆放棋子的方案数 设$Ans[i]$表示$F[i][0]+F[i][1]$ 那么忽略第二个限制可以发现有: $F[i][0]=F[i-1][0]+F[i-1][1]$ $F[i][1]=F[i-1][0]$ 所以有 $Ans[i]$ $=F[i][0]+F[i][1]$ $=2F[i-1][0]+F[i-1][1]$ $=(F[i-1][0]+F[i-1][1])+(F[i-2][0]+F[i-2][1])$ $=Ans[i-1]+Ans[i-2]$ 好了很显然这是一个斐波那契数列。自己再推一下，注意一下细节，不难发现最后的答案就是$$(Fib_{n+3}-n-2)^{n+1}$$矩阵加快速幂就可以在$\Theta(\log n)$的复杂内求解。 还有一个问题，由于n和P都非常大，直接乘long long也会boom。所以这里用了一个类似于快速幂的方法来求$(a*b)\mod P$的值。虽然复杂度多了一只log，但是很好写，并且避免了高精度又臭又长的代码和大常数复杂度。 代码还挺好写的呢poi。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include&lt;cstdio&gt;using namespace std;typedef long long LL;LL n,P;LL Multiply(LL x,LL y) //两个10^18级别的数在模P意义下的乘法&#123; LL ret=0,w=x; while(y) &#123; if(y&amp;1) ret=(ret+w)%P; w=(w+w)%P;y&gt;&gt;=1; &#125; return ret;&#125;struct Matrix&#123; LL a[2][2]; Matrix()&#123;a[0][0]=a[0][1]=a[1][0]=a[1][1]=0;&#125; Matrix operator * (Matrix b) //矩阵乘法 &#123; Matrix c; for(int i=0;i&lt;2;i++) for(int j=0;j&lt;2;j++) for(int k=0;k&lt;2;k++) c.a[i][j]=(c.a[i][j]+Multiply(a[k][j],b.a[i][k]))%P; return c; &#125;&#125;ans,mat,tep;LL QP(LL a,LL b) //普通快速幂&#123; LL ret=1,w=a; while(b) &#123; if(b&amp;1) ret=Multiply(ret,w); w=Multiply(w,w);b&gt;&gt;=1; &#125; return ret;&#125;int main()&#123; scanf("%lld%lld",&amp;n,&amp;P); ans.a[0][0]=ans.a[0][1]=mat.a[0][0]=mat.a[0][1]=mat.a[1][0]=1; LL b=n+1;tep=mat; while(b) //矩阵加速斐波那契数列 &#123; if(b&amp;1) mat=mat*tep; tep=tep*tep;b&gt;&gt;=1; &#125; ans=ans*mat; printf("%lld\n",QP(((ans.a[0][0]-n-2)%P+P)%P,n+1)); return 0;&#125;]]></content>
      <categories>
        <category>矩阵加速DP</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>数数</tag>
        <tag>快速幂</tag>
        <tag>斐波那契数列</tag>
        <tag>矩阵加速</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「JSOI2004」平衡点/吊打XXX]]></title>
    <url>%2F2019%2F01%2F15%2F%E3%80%8CJSOI2004%E3%80%8D%E5%B9%B3%E8%A1%A1%E7%82%B9%20%E5%90%8A%E6%89%93XXX-Solution%2F</url>
    <content type="text"><![CDATA[这是一个欧皇与非酋的故事…… 引言很久很久以前，有一位欧皇叫做黄霖，他热衷于各种随机算法，而且每次都能AC，直到有一天，他看到了张老师（ZS，我的启蒙老师，他水平很高，造数据能力特强）出的一份卷子： 黄霖：嗯！T1模拟退火能AC！T2模拟退火也能AC！T3模拟退火照样AC！ 张老师（冷笑）：嗯哼？三题都写模拟退火？有分吗？ 然后就没有然后了呢poi… 传送门洛谷P1337 题解这是一道物理题。 首先根据最小势能原理，当整个系统的势能最小时，系统平衡。不要问我为什么QwQ，我物理不好呢poi 虽然这题的正解不是模拟退火，但是用这题来当模拟退火的经典题还是很不错的呢poi。 首先我们钦定一个点作为绳结所在的位置作为初始答案，然后计算势能。 每次都在当前答案点附近的一个区域内rand一个点，区域大小由当前温度决定，如果这个点更优（势能更小），那么久接收这个点作为答案。否则有一定的概率接收新答案（概率计算方法很玄学，但是温度越小接收的概率越大）。 然后将温度乘以一个降温系数（降温系数是一个小于1的正数，这一步即退火），然后进行下一次答案搜索。 当温度降到几乎为0时停止就行了呢poi。 退火技巧首先可以多退几次。 降温系数要根据题目细调，太大了会导致时效差，太小可能搜不到最优解QwQ。 初始温度也要根据情况给定，可以用一些历史上特殊的日子，比如某dalao的生日来做初始温度呢poi。 种子也建议用某dalao的生日，或脸滚键盘，最好不要用初始值。 没事时多放放大悲咒，往生咒，般若波罗蜜多心经之类的音乐，你将得到佛祖的保佑。 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;cstdlib&gt;using namespace std;const int maxn=1005;const double delta=0.995; //降温系数int n,X[maxn],Y[maxn],W[maxn];double ansx,ansy,anse;inline int read()&#123; int ret=0,f=1;char ch=getchar(); while(ch&lt;'0'||ch&gt;'9')&#123;if(ch=='-')f=-f;ch=getchar();&#125; while(ch&gt;='0'&amp;&amp;ch&lt;='9')&#123;ret=ret*10+ch-'0';ch=getchar();&#125; return ret*f;&#125;inline double PotentialEnergy(double nowx,double nowy) //计算势能&#123; double ret=0; for(int i=1;i&lt;=n;i++) ret+=sqrt((X[i]-nowx)*(X[i]-nowx)+(Y[i]-nowy)*(Y[i]-nowy))*W[i]; return ret;&#125;inline void SimulateAnneal(double T)&#123; double nowx=ansx,nowy=ansy; while(T&gt;1e-14) &#123; double tempx=nowx+(rand()*2-RAND_MAX)*T; double tempy=nowy+(rand()*2-RAND_MAX)*T; double PE=PotentialEnergy(tempx,tempy); if(PE&lt;anse) //如果更优就马上接受 &#123; ansx=tempx;ansy=tempy; nowx=tempx;nowy=tempy; anse=PE; &#125; else if(exp((anse-PE)/T)*RAND_MAX&gt;rand())&#123;nowx=tempx;nowy=tempy;&#125; //否则有一定概率接收 T*=delta; //降温 &#125;&#125;inline void Solve()&#123; anse=PotentialEnergy(ansx,ansy); SimulateAnneal(2005); //多刷几次，记得洗把脸 SimulateAnneal(1926); SimulateAnneal(1949); SimulateAnneal(1978);&#125;int main()&#123; srand(20050429);//2005年4月29日dalao LTL出生，dalao会为你带来好运 n=read(); for(int i=1;i&lt;=n;i++)&#123;X[i]=read();Y[i]=read();W[i]=read();&#125; Solve(); printf("%.3lf %.3lf\n",ansx,ansy); return 0;&#125;]]></content>
      <categories>
        <category>模拟退火</category>
      </categories>
      <tags>
        <tag>随机算法</tag>
        <tag>模拟退火</tag>
        <tag>物理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「USACO2015JAN」草鉴定Grass Cownoisseur]]></title>
    <url>%2F2019%2F01%2F14%2F%E3%80%8CUSACO2015JAN%E3%80%8D%E8%8D%89%E9%89%B4%E5%AE%9AGrass-Cownoisseur%20-Solution%2F</url>
    <content type="text"><![CDATA[骚年，快来看！奶牛Bessie又在吃草了QwQ。 传送门洛谷P3119 题解单向道路？求一次能遍历到的最大点的数量？二话不说先上个Tarjan缩个点压压惊poi。 如果没有逆行这种操作，那么很显然起点所在强联通分量点的个数就是答案。 可是Bessie就是Bessie，总要搞点事情出来才符合她的性格。 于是乎我们缩点之后正反建图，刷两趟SPFA求每个点到起点的最长路。 然后枚举缩完点的图上的一条边，用来搞事情逆行。设当前枚举到的边为$(u,v)$，那么$u$在正建的图上到起点的最长路加上$v$在反建图上到起点的最长路就是逆行这条边时的最优解。在所有边里刷个最大值就行了呢poi。 有几个坑： 在最后计算答案时起点的权值会被算两次，记得减去一个。 枚举用于逆行的边时需要确保可以走到这条边并且走到这条边后可以走回起点。 由于需要建三套图(没缩过点的一套正建图一套反建图一套)，不要把数组名搞混了。此时封装可能是个好办法（但是会长一些，所以我没封装）。 其实总体上讲这题的想法并不难，但是代码有点难码QwQ。 于是乎这题就解完了。时间复杂度为$\Theta(n)$。 代码我觉得我写的挺简洁的poi。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687#include&lt;cstdio&gt;#include&lt;cstring&gt;using namespace std;const int maxn=100005;int n,m,tot[3],lnk[3][maxn],son[3][maxn],nxt[3][maxn],w[maxn],idx,dfn[maxn],low[maxn],top,stack[maxn],cnt,id[maxn],dist[3][maxn],que[maxn],ans;bool vis[maxn];inline int read()&#123; int ret=0,f=1;char ch=getchar(); while(ch&lt;'0'||ch&gt;'9')&#123;if(ch=='-')f=-f;ch=getchar();&#125; while(ch&gt;='0'&amp;&amp;ch&lt;='9')&#123;ret=ret*10+ch-'0';ch=getchar();&#125; return ret*f;&#125;inline void add_e(int x,int y,int id)&#123;tot[id]++;son[id][tot[id]]=y;nxt[id][tot[id]]=lnk[id][x];lnk[id][x]=tot[id];&#125;void Tarjan(int now)&#123; idx++;top++;vis[now]=true; dfn[now]=low[now]=idx;stack[top]=now; for(int i=lnk[0][now];i;i=nxt[0][i]) &#123; if(!dfn[son[0][i]]) &#123; Tarjan(son[0][i]); if(low[son[0][i]]&lt;low[now]) low[now]=low[son[0][i]]; &#125; else if(vis[son[0][i]]&amp;&amp;dfn[son[0][i]]&lt;low[now]) low[now]=dfn[son[0][i]]; &#125; if(dfn[now]==low[now]) &#123; cnt++; do &#123; id[stack[top]]=cnt;w[cnt]++; vis[stack[top]]=false;top--; &#125;while(stack[top+1]!=now); &#125;&#125;inline void SPFA(int id)&#123; memset(vis,false,sizeof(vis)); int hed=0,til=1; que[1]=::id[1];vis[que[1]]=true;dist[id][que[1]]=w[que[1]]; while(hed!=til) &#123; hed=(hed+1)%maxn;vis[que[hed]]=false; for(int j=lnk[id][que[hed]];j;j=nxt[id][j]) &#123; if(dist[id][que[hed]]+w[son[id][j]]&gt;dist[id][son[id][j]]) &#123; dist[id][son[id][j]]=dist[id][que[hed]]+w[son[id][j]]; if(!vis[son[id][j]]) &#123; vis[son[id][j]]=true; til=(til+1)%maxn; que[til]=son[id][j]; &#125; &#125; &#125; &#125;&#125;int main()&#123; n=read();m=read(); for(int i=1;i&lt;=m;i++) &#123; int a=read(),b=read(); add_e(a,b,0); &#125; for(int i=1;i&lt;=n;i++) if(!dfn[i]) Tarjan(i); for(int i=1;i&lt;=n;i++) &#123; for(int j=lnk[0][i];j;j=nxt[0][j]) &#123; if(id[i]!=id[son[0][j]]) &#123; add_e(id[i],id[son[0][j]],1); add_e(id[son[0][j]],id[i],2); &#125; &#125; &#125; SPFA(1);SPFA(2); for(int i=1;i&lt;=cnt;i++) for(int j=lnk[2][i];j;j=nxt[2][j]) if(dist[1][i]&amp;&amp;dist[2][son[2][j]]&amp;&amp;dist[1][i]+dist[2][son[2][j]]-w[id[1]]&gt;ans) ans=dist[1][i]+dist[2][son[2][j]]-w[id[1]]; printf("%d\n",ans); return 0;&#125;]]></content>
      <categories>
        <category>强联通分量</category>
      </categories>
      <tags>
        <tag>DAG</tag>
        <tag>Tarjan</tag>
        <tag>强联通分量</tag>
        <tag>最短路</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「HNOI2016」树]]></title>
    <url>%2F2019%2F01%2F05%2F%E3%80%8CHNOI2016%E3%80%8D%E6%A0%91-Solution%2F</url>
    <content type="text"><![CDATA[骚年，来看看这棵 真•树套树 吧！ 传送门洛谷 BZOJ 题解蒟蒻我定睛一看，一共有$10^{10}$个点，立马把蒟蒻我给吓到了QwQ。显然这是一道毒瘤题。我深深地感受到了出题人的恶意(然而我还是太菜了，像XHW这种dalao就可以想着要把出题人阿掉，我却不行)。 既然有这么多点，肯定是存不下的。因为每次操作都是copy一整颗子树，所以我们可以用一种叫做 真•树套树 的方法来解决呢poi。 我们构造大树时，令每一个大节点都对应模板树中的一整棵子树，并对新树重新编号，就像这样（样例）： 然后我们定义两个大节点之间的边的变权为两个大节点所包含的树的树根之间的距离。如上图中大节点1和2之间的边权为2,1与3之间的边权为3。 每一个大节点还需要存储以下信息： S[],T[]：该大节点包含的小节点的编号区间的起点和终点，如上图节点1的编号区间是[1,5]，节点2是[6,8]，节点3是[9,9]。 pre[]：该大节点对应的是模板树中哪一个节点的子树，如pre[1]=1，pre[2]=4，pre[3]=3。 lnk[]：该大节点挂在大树中的哪一个节点底下，如lnk[2]=3，lnk[3]=2。 以及常见的倍增LCA所需的信息。 还需要写几个函数： int GetRoot(long long u);用于查找小节点u所在的大节点。构造好S[],T[0]后，二分即可实现。 int GetPre(long long u);用于查找小节点u在模板树中对应的是哪个节点。假设小节点u在大节点rt里，那么根据题意，我们要找的就是rt对应的模板树的子树中该子树编号第$u-S[rt]+1$小的节点。这个我们可以把模板树一巴掌拍扁求个DFS序，然后用主席树解决（不会主席树的童鞋戳这里）。 int GetDist(int u,int v);用于求模板树上的节点u,v之间的距离。LCA解决。 然后就可以开始考虑如何计算答案了。 计算答案的主要思想就是在大树上通过倍增LCA求解，但是与普通LCA不同的是，不能纯粹地就在大树上LCA，需要注意很多细节。比如当再跳一步就跳到最近的大节点公共祖先时，不能马上往上跳，而需要往上跳一小步后转到模板树上去LCA。因为计算答案的细节，劳资%@#@￥%(文明靠大家)地交了4次才AC(不过好像也不算多)。 这样这题就解完了。时空复杂度都是大约$\Theta(超大常数*n\log n)$呢poi。 总结&amp;反思这是一道十分毒瘤的代码题(但是在某些dalao眼里就是送分题)，思维难度一般，但蒟蒻我前前后后一共花了3个多小时才AC(听说隔壁XCW一看题就秒掉了)QwQ。这道题很好地反映出蒟蒻我的代码实现能力还是太差，可能是由于做题太少的缘故。我虽然很菜，但是如果ZJOI2019真的出了像这样的一道题(或者类似于猪国杀什么的)，空有想法却没时间写代码和调试，那可就亏大发了QwQ。 代码蒟蒻我为了避免变量重名，于是开了两个namespace（不知代码是更好看了还是更丑了）。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;typedef long long LL;const int maxn=100005,LOG=20;int Q;inline LL read()&#123; LL ret=0,f=1;char ch=getchar(); while(ch&lt;'0'||ch&gt;'9')&#123;if(ch=='-')f=-f;ch=getchar();&#125; while(ch&gt;='0'&amp;&amp;ch&lt;='9')&#123;ret=ret*10+ch-'0';ch=getchar();&#125; return ret*f;&#125;struct ChairmanTree //封装好的主席树&#123; int tot,T[maxn]; struct Node&#123;int L,R,Sum;&#125;Tree[maxn*LOG]; int Build(int L,int R) &#123; int rt=++tot,mid=L+R&gt;&gt;1; if(L&gt;=R) return rt; Tree[rt].L=Build(L,mid); Tree[rt].R=Build(mid+1,R); if(rt==1) T[0]=rt; return rt; &#125; int Update(int num,int pre,int L,int R) &#123; int rt=++tot,mid=L+R&gt;&gt;1; Tree[rt].L=Tree[pre].L;Tree[rt].R=Tree[pre].R;Tree[rt].Sum=Tree[pre].Sum+1; if(L&gt;=R) return rt; if(num&lt;=mid) Tree[rt].L=Update(num,Tree[pre].L,L,mid); else Tree[rt].R=Update(num,Tree[pre].R,mid+1,R); return rt; &#125; int Query(int u,int v,int k,int L,int R) &#123; int mid=L+R&gt;&gt;1,x=Tree[Tree[v].L].Sum-Tree[Tree[u].L].Sum; if(L==R) return mid; if(x&gt;=k) return Query(Tree[u].L,Tree[v].L,k,L,mid); else return Query(Tree[u].R,Tree[v].R,k-x,mid+1,R); &#125;&#125;CT;namespace TemplateTree //模板树&#123; int n,father[maxn][LOG],dep[maxn],idx,que[maxn],S[maxn],T[maxn],tot,lnk[maxn],son[maxn*2],nxt[maxn*2]; inline void add_e(int x,int y)&#123;tot++;son[tot]=y;nxt[tot]=lnk[x];lnk[x]=tot;&#125; void Build(int now,int fa) //把树上的一些信息构造好 &#123; S[now]=++idx;que[idx]=now;father[now][0]=fa;dep[now]=dep[fa]+1; for(int i=1;i&lt;=16;i++) father[now][i]=father[father[now][i-1]][i-1]; for(int i=lnk[now];i;i=nxt[i]) if(son[i]!=fa) Build(son[i],now); T[now]=idx; &#125; inline void BuildCT() //初始化主席树 &#123; CT.Build(1,n); for(int i=1;i&lt;=n;i++) CT.T[i]=CT.Update(que[i],CT.T[i-1],1,n); &#125; inline void Input() //读入数据 &#123; for(int i=1;i&lt;n;i++) &#123; int a=read(),b=read(); add_e(a,b);add_e(b,a); &#125; Build(1,0);BuildCT(); &#125; int GetDist(int u,int v) //LCA求亮点间距离 &#123; int ret=0; if(dep[u]&lt;dep[v]) swap(u,v); for(int i=16;i&gt;=0;i--) if(dep[father[u][i]]&gt;=dep[v])&#123;ret+=(1&lt;&lt;i);u=father[u][i];&#125; for(int i=16;i&gt;=0;i--) if(father[u][i]!=father[v][i])&#123;ret+=(1&lt;&lt;i+1);u=father[u][i];v=father[v][i];&#125; if(u==v) return ret; return ret+2; &#125;&#125;namespace BigTree //大树&#123; int n,m,father[maxn][LOG],dep[maxn],pre[maxn];LL dist[maxn][LOG],S[maxn],T[maxn],lnk[maxn],cnt; inline int GetRoot(LL u) &#123; int L=1,R=n,mid; while(L&lt;=R) &#123; mid=L+R&gt;&gt;1; S[mid]&lt;=u?L=mid+1:R=mid-1; &#125; return R; &#125; inline int GetPre(LL u) &#123; int rt=GetRoot(u); return CT.Query(CT.T[TemplateTree::S[pre[rt]]-1],CT.T[TemplateTree::T[pre[rt]]],u-S[rt]+1,1,TemplateTree::n); &#125; inline void Build() //初始化大树 &#123; n=1;dep[1]=1;pre[1]=1;S[1]=1;T[1]=TemplateTree::n;cnt=T[1]; for(int i=1;i&lt;=m;i++) &#123; int fr=read();LL to=read();int rt=GetRoot(to); n++;dep[n]=dep[rt]+1;lnk[n]=to;pre[n]=fr;S[n]=cnt+1;T[n]=cnt+TemplateTree::T[fr]-TemplateTree::S[fr]+1;cnt=T[n]; father[n][0]=rt;dist[n][0]=TemplateTree::dep[GetPre(to)]-TemplateTree::dep[pre[rt]]+1; for(int j=1;j&lt;=16;j++)&#123;father[n][j]=father[father[n][j-1]][j-1];dist[n][j]=dist[n][j-1]+dist[father[n][j-1]][j-1];&#125; &#125; &#125; inline LL Solve(LL u,LL v) //计算答案(写的真丑QwQ) &#123; LL ret=0;int rtu=GetRoot(u),rtv=GetRoot(v); if(rtu==rtv) return TemplateTree::GetDist(GetPre(u),GetPre(v)); if(dep[rtu]&lt;dep[rtv])&#123;swap(u,v);swap(rtu,rtv);&#125; ret+=TemplateTree::dep[GetPre(u)]-TemplateTree::dep[pre[rtu]];u=rtu; for(int i=16;i&gt;=0;i--) if(dep[father[u][i]]&gt;dep[rtv])&#123;ret+=dist[u][i];u=father[u][i];&#125; if(GetRoot(lnk[u])==rtv) return ret+1+TemplateTree::GetDist(GetPre(lnk[u]),GetPre(v)); ret+=TemplateTree::dep[GetPre(v)]-TemplateTree::dep[pre[rtv]];v=rtv; if(dep[u]&gt;dep[v])&#123;ret+=dist[u][0];u=father[u][0];&#125; for(int i=16;i&gt;=0;i--) if(father[u][i]!=father[v][i])&#123;ret+=dist[u][i]+dist[v][i];u=father[u][i];v=father[v][i];&#125; u=lnk[u];v=lnk[v];ret+=2; return ret+TemplateTree::GetDist(GetPre(u),GetPre(v)); &#125;&#125;int main() //好简洁的主函数&#123; TemplateTree::n=read();BigTree::m=read();Q=read(); TemplateTree::Input();BigTree::Build(); while(Q--) printf("%lld\n",BigTree::Solve(read(),read())); return 0;&#125;]]></content>
      <categories>
        <category>树上问题</category>
      </categories>
      <tags>
        <tag>树上问题</tag>
        <tag>LCA</tag>
        <tag>主席树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[主席树（可持久化线段树）]]></title>
    <url>%2F2019%2F01%2F04%2F%E4%B8%BB%E5%B8%AD%E6%A0%91%EF%BC%88%E5%8F%AF%E6%8C%81%E4%B9%85%E5%8C%96%E7%BA%BF%E6%AE%B5%E6%A0%91%EF%BC%89%2F</url>
    <content type="text"><![CDATA[骚年，你需要一棵主席树！它会赐予你力量！ 传送门洛谷的主席树模板题 正文引入问题我们可能时常会遇到这样的一类问题：给定一个序列$A$和若干组询问，每次给定一个区间$[L,R]$和一个参数$k$，问序列上该区间中第$k$大的元素是多少。 对于这类问题，暴力算法显而易见(但是会T飞)。一个很好的解决办法就是用主席树(其实洛谷上的这道模板题不强制在线，分块+莫队可以AC，还跑得贼快)。 说一句题外话，主席树这种数据结构据说是一位名字缩写是HJT的神仙在考场上现场yy出来的，而HJT正是新中国历史上一位著名主席的名字缩写，因此得名。 考虑初始版本首先请确保你已经掌握普通线段树的写法，不会的童鞋请自行Ctrl+W。 我们建$n$权值棵线段树，第$i$棵线段树需要维护序列$A_1$~$A_i$中，每个权值出现的次数。比如说第$i$棵线段树上的一个节点管辖的权值区间是$[S,T]$，该节点需要储存满足$A_j\inS,T$的元素$A_j$的个数。可以将这些线段树一开始就构造好。 当进行询问的时候，如果当前的询问区间是$[L,R]$那么我们就把第$L-1$棵线段树和第$R$棵线段树拎出来，根据容斥的原理，将两棵线段树每个节点的权值相减就能得到一颗有我们想要用的包含$A_L$~$A_R$的信息的权值线段树。 然后我们就在这棵线段树上计算答案。 首先先遍历树根，假设当前节点管辖的权值区间是$[L,R]$，权值在该区间内的元素的个数和是$sum$。 如果$sum\leq k$，那么遍历当前节点的左儿子。 否则将$k$的值减去$sum$，然后遍历右儿子。 循环以上步骤，直到$L=R$，此时的$L$就是答案。 完善初始版本说真的，初始版本又难码又慢，比暴力算法还垃圾QwQ 现在考虑完善一下初始版本，让它成为一棵真正的主席树！ 首先在询问的时候，不需要每次都重构一棵线段树，用两个指针同时在两棵线段树上遍历，查个数的时候再相减就行了。 其次，如果真的开$n$棵完整的权值线段树，内存不炸才怪QwQ。 我们发现，第$i$棵权值线段树是在继承第$i-1$棵的信息的基础上，再添加第$i$个元素的信息。而根据线段树的性质，每进行一次修改，最多只会改变$\log n$个节点的信息。所以我们动态开点，在开第$i$棵线段树时，只新开修改过的节点，并把新开的节点直接接到没有修改过的已有节点上就可以了QwQ。骚年，你感受到了可持久化的力量了吗？ 还有，由于元素的权值可能很大，我们需要将原序列先离散化。 这样，我们就成功地把时间复杂度和空间复杂度都下压至$\Theta(n\log n)$的水平。主席树万岁！ 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include&lt;map&gt;#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;const int maxn=200005,LOG=20;int n,m,cnt,A[maxn],B[maxn];map&lt;int,int&gt; H;inline int read()&#123; int ret=0,f=1;char ch=getchar(); while(ch&lt;'0'||ch&gt;'9')&#123;if(ch=='-')f=-f;ch=getchar();&#125; while(ch&gt;='0'&amp;&amp;ch&lt;='9')&#123;ret=ret*10+ch-'0';ch=getchar();&#125; return ret*f;&#125;struct ChairmanTree //封装大法好&#123; int tot,T[maxn]; struct Node&#123;int L,R,Sum;&#125;Tree[maxn*LOG]; int Build(int L,int R) //在开始添加信息之前，先初始化 &#123; int rt=++tot,mid=L+R&gt;&gt;1; if(L&gt;=R) return rt; Tree[rt].L=Build(L,mid); Tree[rt].R=Build(mid+1,R); if(rt==1) T[0]=rt; return rt; &#125; int Update(int num,int pre,int L,int R) //添加信息 &#123; int rt=++tot,mid=L+R&gt;&gt;1; Tree[rt].L=Tree[pre].L;Tree[rt].R=Tree[pre].R;Tree[rt].Sum=Tree[pre].Sum+1; if(L&gt;=R) return rt; if(num&lt;=mid) Tree[rt].L=Update(num,Tree[pre].L,L,mid); else Tree[rt].R=Update(num,Tree[pre].R,mid+1,R); return rt; &#125; int Query(int u,int v,int k,int L,int R) //询问 &#123; int mid=L+R&gt;&gt;1,x=Tree[Tree[v].L].Sum-Tree[Tree[u].L].Sum; if(L==R) return mid; //找到了 if(x&gt;=k) return Query(Tree[u].L,Tree[v].L,k,L,mid); //分类讨论 else return Query(Tree[u].R,Tree[v].R,k-x,mid+1,R); &#125;&#125;CT;int main()&#123; n=read();m=read(); for(int i=1;i&lt;=n;i++) A[i]=B[i]=read(); sort(B+1,B+1+n);cnt=unique(B+1,B+1+n)-B-1; //离散化 for(int i=1;i&lt;=cnt;i++) H[B[i]]=i; CT.Build(1,cnt); for(int i=1;i&lt;=n;i++) CT.T[i]=CT.Update(H[A[i]],CT.T[i-1],1,cnt); while(m--) &#123; int L=read(),R=read(),k=read(); printf("%d\n",B[CT.Query(CT.T[L-1],CT.T[R],k,1,cnt)]); &#125; return 0;&#125; 其他其实主席树也可以维护带修改操作的序列，但是蒟蒻我现在还不会QwQ。]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>主席树</tag>
        <tag>数据结构</tag>
        <tag>线段树</tag>
        <tag>可持久化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[XZY的女装flag(捂脸]]></title>
    <url>%2F2018%2F12%2F31%2FXZY%E7%9A%84%E5%A5%B3%E8%A3%85flag%2F</url>
    <content type="text"><![CDATA[震惊！蒟蒻XZY竟在大年夜当众….. 如果你想了解蒟蒻我女装的原因，右拐公告。 蒟蒻我虽然NOIP翻车了，翻得挺惨，但是CCF很仁慈，可怜了一下蒟蒻我，为此，我忍不住又吟诗一首： 咳咳，XZY的女装flag已近兑现入土了。 照片在底下(蒟蒻我和巨佬XXC女装的合照) % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % 瘦一点的，穿白色蕾丝裙的是蒟蒻我，旁边穿日款夏装的是巨佬XXC(妈的，冻死宝宝了)。 XXC巨佬的blog 晚上光线真的不好qwq，拍出来不好看poi。 警告：照片看看就好，不要用作任何非法用途qwq。]]></content>
      <categories>
        <category>公告</category>
      </categories>
      <tags>
        <tag>flag</tag>
        <tag>女装</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「国家集训队」数颜色/维护队列]]></title>
    <url>%2F2018%2F12%2F27%2F%E3%80%8C%E5%9B%BD%E5%AE%B6%E9%9B%86%E8%AE%AD%E9%98%9F%E3%80%8D%E6%95%B0%E9%A2%9C%E8%89%B2%20%E7%BB%B4%E6%8A%A4%E9%98%9F%E5%88%97%2F</url>
    <content type="text"><![CDATA[什么？维护序列的题？当然是上莫队啦poi！ 传送门洛谷传送门 BZOJ传送门 题解很显然这是一道莫队的题呢poi！ 但是有修改操作QwQ。 怎么办呢poi？ 当然是写一个资瓷修改的莫队啦！(好像都是废话) 首先我们要把所有操作分成两坨，一坨修改操作，一坨询问操作。 并且我们需要预处理出进行每一个修改操作之前这个要修改的位置上的颜色。 还要预处理出进行每一个询问操作时已近完成了几个修改操作。 然后在莫队的时候，如果当前已经进行了的修改操作的个数与当前询问操作所记录的已经进行了的修改操作数不一致，暴力更新一下就行了呢poi！ 据说这样带修改的莫队只要把块的大小设置为$n^\frac{2}{3}$就能将时间内复杂度控制在可接受的范围内呢poi。 其他的按照普通莫队写就行啦poi！ 还有洛谷上这题数据比较强，如果不按玄学方法排序要吸个氧才能AC(也有可能是蒟蒻我的常数太大了QwQ)。 代码其实还挺好写的呢poi 还有不要问我为什么那么喜欢poi呢poi 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;const int maxn=50005;int n,m,m1,m2,S,A[maxn],B[maxn],Area[maxn],ans[maxn],L,R,now,ncnt,hsh[1000005];inline int read()&#123; int ret=0,f=1;char ch=getchar(); while(ch&lt;'0'||ch&gt;'9')&#123;if(ch=='-')f=-f;ch=getchar();&#125; while(ch&gt;='0'&amp;&amp;ch&lt;='9')&#123;ret=ret*10+ch-'0';ch=getchar();&#125; return ret*f;&#125;char GetChar()&#123; char ch=getchar(); while(ch!='Q'&amp;&amp;ch!='R') ch=getchar(); return ch;&#125;struct Query&#123; int L,R,id,cnt; bool operator &lt; (const Query&amp; b)const&#123;return Area[L]&lt;Area[b.L]||(Area[L]==Area[b.L]&amp;&amp;((Area[L]&amp;1)?R&gt;b.R:R&lt;b.R));&#125;&#125;Q[maxn];struct Update&#123;int P,C,lst;&#125;U[maxn];inline void inc(int num)&#123;if(!hsh[num]++) now++;&#125;inline void dec(int num)&#123;if(!--hsh[num]) now--;&#125;int main()&#123; n=read();m=read();S=pow(n,0.666666)+1e-10; for(int i=1;i&lt;=n;i++) Area[i]=(i-1)/S+1; for(int i=1;i&lt;=n;i++) A[i]=B[i]=read(); for(int i=1;i&lt;=m;i++) &#123; if(GetChar()=='Q')&#123;Q[++m1].L=read();Q[m1].R=read();Q[m1].id=m1;Q[m1].cnt=m2;&#125; else&#123;U[++m2].P=read();U[m2].C=read();U[m2].lst=B[U[m2].P];B[U[m2].P]=U[m2].C;&#125; &#125; sort(Q+1,Q+1+m1); L=1;R=1;hsh[A[1]]++;now=1; for(int i=1;i&lt;=m1;i++) &#123; while(R&lt;Q[i].R) inc(A[++R]); while(L&gt;Q[i].L) inc(A[--L]); while(R&gt;Q[i].R) dec(A[R--]); while(L&lt;Q[i].L) dec(A[L++]); while(ncnt&gt;Q[i].cnt) &#123; A[U[ncnt].P]=U[ncnt].lst; if(L&lt;=U[ncnt].P&amp;&amp;U[ncnt].P&lt;=R)&#123;dec(U[ncnt].C);inc(U[ncnt].lst);&#125; ncnt--; &#125; while(ncnt&lt;Q[i].cnt) &#123; ncnt++; A[U[ncnt].P]=U[ncnt].C; if(L&lt;=U[ncnt].P&amp;&amp;U[ncnt].P&lt;=R)&#123;inc(U[ncnt].C);dec(U[ncnt].lst);&#125; &#125; ans[Q[i].id]=now; &#125; for(int i=1;i&lt;=m1;i++) printf("%d\n",ans[i]); return 0;&#125;]]></content>
      <categories>
        <category>莫队</category>
      </categories>
      <tags>
        <tag>分块</tag>
        <tag>莫队</tag>
        <tag>带修改莫队</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「ZJOI2013」K大数查询|整体二分]]></title>
    <url>%2F2018%2F12%2F26%2F%E3%80%8CZJOI2013%E3%80%8DK%E5%A4%A7%E6%95%B0%E6%9F%A5%E8%AF%A2%20%E6%95%B4%E4%BD%93%E4%BA%8C%E5%88%86%2F</url>
    <content type="text"><![CDATA[什么？树套树？不存在的。 传送门洛谷传送门 BZOJ传送门 在您开始阅读本题解之前，蒟蒻我建议您先把题面多看几遍，并仔细阅读样例和样例说明。 我才不会告诉你蒟蒻我就是因为看错题面然后白忙活了一个小时。 题解据说本题可以用树套树解，但是树套树这种东西常数稍微一大就TLE，这位dalao的树套树就咕掉了。而且树套树对于蒟蒻我来说太***难了，所以我们需要整体二分这种东西。 首先确保您已经掌握普通二分的写法，不会普通二分的请自行Ctrl+w。 整体二分的主要思想就是把这一大坨询问一起处理。 首先让我们来考虑只有一个询问操作的情况： 二分权值(即答案)，每次分到一个$mid$，我们就把这个询问之前所有的有贡献的添加操作(即$c$值大于$mid$的添加操作)用一个支持区间修改的树状数组或者线段树预处理，然后我们就可以很快地得到区间$[a,b]$中权值大于$mid$的数的个数$tot$。如果$tot$小于这个询问操作的$c$值，那么我们就把$c$值减去$tot$，然后把之前产生过贡献的添加操作扔掉删除，并修改二分的边界值继续二分；否则直接修改二分的边界值继续二分即可。 好了现在再来考虑有一坨询问的情况。 方便起见，我们把询问操作和添加操作一起处理。设当前二分的值是$mid$，二分的权值区间是$[L,R]$要处理的操作区间是$[s,t]$。那我们先遍历一遍操作区间，如果当前遍历到的是有贡献的添加操作，就更新一下线段树；若果是询问操作，就在线段树上查询一下该询问区间内权值大于$mid$的个数$tot$，根据$tot$是否大于$c$并把操作分成两堆，然后递归分别处理两堆，直到$L=R$时$mid$就是当前所有询问操作的答案。(添加操作也要根据$c$值是否大于$mid$也一起分成两堆) 注意将操作分堆时每一堆内不要打乱操作的顺序。 时间复杂度$\Theta(n\log{n}^2)$，常数是真的小QwQ。 代码貌似真的比树套树好懂 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697#include&lt;cstdio&gt;using namespace std;typedef long long LL;const int maxn=50005;int n,m,cnt,ans[maxn];inline LL read()&#123; LL ret=0,f=1;char ch=getchar(); while(ch&lt;'0'||ch&gt;'9')&#123;if(ch=='-')f=-f;ch=getchar();&#125; while(ch&gt;='0'&amp;&amp;ch&lt;='9')&#123;ret=ret*10+ch-'0';ch=getchar();&#125; return ret*f;&#125;struct Command&#123; int typ,L,R,id;LL C;&#125;Q[maxn],Q1[maxn],Q2[maxn];struct SegmentTree //一个普普通通的线段树&#123;private: struct Node&#123;LL Sum,Tag;&#125;Tree[maxn*4]; void PushUp(int rt)&#123;Tree[rt].Sum=Tree[rt*2].Sum+Tree[rt*2+1].Sum;&#125; void PushDown(int rt,int LC,int RC) &#123; Tree[rt*2].Tag+=Tree[rt].Tag;Tree[rt*2+1].Tag+=Tree[rt].Tag; Tree[rt*2].Sum+=LC*Tree[rt].Tag;Tree[rt*2+1].Sum+=RC*Tree[rt].Tag; Tree[rt].Tag=0; &#125;public: void RangeUpdate(int LL,int RR,int delta,int L=1,int R=n,int rt=1) &#123; if(LL&lt;=L&amp;&amp;R&lt;=RR)&#123;Tree[rt].Sum+=(R-L+1)*delta;Tree[rt].Tag+=delta;return;&#125; int M=L+R&gt;&gt;1; PushDown(rt,M-L+1,R-M); if(LL&lt;=M) RangeUpdate(LL,RR,delta,L,M,rt*2); if(M&lt;RR) RangeUpdate(LL,RR,delta,M+1,R,rt*2+1); PushUp(rt); &#125; LL RangeQuery(int LL,int RR,int L=1,int R=n,int rt=1) &#123; if(LL&lt;=L&amp;&amp;R&lt;=RR) return Tree[rt].Sum; int M=L+R&gt;&gt;1;::LL ret=0; PushDown(rt,M-L+1,R-M); if(LL&lt;=M) ret+=RangeQuery(LL,RR,L,M,rt*2); if(M&lt;RR) ret+=RangeQuery(LL,RR,M+1,R,rt*2+1); return ret; &#125;&#125;S;void BinarySearch(int L,int R,int s,int t) //整体二分&#123; if(L&gt;R||s&gt;t) return; int mid=L+R&gt;&gt;1,len1=0,len2=0; if(L==R) &#123; for(int i=s;i&lt;=t;i++) if(Q[i].typ==2) //只有询问操作才需要回答 ans[Q[i].id]=mid; return; &#125; for(int i=s;i&lt;=t;i++) &#123; if(Q[i].typ==1) &#123; if(Q[i].C&gt;mid) &#123; S.RangeUpdate(Q[i].L,Q[i].R,1); Q1[++len1]=Q[i]; //操作分堆 &#125; else Q2[++len2]=Q[i]; &#125; else &#123; LL tot=S.RangeQuery(Q[i].L,Q[i].R); if(Q[i].C&lt;=tot) Q1[++len1]=Q[i]; //操作分堆 else&#123;Q2[++len2]=Q[i];Q2[len2].C-=tot;&#125; &#125; &#125; for(int i=s;i&lt;=t;i++) //撤销操作，清空线段树 if(Q[i].typ==1&amp;&amp;Q[i].C&gt;mid) S.RangeUpdate(Q[i].L,Q[i].R,-1); int j=s; for(int i=1;i&lt;=len1;i++,j++) Q[j]=Q1[i]; for(int i=1;i&lt;=len2;i++,j++) Q[j]=Q2[i]; BinarySearch(L,mid,s+len1,t);BinarySearch(mid+1,R,s,s+len1-1);&#125;int main()&#123; n=read();m=read(); for(int i=1;i&lt;=m;i++) &#123; Q[i].typ=read(); if(Q[i].typ==2) Q[i].id=++cnt; Q[i].L=read();Q[i].R=read();Q[i].C=read(); &#125; BinarySearch(-n,n,1,m); for(int i=1;i&lt;=cnt;i++) printf("%d\n",ans[i]); return 0;&#125;]]></content>
      <categories>
        <category>整体二分</category>
      </categories>
      <tags>
        <tag>整体二分</tag>
        <tag>树套树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「HNOI2010」弹飞绵羊]]></title>
    <url>%2F2018%2F12%2F24%2F%E3%80%8CHNOI2010%E3%80%8D%E5%BC%B9%E9%A3%9E%E7%BB%B5%E7%BE%8A-Solution%2F</url>
    <content type="text"><![CDATA[什么？LCT？不存在的。蒟蒻我怎么可能会LCT。 传送门洛谷传送门(咕咕咕) 爆炸BZOJ传送门 题解听说这题的标算是LCT？我这么菜！怎么可能会LCT！！！看了一眼数据范围，很亲切啊！二话不说直接上分块！ 首先，按照分块的套路，把$n$个弹力装置分成若干个块(块的大小取$\sqrt{n}$即可)。然后需要提前构造好两个数组： 1：$step[]$。$step[i]$表示落到第i个弹力装置上的绵羊还需几次才能跳到下一个块里（或者被弹飞）。 2：$pos[]$。$pos[i]$表示落到第i个弹力装置上的绵羊在被弹出当前块后会被弹到哪一个位置上。 这两个数组可以一开始从后往前在$\Theta(n*\sqrt{n})$的时间复杂度内构造出来。(我才不会告诉你我写这个是为了测试markdown的数学公式)询问的时候借助这两个数组就可以在$\Theta(\sqrt{n})$的时间复杂度内通过模拟计算出答案。 然后让我们再来考虑修改的问题。 自己思考一下，不难发现，修改了一个弹力系数之后，只有该块内的两个数组的值可能发生改变，然后从后往前暴力更新一下即可。 代码比LCT短了不少 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include&lt;cmath&gt;#include&lt;cstdio&gt;using namespace std;const int maxn=200005;int n,m,S,Area[maxn],K[maxn],step[maxn],pos[maxn];inline int read()&#123; int ret=0,f=1;char ch=getchar(); while(ch&lt;'0'||ch&gt;'9')&#123;if(ch=='-')f=-f;ch=getchar();&#125; while(ch&gt;='0'&amp;&amp;ch&lt;='9')&#123;ret=ret*10+ch-'0';ch=getchar();&#125; return ret*f;&#125;inline void Solve(int s)&#123; int p=s+K[s],ret=1; while(Area[p]==Area[s])&#123;p=p+K[p];ret++;&#125; step[s]=ret;pos[s]=p;&#125;inline void Update(int s)&#123; int p=s+K[s],ret=1; while(Area[p]==Area[s])&#123;p=p+K[p];ret++;&#125; step[s]=ret;pos[s]=p; for(int i=s-1;Area[i]==Area[s];i--) if(Area[i+K[i]]==Area[i]) &#123;step[i]=step[i+K[i]]+1;pos[i]=pos[i+K[i]];&#125;&#125;inline void Query(int s)&#123; int p=s,ret=0; while(p&lt;=n)&#123;ret+=step[p];p=pos[p];&#125; printf("%d\n",ret);&#125;int main()&#123; n=read();S=sqrt(n)+1e-10; for(int i=1;i&lt;=n;i++) Area[i]=(i-1)/S+1; for(int i=1;i&lt;=n;i++) K[i]=read(); for(int i=n;i&gt;=1;i--) Solve(i); m=read(); while(m--) &#123; int a=read(),b=read()+1; if(a==1) Query(b); else&#123;int c=read();K[b]=c;Update(b);&#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>分块</category>
      </categories>
      <tags>
        <tag>分块</tag>
        <tag>LCT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[公告]]></title>
    <url>%2F2018%2F12%2F22%2F%E5%85%AC%E5%91%8A%2F</url>
    <content type="text"><![CDATA[什么？女装发blog？不存在的… 欢迎访问蒟蒻我的blog. 蒟蒻我万年不更新的Blog终于在网站开通后n个星期准备开始更新了。。。 蒟蒻我和巨佬XXC女装的事，想必各位dalao都知道了。 关于女装，可说来话长了。是这么一回事： NOIP2018 day2考完出场，ZJ初三小蒟蒻我感觉两腿绵软无力，很显然我这只蒟蒻是考boom了。day2 T1我傻逼样得想用一种奇妙的方法来解决这棵基环外向树，然后写了两个小时还没有结果，CCF给的大样例也过不了。出了考场和各位大佬一起交流了一下才发现暴力枚举删掉的边然后重构图即可。因为T1没做出来，T2的45分结论分也没拿到。自己估摸了一下，不该丢的分一共丢了85分，预估不翻车的情况下分数为应该379，省一GG… 事后，蒟蒻我写了一首诗来表达自己内心的想法(我有一句mmp不知当不当讲)： 于是乎，我便当众立了一个flag：我CCF评出来400分以上就那啥！ 然鹅等到CCF出成绩的那天，由于CCF的数据非常友好，我总分399(CCF万岁) 但是成绩出来之后，跟各位dalao一讨论，参考了一下CCF的文件，发现蒟蒻我省一仍然没有太大希望qwq。 于是乎，我又当众立了一个flag：我省一就那啥！ 12.04，CCF发布获奖名单，我惊奇地发现CCF修改了省一获奖名额的分配方案。CCF万岁万岁万万岁。蒟蒻我先是高兴了一会儿，然后想起了之前立的flag… 我&amp;^%￥#T@(文明你我他) 然后就没有然后了… 为了不让Matsusaki这位dalao破费，我决定等XXC巨佬女装后把衣服借来用用。 听说我已近被安排上了？好像就在81022018年12月30/31号？ XXC巨佬的blog(据说这里会放上他她的女装图)]]></content>
      <categories>
        <category>公告</category>
      </categories>
      <tags>
        <tag>女装</tag>
        <tag>公告</tag>
      </tags>
  </entry>
</search>
