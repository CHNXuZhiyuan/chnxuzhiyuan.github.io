<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[「TJOI2010」分金币]]></title>
    <url>%2F2019%2F03%2F08%2F%E3%80%8CTJOI2010%E3%80%8D%E5%88%86%E9%87%91%E5%B8%81-Solution%2F</url>
    <content type="text"><![CDATA[又是一道模拟退火的题QwQ。 传送门洛谷P3878 题解感觉这样的题目还是比较套路的QwQ。 还是先考虑一个看起来比较靠谱的贪心，比如考虑按顺序遍历这些金币，如果当前两堆个数相等的话谁小就先丢到谁哪儿，否则就丢到个数少的一堆里。 此时决策的方案还是与遍历的顺序有关，所以上模拟退火确定一个最优的顺序，然后就好了QwQ。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;algorithm&gt;using namespace std;const int maxn=35;const double delta=0.998;int T,n,v[maxn],ans;inline int read()&#123; int ret=0,f=1;char ch=getchar(); while(ch&lt;'0'||ch&gt;'9')&#123;if(ch=='-')f=-f;ch=getchar();&#125; while(ch&gt;='0'&amp;&amp;ch&lt;='9')&#123;ret=ret*10+ch-'0';ch=getchar();&#125; return ret*f;&#125;inline int ABS(int x)&#123;return x&lt;0?-x:x;&#125;inline int Calc()&#123; int sum1=0,sum2=0,cnt1=0,cnt2=0; for(int i=1;i&lt;=n;i++) &#123; if(cnt1==cnt2) &#123; if(sum1&lt;sum2)&#123;sum1+=v[i];cnt1++;&#125; else&#123;sum2+=v[i];cnt2++;&#125; &#125; else &#123; if(cnt1&lt;cnt2)&#123;sum1+=v[i];cnt1++;&#125; else&#123;sum2+=v[i];cnt2++;&#125; &#125; &#125; return ABS(sum1-sum2);&#125;inline void SA(double T)&#123; while(T&gt;1e-12) &#123; int a=rand()%n+1,b=rand()%n+1; while(a==b)&#123;a=rand()%n+1;b=rand()%n+1;&#125; swap(v[a],v[b]); int now=Calc(); if(now&lt;ans) ans=now; else if(exp((ans-now)/T)&lt;(double)rand()/RAND_MAX) swap(v[a],v[b]); T*=delta; &#125;&#125;int main()&#123; srand(20030909); T=read(); while(T--) &#123; n=read(); for(int i=1;i&lt;=n;i++) v[i]=read(); ans=Calc(); if(n&gt;1) for(int i=1;i&lt;=15;i++) SA(19630217); printf("%d\n",ans); &#125; return 0;&#125;]]></content>
      <categories>
        <category>模拟退火</category>
      </categories>
      <tags>
        <tag>随机算法</tag>
        <tag>模拟退火</tag>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「HAOI2006」均分数据]]></title>
    <url>%2F2019%2F03%2F08%2F%E3%80%8CHAOI2006%E3%80%8D%E5%9D%87%E5%88%86%E6%95%B0%E6%8D%AE-Solution%2F</url>
    <content type="text"><![CDATA[今天是国际劳动妇女节，各位妇女们有没有去劳动啊QwQ？反正我没去 传送门洛谷P2503 BZOJ2428 题解数据范围好小啊，看起来像是状压DP或者搜索之类的。蒟蒻我选择了模拟退火+贪心。 先考虑贪心，我们从$1$到$n$遍历整个序列，每次就把当前的元素丢到加和最小的那一组里。 显然光光这样贪心是肯定不行的，但是这样得到的答案还是比较优的。考虑怎样改进。 不难发现，如果遍历序列的顺序会影响最后的答案，那么可以考虑直接random_shuffle，打乱个比如$10^5​$次的，很大概率上就能刷到最优解了。 但是总感觉直接random_shuffle不太靠谱啊（不过貌似也能AC），但是蒟蒻我选择了模拟退火，感觉起来会靠谱一些（其实到底是不是更靠谱我也不知道，但是我想练一下模拟退火，所以就这样写了）。 每次随机拎出来两个元素交换，然后再计算当前答案就可以了。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;const int maxn=25,maxm=10;const double delta=0.991;int n,m,A[maxn];double X[maxn],avg,ret,ans;inline double Calc() //计算当前答案&#123; ret=avg=0; memset(X,0,sizeof(X)); for(int i=1;i&lt;=n;i++) &#123; int mi=1; for(int j=1;j&lt;=m;j++) if(X[j]&lt;X[mi]) mi=j; X[mi]+=A[i]; &#125; for(int i=1;i&lt;=m;i++) avg+=X[i]; avg/=m; for(int i=1;i&lt;=m;i++) ret+=(X[i]-avg)*(X[i]-avg); return sqrt(ret/m);&#125;inline void SA(double T)&#123; while(T&gt;1e-12) &#123; int a=rand()%n+1,b=rand()%n+1; while(a==b)&#123;a=rand()%n+1;b=rand()%n+1;&#125;//rand出来两个是一样的概率挺大的，这样可以提升效率 swap(A[a],A[b]); double now=Calc(); if(now&lt;ans) ans=now; else if(exp((ans-now)/T)&lt;(double)rand()/RAND_MAX) swap(A[a],A[b]); T*=delta; &#125;&#125;int main()&#123; srand(20030909); //黄霖的生日，种子什么的选大佬的生日肯定不会错的 scanf("%d%d",&amp;n,&amp;m); for(int i=1;i&lt;=n;i++) scanf("%d",&amp;A[i]); sort(A+1,A+1+n); ans=Calc(); for(int i=1;i&lt;=100;i++) SA(19630217); //退火120次又不会WA并且还比较快，求稳的话可以多来几次 printf("%.2lf\n",ans); return 0;&#125;]]></content>
      <categories>
        <category>模拟退火</category>
      </categories>
      <tags>
        <tag>随机算法</tag>
        <tag>模拟退火</tag>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「USACO」Haywire]]></title>
    <url>%2F2019%2F03%2F07%2F%E3%80%8CUSACO%E3%80%8DHaywire-Solution%2F</url>
    <content type="text"><![CDATA[什么神仙题目。蒟蒻我前前后后一共交了13次，才终于把这个退火搞懂了QwQ。 传送门洛谷P2210 题解蒟蒻我之前一直对模拟退火保持一个懵逼状态，今天是差不多把大概原理终于理清楚了QwQ。 其实基本上就是个退火的板子，但是蒟蒻我一直搞不清楚计算接受较差答案的概率。 一般来说，计算改成的式子是这样的： exp((now-ans)/T)&gt;rand()/RAND_MAX 其中now表示当前的答案，ans表示已知最优答案，也有可能是ans-now，总之应该是个负数。满足上式，则接受较差的答案。 其中$exp(x)$表示$e^x$，函数图像大概是这样的： 所以与当前最优答案差距越大，温度越低，$exp()$的值就越小，接受这个较差的答案的概率就越小。 还有，调参的时候，降温系数，停止退火的温度下限，温度初始值，退火的次数要一起调，尤其是退火的次数，多退几次还是很有必要的。种子可以用神仙学长ZZK的生日20020222。 代码1234567891011121314151617181920212223242526272829303132333435363738394041#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;algorithm&gt;using namespace std;const double delta=0.99;int n,fri[20][5],Q[20],ans;inline int Calc()&#123; int ret=0; for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=3;j++) if(Q[i]&gt;Q[fri[i][j]]) ret+=Q[i]-Q[fri[i][j]]; return ret;&#125;inline void SA(double T)&#123; while(T&gt;1e-12) &#123; int a=rand()%n+1,b=rand()%n+1; while(a==b)&#123;a=rand()%n+1;b=rand()%n+1;&#125; swap(Q[a],Q[b]); int now=Calc(); if(now&lt;ans) ans=now; else if(exp((ans-now)/T)&lt;(double)rand()/RAND_MAX) swap(Q[a],Q[b]); T*=delta; &#125;&#125;int main()&#123; srand(19260817); scanf("%d",&amp;n); for(int i=1;i&lt;=n;i++) scanf("%d%d%d",&amp;fri[i][1],&amp;fri[i][2],&amp;fri[i][3]); for(int i=1;i&lt;=n;i++) Q[i]=i; ans=Calc(); for(int i=1;i&lt;=500;i++) SA(19260817); printf("%d\n",ans); return 0;&#125;]]></content>
      <categories>
        <category>模拟退火</category>
      </categories>
      <tags>
        <tag>随机算法</tag>
        <tag>模拟退火</tag>
        <tag>搜索</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「HNOI2008」遥远的行星]]></title>
    <url>%2F2019%2F03%2F07%2F%E3%80%8CHNOI2008%E3%80%8D%E9%81%A5%E8%BF%9C%E7%9A%84%E8%A1%8C%E6%98%9F-Solution%2F</url>
    <content type="text"><![CDATA[又是一道玄学的题目QwQ。 传送门洛谷P3198 BZOJ1011 题解首先要一眼看到这题的重点：结果的相对误差不超过$5\%$即可。 所以考虑非完美算法。 首先，对于第$i​$个行星，对它有贡献的星球区间是$[1,\lfloor A\cdot i\rfloor]​$。设$R=\lfloor A\cdot i\rfloor​$。 然后再设一个阈值$S$比如$S=n^{0.4}$。 接下来的操作类似于分块，把区间$[1,R]$分成若干个块，每个块的大小为$S$，剩下的零头暴力搞，对于每一个完整的块，设这个块为$[a,b]$，那么这个块的贡献约等于 \frac{M[i]\cdot\sum_{j=a}^{b}M[j]}{i-\frac{a+b}{2}}这个式子可以构造前缀和来求。 把所有块的贡献加起来，注意下细节，就能过了QwQ。 代码12345678910111213141516171819202122232425262728#include&lt;cmath&gt;#include&lt;cstdio&gt;using namespace std;typedef long long LL;const int maxn=100005;int n,S,M[maxn];double A,ans;LL sum[maxn];inline int read()&#123; int ret=0,f=1;char ch=getchar(); while(ch&lt;'0'||ch&gt;'9')&#123;if(ch=='-')f=-f;ch=getchar();&#125; while(ch&gt;='0'&amp;&amp;ch&lt;='9')&#123;ret=ret*10+ch-'0';ch=getchar();&#125; return ret*f;&#125;int main()&#123; n=read();scanf("%lf",&amp;A);S=pow(n,0.38)+1e-10; for(int i=1;i&lt;=n;i++)&#123;M[i]=read();sum[i]=sum[i-1]+M[i];&#125; //构造前缀和 for(int i=1;i&lt;=n;i++) &#123; int R=i*A+1e-10,j;ans=0; //加上1e-10是为了防止精度损失 for(j=1;j+S&lt;=R;j+=S) //处理整块 ans+=(double)M[i]*(sum[j+S-1]-sum[j-1])/(i-(double)(2*j+S-1)/2); for(;j&lt;=R;j++) //处理零头 ans+=(double)M[i]*M[j]/(i-j); printf("%lf\n",ans); &#125; return 0;&#125;]]></content>
      <categories>
        <category>分块</category>
      </categories>
      <tags>
        <tag>分块</tag>
        <tag>概率</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「YNOI2016」这是我自己的发明]]></title>
    <url>%2F2019%2F03%2F06%2F%E3%80%8CYNOI2016%E3%80%8D%E8%BF%99%E6%98%AF%E6%88%91%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8F%91%E6%98%8E-Solution%2F</url>
    <content type="text"><![CDATA[震惊！我妻由乃当上了发明家！！！ 传送门洛谷P4689 BZOJ4940 题解又是一道由乃OI的毒瘤题QwQ。 前置技能，这题的简化版：SNOI2017 一个简单的询问。 做完上面一题，不难发现，只要爬到树上做这题就行了。 先一巴掌把树拍扁按照DFS序将树化成一个序列，这样每一颗子树对应着序列上的一段区间，然后就和之前那一题没什么区别了。 但是！！！竟然有换根这种操作。 不过不难发现，其实换根的操作就是假的。 先设当前的根为$rt$，询问子树的节点为$x$，不管怎样，我们就认为根始终是节点$1$。 然后又这么几种情况： $x=rt​$ 此时询问的就是整棵树。 $LCA(x,rt)\neq x$ 此时查询的就是当$1$为根时$x$的子树。 $LCA(x,rt)=x​$ 此时查询整棵树除去rt到x路径上离x最近的一个节点（就是图中好几个箭头指的那个点）的子树。可以拆成两个序列解决。那个节点可以通过倍增找到。 拆分成若干个序列之后，直接莫队即可。 还有记得要离散，权值是比较大的。我就因为没看数据范围，忘记离散，结果崩掉1个点QwQ 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798#include&lt;map&gt;#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;typedef long long LL;const int maxn=100005,maxm=500005;int n,m,q,rt,idx,tot,lnk[maxn],son[maxn*2],nxt[maxn*2],St[maxn],En[maxn],father[maxn][20],dep[maxn],A[maxn],B[maxn],S,Area[maxn],num,cnt1[maxn],cnt2[maxn],p1,p2;LL ans[maxm],now; //要开的东西实在太多，写的好丑QwQmap&lt;int,int&gt; hsh;inline int read()&#123; int ret=0,f=1;char ch=getchar(); while(ch&lt;'0'||ch&gt;'9')&#123;if(ch=='-')f=-f;ch=getchar();&#125; while(ch&gt;='0'&amp;&amp;ch&lt;='9')&#123;ret=ret*10+ch-'0';ch=getchar();&#125; return ret*f;&#125;inline void add_e(int x,int y)&#123;tot++;son[tot]=y;nxt[tot]=lnk[x];lnk[x]=tot;&#125;void Build(int now,int fa) //以节点1作为根节点初始化&#123; father[now][0]=fa;dep[now]=dep[fa]+1;idx++;A[idx]=B[now];St[now]=idx; for(int i=1;i&lt;=16;i++) father[now][i]=father[father[now][i-1]][i-1]; for(int i=lnk[now];i;i=nxt[i]) if(son[i]!=fa) Build(son[i],now); En[now]=idx;&#125;int LCA(int u,int v) //倍增LCA&#123; if(dep[u]&lt;dep[v]) swap(u,v); for(int i=16;i&gt;=0;i--) if(dep[father[u][i]]&gt;=dep[v]) u=father[u][i]; for(int i=16;i&gt;=0;i--) if(father[u][i]!=father[v][i])&#123;u=father[u][i];v=father[v][i];&#125; if(u!=v) return father[u][0]; return u;&#125;int GetSon(int u,int v)&#123; if(dep[u]&lt;dep[v]) swap(u,v); for(int i=16;i&gt;=0;i--) if(dep[father[u][i]]&gt;dep[v]) u=father[u][i]; return u;&#125;struct Interval&#123; int R1,R2,f,id; void Init()&#123;if(R1&gt;R2)swap(R1,R2);&#125; bool operator &lt; (const Interval&amp; b)const&#123;return Area[R1]&lt;Area[b.R1]||(Area[R1]==Area[b.R1]&amp;&amp;((Area[R1]&amp;1)?R2&lt;b.R2:R2&gt;b.R2));&#125;&#125;Q[maxm*16]; //注意一个询问最左可以拆成16个区间inline void Add(int L1,int R1,int L2,int R2,int id)&#123; num++;Q[num].R1=R1;Q[num].R2=R2;Q[num].f=1;Q[num].Init();Q[num].id=id; if(L1&gt;1)&#123;num++;Q[num].R1=L1-1;Q[num].R2=R2;Q[num].f=-1;Q[num].Init();Q[num].id=id;&#125; if(L2&gt;1)&#123;num++;Q[num].R1=R1;Q[num].R2=L2-1;Q[num].f=-1;Q[num].Init();Q[num].id=id;&#125; if(L1&gt;1&amp;&amp;L2&gt;1)&#123;num++;Q[num].R1=L1-1;Q[num].R2=L2-1;Q[num].f=1;Q[num].Init();Q[num].id=id;&#125;&#125;int main()&#123; n=read();m=read();S=sqrt(n)+1e-10;rt=1; for(int i=1;i&lt;=n;i++) A[i]=B[i]=read(); sort(B+1,B+1+n);int tep=0; for(int i=1;i&lt;=n;i++) if(!hsh[B[i]]) hsh[B[i]]=++tep; for(int i=1;i&lt;=n;i++) B[i]=hsh[A[i]]; //离散 for(int i=1;i&lt;=n;i++) Area[i]=(i-1)/S+1; for(int i=1;i&lt;n;i++) &#123; int a=read(),b=read(); add_e(a,b);add_e(b,a); &#125; Build(1,0); for(int i=1;i&lt;=m;i++) &#123; if(read()==1) rt=read(); else &#123; int x=read(),y=read();q++; int len1=0,L1[3],R1[3],len2=0,L2[3],R2[3]; if(x==rt)&#123;len1++;L1[len1]=1;R1[len1]=n;&#125; else if(LCA(x,rt)!=x)&#123;len1++;L1[len1]=St[x];R1[len1]=En[x];&#125; else&#123;int v=GetSon(rt,x);len1++;L1[len1]=1;R1[len1]=St[v]-1;if(En[v]&lt;n)&#123;len1++;L1[len1]=En[v]+1;R1[len1]=n;&#125;&#125; if(y==rt)&#123;len2++;L2[len2]=1;R2[len2]=n;&#125; else if(LCA(y,rt)!=y)&#123;len2++;L2[len2]=St[y];R2[len2]=En[y];&#125; else&#123;int v=GetSon(rt,y);len2++;L2[len2]=1;R2[len2]=St[v]-1;if(En[v]&lt;n)&#123;len2++;L2[len2]=En[v]+1;R2[len2]=n;&#125;&#125; for(int j=1;j&lt;=len1;j++) for(int k=1;k&lt;=len2;k++) Add(L1[j],R1[j],L2[k],R2[k],q); //拆成区间上莫队 &#125; &#125; sort(Q+1,Q+1+num); //莫队 for(int i=1;i&lt;=num;i++) &#123; while(p2&lt;Q[i].R2)&#123;p2++;cnt2[A[p2]]++;now+=cnt1[A[p2]];&#125; while(p1&gt;Q[i].R1)&#123;cnt1[A[p1]]--;now-=cnt2[A[p1]];p1--;&#125; while(p2&gt;Q[i].R2)&#123;cnt2[A[p2]]--;now-=cnt1[A[p2]];p2--;&#125; while(p1&lt;Q[i].R1)&#123;p1++;cnt1[A[p1]]++;now+=cnt2[A[p1]];&#125; ans[Q[i].id]+=now*Q[i].f; &#125; for(int i=1;i&lt;=q;i++) printf("%lld\n",ans[i]); return 0;&#125;]]></content>
      <categories>
        <category>莫队</category>
      </categories>
      <tags>
        <tag>LCA</tag>
        <tag>莫队</tag>
        <tag>DFS序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「IOI2011」Race]]></title>
    <url>%2F2019%2F03%2F05%2F%E3%80%8CIOI2011%E3%80%8DRace-Solution%2F</url>
    <content type="text"><![CDATA[又是一个赤裸裸的点分治QwQ。 传送门洛谷P4149 BZOJ2599 题解基本上就是点分治的裸题QwQ。 每次找重心，然后刷出当前处理的子树中每个点到重心的距离和经过的边的数量，直接搞就行了，记得要刷边数的最小值，还要判无解。没啥好说的QwQ。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include&lt;cstdio&gt;#include&lt;cstring&gt;using namespace std;const int maxn=200005,maxk=1000005,inf=0x3F3F3F3F;int n,K,tot,lnk[maxn],son[maxn*2],w[maxn*2],nxt[maxn*2],sum,siz[maxn],maxp[maxn],rt,dist[maxn],cnt[maxn],num,Q[maxn][2],ans=inf,jud[maxk],que[maxn];bool vis[maxn];inline int read()&#123; int ret=0,f=1;char ch=getchar(); while(ch&lt;'0'||ch&gt;'9')&#123;if(ch=='-')f=-f;ch=getchar();&#125; while(ch&gt;='0'&amp;&amp;ch&lt;='9')&#123;ret=ret*10+ch-'0';ch=getchar();&#125; return ret*f;&#125;inline void add_e(int x,int y,int z)&#123;tot++;son[tot]=y;w[tot]=z;nxt[tot]=lnk[x];lnk[x]=tot;&#125;void GetRoot(int now,int fa)&#123; siz[now]=1;maxp[now]=0; for(int i=lnk[now];i;i=nxt[i]) &#123; if(vis[son[i]]||son[i]==fa) continue; GetRoot(son[i],now);siz[now]+=siz[son[i]]; if(siz[son[i]]&gt;maxp[now]) maxp[now]=siz[son[i]]; &#125; if(sum-siz[now]&gt;maxp[now]) maxp[now]=sum-siz[now]; if(maxp[now]&lt;maxp[rt]) rt=now;&#125;void GetDist(int now,int fa)&#123; if(dist[now]&gt;K||cnt[now]&gt;ans) return; num++;Q[num][0]=dist[now];Q[num][1]=cnt[now]; for(int i=lnk[now];i;i=nxt[i]) if(!vis[son[i]]&amp;&amp;son[i]!=fa) &#123;dist[son[i]]=dist[now]+w[i];cnt[son[i]]=cnt[now]+1;GetDist(son[i],now);&#125;&#125;void Solve(int now)&#123; int len=1;que[1]=0;vis[now]=true;jud[0]=0; for(int i=lnk[now];i;i=nxt[i]) &#123; if(vis[son[i]]) continue; num=0;dist[son[i]]=w[i];cnt[son[i]]=1;GetDist(son[i],0); for(int j=1;j&lt;=num;j++) if(Q[j][1]+jud[K-Q[j][0]]&lt;ans) ans=Q[j][1]+jud[K-Q[j][0]]; for(int j=1;j&lt;=num;j++) &#123; if(Q[j][1]&lt;jud[Q[j][0]]) jud[Q[j][0]]=Q[j][1]; que[++len]=Q[j][0]; &#125; &#125; for(int i=1;i&lt;=len;i++) jud[que[i]]=inf; for(int i=lnk[now];i;i=nxt[i]) if(!vis[son[i]]) &#123;sum=siz[son[i]];rt=0;GetRoot(son[i],0);Solve(rt);&#125;&#125;int main()&#123; n=read();K=read(); for(int i=1;i&lt;n;i++) &#123; int a=read()+1,b=read()+1,c=read(); add_e(a,b,c);add_e(b,a,c); &#125; memset(jud,63,sizeof(jud)); maxp[0]=sum=n;GetRoot(1,0);Solve(rt); printf("%d\n",ans==inf?-1:ans); return 0;&#125;]]></content>
      <categories>
        <category>点分治</category>
      </categories>
      <tags>
        <tag>点分治</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「洛谷P4886」快递员]]></title>
    <url>%2F2019%2F03%2F05%2F%E3%80%8C%E6%B4%9B%E8%B0%B7P4886%E3%80%8D%E5%BF%AB%E9%80%92%E5%91%98-Solution%2F</url>
    <content type="text"><![CDATA[完了…没高中读了QwQ，我要去打工送快递！！！QwQ 传送门洛谷P4886 题解这题其实还是挺好玩的。 首先随便钦定一个点，临时作为快递中心 。 然后可以$O(n)$计算出每一组点对到快递中心的距离和。设点对到快递中心最大距离和为$Max$，可能有多个点对到快递中心的距离和都是$Max$那么就把它们都存下来。 如果当前的快递中心在任意一组距离最大的点对之间最短路径上，那么答案就是$Max$不可能再小了。 如果有任意两组点对，一组在当前快递中心的一棵子树里，另一组在另一棵子树里，那么答案同样也无法更小。 否则答案最优时的快递中心就有可能在当前唯一一棵有点对的子树中，那么就取这棵子树的重心作为临时快递中心，然后递归。由于每次取的都是重心，所以只会递归$\log n$层，总时间复杂度为$O(n\log n)​$。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include&lt;cstdio&gt;#include&lt;cstdlib&gt;using namespace std;const int maxn=100005;int n,m,u[maxn],v[maxn],tot,lnk[maxn],son[maxn*2],w[maxn*2],nxt[maxn*2],sum,siz[maxn],maxp[maxn],rt,sub[maxn],dist[maxn],que[maxn],ans=1000000000;bool vis[maxn];inline int read()&#123; int ret=0,f=1;char ch=getchar(); while(ch&lt;'0'||ch&gt;'9')&#123;if(ch=='-')f=-f;ch=getchar();&#125; while(ch&gt;='0'&amp;&amp;ch&lt;='9')&#123;ret=ret*10+ch-'0';ch=getchar();&#125; return ret*f;&#125;inline void add_e(int x,int y,int z)&#123;tot++;son[tot]=y;w[tot]=z;nxt[tot]=lnk[x];lnk[x]=tot;&#125;void GetRoot(int now,int fa) //找重心&#123; siz[now]=1;maxp[now]=0; for(int i=lnk[now];i;i=nxt[i]) &#123; if(vis[son[i]]||son[i]==fa) continue; GetRoot(son[i],now);siz[now]+=siz[son[i]]; if(siz[son[i]]&gt;maxp[now]) maxp[now]=siz[son[i]]; &#125; if(sum-siz[now]&gt;maxp[now]) maxp[now]=sum-siz[now]; if(maxp[now]&lt;maxp[rt]) rt=now;&#125;void GetDist(int now,int fa,int st)&#123; sub[now]=st; for(int i=lnk[now];i;i=nxt[i]) if(son[i]!=fa) &#123;dist[son[i]]=dist[now]+w[i];GetDist(son[i],now,st);&#125;&#125;inline void Print()&#123;printf("%d\n",ans);exit(0);&#125; //输出答案void Solve(int now)&#123; if(vis[now]) Print(); vis[now]=true;dist[now]=0; for(int i=lnk[now];i;i=nxt[i]) &#123;dist[son[i]]=w[i];GetDist(son[i],now,son[i]);&#125; //先暴力计算距离 int Max=0,len=0,las=0; for(int i=1;i&lt;=m;i++) &#123; if(dist[u[i]]+dist[v[i]]&gt;Max)&#123;len=1;que[len]=i;Max=dist[u[i]]+dist[v[i]];&#125; else if(dist[u[i]]+dist[v[i]]==Max) que[++len]=i; //刷最大距离和 &#125; if(Max&lt;ans) ans=Max; for(int i=1;i&lt;=len;i++) &#123; if(sub[u[que[i]]]!=sub[v[que[i]]]) Print(); //分情况考虑答案 if(!las) las=sub[u[que[i]]]; if(sub[u[que[i]]]!=las) Print(); &#125; rt=0;sum=siz[las];GetRoot(las,0);Solve(rt); //递归解决&#125;int main()&#123; n=read();m=read(); for(int i=1;i&lt;n;i++) &#123; int a=read(),b=read(),c=read(); add_e(a,b,c);add_e(b,a,c); &#125; for(int i=1;i&lt;=m;i++)&#123;u[i]=read();v[i]=read();&#125; sum=maxp[0]=n;GetRoot(1,0);Solve(rt); Print(); return 0;&#125;]]></content>
      <categories>
        <category>点分治</category>
      </categories>
      <tags>
        <tag>点分治</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「ZJOI2019模拟赛 十二」紫苑]]></title>
    <url>%2F2019%2F03%2F04%2F%E3%80%8CZJOI2019%E6%A8%A1%E6%8B%9F%E8%B5%9B%20%E5%8D%81%E4%BA%8C%E3%80%8D%E7%B4%AB%E8%8B%91-Solution%2F</url>
    <content type="text"><![CDATA[震惊！XZY竟然在ZJOI模拟赛时公然写代码造数据卡掉各种排序算法… 传送门原题来自UOJ，但各个子任务的分值略有不同。 UOJ83 题解这题是真的毒瘤QwQ。 Subtask #1观察一下计数排序法的代码，发现它在排序开始之前先把数组从$0$到$max(A_i)$清了一遍，那么只要给一个数，并且足够大即可。简直就是送分。 Subtask #2从第二个子任务开始，题目渐渐地毒瘤了起来。 首先你需要知道对于冒泡排序法，交换元素的次数等于逆序对的个数。 然后仔细分析代码，计算出冒泡排序法和计数排序法的具体复杂度，然后发现，只要构造一个长度为$1990​$的升序排列，然后选出$521​$对元素两两交换即可。此时冒泡刚好不会T，选排刚好T掉。 Subtask #3继续分析代码。发现快排没有随机化，那么就让每次选的基准数都是整个序列的最大或者最小值，然后手动二分得到$n​$的值应该为$1984​$。 Subtask #4对于冒泡排序法来说，一个降序的排列逆序对数最多，最容易T，但是对计数排序法就很不友好了。 然后再随便写几个数列试试看，发现类似于这样的序列很不错：2 2 2 1 1 1 0 0 0，手动多试几次值域和每个值出现的次数，就把这个点搞掉了。 Subtask #5和子任务4一样是要卡冒泡，同样构造一个类似的序列，然后手动胡乱修改几个数的出现次数，然后就过了。（大雾 Subtask #6woc最恶心的一个点，一定要好好分析一下随机排序法的代码。 首先发现随机函数是手写的，想到这里应该有玄机，赶紧仔细看看。 发现seed、RNG_a、RNG_b的初值都是一个奇怪的数字，在10进制下看不出啥玩意，打开计算器，转到二进制下看看。 然后发现RNG_a在二进制下是$1100101101010000000000001$，RNG_b是$100110100100000000000001$，后面都有一长串$0$和一个$1$。并且打乱数组时都是取随机值然后模$n$，然后想到如果$n$是$2$的正整数次幂的话就会有一些奇妙的性质：上面两个数字在模$n$意义下都等于$1​$。 考虑到最好应该让该程序打乱一遍数组就排序好，并且题目中时间上限给的十分准确，枚举$n$，发现$n=4096$时计时器的值刚好是$43026$，由此根据出题人心理学套路断定$n$一定等于$4096$。 然后再仔细观察，发现如果seed是一个确定的值，原序列各元素之间的大小关系可以确定。于是乎再枚举seed，发现$seed=2048$（模$n$的意义下）时倒推得到的原序列使得快排T掉了。可得$seed=2048$。 但是由于seed是一个根据输入序列生成的值，所以在确定原序列各元素之间的大小关系的情况下，关键在于如何构造一个合法的序列使得$seed=2048$。 所以可以先构造一个各元素值都尽量小的排列$A$，然后将所有大于$A[n]$的元素的值都加上个比如$10^6$，然后就可枚举$A[n]$，一点点把它的值变大，直到$seed=2048$。这样最后一个点就构造好了。 然后恭喜你获得荣誉勋章：毒瘤出题人。 代码Subtask #11//没有QwQ，手造 Subtask #21234567891011121314#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;int n,A[2000];int main()&#123; n=1990; printf("%d\n",n); for(int i=1;i&lt;=n;i++) A[i]=i; for(int i=1;i&lt;=521;i++) swap(A[i*2],A[i*2-1]); for(int i=1;i&lt;=n;i++) printf("%d%c",A[i],i==n?'\n':' '); return 0;&#125; Subtask #3123456789101112131415161718#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;int n,A[5000],counter;int main()&#123; n=1984; printf("%d\n",n); for(int i=1;i&lt;=n;i++) A[i]=i; for(int i=1;i&lt;=n;i++) &#123; int j=(i+1)/2; swap(A[i],A[j]); &#125; for(int i=1;i&lt;=n;i++) printf("%d%c",A[i],i==n?'\n':' '); return 0;&#125; Subtask #4其实后面少了几个0，可以手动补上，不补也没关系。 12345678910#include&lt;cstdio&gt;using namespace std;int main()&#123; printf("%d\n",1012); for(int i=30;i&gt;=0;i--) for(int j=1;j&lt;=32;j++) printf("%d ",i); return 0;&#125; Subtask #5用这个代码生成数据后还有手动乱搞一下QwQ。 12345678910#include&lt;cstdio&gt;using namespace std;int main()&#123; printf("%d\n",1015); for(int i=27;i&gt;=0;i--) for(int j=1;j&lt;=40;j++) printf("%d ",i); return 0;&#125; Subtask #612345678910111213141516171819202122232425262728293031323334#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;int n,A[5000],counter;unsigned int seed,RNG_a,RNG_b;void RNG_init()&#123; counter++; seed = 2166136261u; counter++; RNG_a = 26648577u; counter++; RNG_b = 10108929u;&#125;int main()&#123; freopen("Shion.in","wb",stdout); n=4096;seed=2166136261u; printf("%d\n",n); for(int i=1;i&lt;=n;i++) A[i]=i; for(int i=n;i;i--) &#123; int j=(i+2048)%4096+1; swap(A[i],A[j]); &#125; for(int i=1;i&lt;=n;i++) if(A[i]&gt;A[n]) A[i]+=1000000; for(int i=1;i&lt;n;i++) seed=(seed*16777619u)^A[i]; while(((seed*16777619u)^A[n])%(unsigned int)4096!=(unsigned int)2048) A[n]++; for(int i=1;i&lt;=n;i++) printf("%d%c",A[i],i==n?'\n':' '); return 0;&#125; 答案戳我呀^w^ 终于写完了QwQ，出题人真是毒瘤QwQ。]]></content>
      <categories>
        <category>分析代码</category>
      </categories>
      <tags>
        <tag>非传统题</tag>
        <tag>提交答案题</tag>
        <tag>排序</tag>
        <tag>分析代码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「AHOI2001」多项式乘法]]></title>
    <url>%2F2019%2F03%2F04%2F%E3%80%8CAHOI2001%E3%80%8D%E5%A4%9A%E9%A1%B9%E5%BC%8F%E4%B9%98%E6%B3%95-Solution%2F</url>
    <content type="text"><![CDATA[来水一发大模拟QwQ。 传送门洛谷P2553 题解好久没写这种处理字符串的大模拟了QwQ。 这题每个多项式的长度都很短，系数也很小，所以直接$O(n^2)$的暴力搞过去就行了。 数据范围大一点的话FFT即可。 注意可能有空格。 注意可能在一行中可能包含一个不完整的表达式（可能没有”*”或者”()”），注意应该什么也不要输出，也要注意不要RE或者怎么样了。 总而言之还是挺好写的QwQ。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include&lt;cstdio&gt;#include&lt;cstring&gt;using namespace std;int len,a1[50],a2[50],ans[100];char exp[1000];int main()&#123; while(gets(exp),exp[0]) &#123; len=strlen(exp);memset(a1,0,sizeof(a1));memset(a2,0,sizeof(a2));memset(ans,0,sizeof(ans)); int i=1; while(exp[i]!=')'&amp;&amp;i&lt;len) &#123; int x=0,z=0; while(exp[i]&lt;'0'||exp[i]&gt;'9') i++; x=exp[i]-'0'; if('0'&lt;=exp[i+1]&amp;&amp;exp[i+1]&lt;='9')&#123;i++;x=x*10+exp[i]-'0';&#125; i++; if(exp[i]=='a') &#123; i++;i++;z=exp[i]-'0'; if('0'&lt;=exp[i+1]&amp;&amp;exp[i+1]&lt;='9')&#123;i++;z=z*10+exp[i]-'0';&#125; i++; &#125; a1[z]+=x; &#125; i++; while(exp[i]!=')'&amp;&amp;i&lt;len) &#123; int x=0,z=0; while(exp[i]&lt;'0'||exp[i]&gt;'9') i++; x=exp[i]-'0'; if('0'&lt;=exp[i+1]&amp;&amp;exp[i+1]&lt;='9')&#123;i++;x=x*10+exp[i]-'0';&#125; i++; if(exp[i]=='a') &#123; i++;i++;z=exp[i]-'0'; if('0'&lt;=exp[i+1]&amp;&amp;exp[i+1]&lt;='9')&#123;i++;z=z*10+exp[i]-'0';&#125; i++; &#125; a2[z]+=x; &#125; for(int i=0;i&lt;=30;i++) for(int j=0;j&lt;=30;j++) ans[i+j]+=a1[i]*a2[j]; bool first=false; for(int j=60;j&gt;=0;j--) &#123; if(!ans[j]) continue; if(first) putchar('+'); else first=true; if(j&gt;0) printf("%da^%d",ans[j],j); else printf("%d",ans[j]); &#125; putchar('\n'); memset(exp,0,sizeof(exp)); &#125; return 0;&#125;]]></content>
      <categories>
        <category>模拟</category>
      </categories>
      <tags>
        <tag>多项式乘法</tag>
        <tag>FFT</tag>
        <tag>模拟</tag>
        <tag>字符串处理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「SNOI2017」一个简单的询问]]></title>
    <url>%2F2019%2F03%2F04%2F%E3%80%8CSNOI2017%E3%80%8D%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E8%AF%A2%E9%97%AE-Solution%2F</url>
    <content type="text"><![CDATA[嗯哼？这不是赤裸裸的莫队吗QwQ？ 传送门BZOJ5016 题解首先拐一道弯，令$F(L1,R1,L2,R2)=\sum_{x=0}^{\infty}{get(L1,R1,x)\cdot get(L2,R2,x)}​$。 那么根据容斥的原理，可以得到$F(L1,R1,L2,R2)=F(1,R1,1,R2)-F(1,L1,1,R2)-F(1,R1,1,L2)+F(1,L1,1,L2)$。 那么就把一个询问先拆成四个询问。 然后只要想办法求出$F(1,x,1,y)$。裸的莫队啊啊啊！！！注意细节即可。 然后就没有然后了。 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;typedef long long LL;const int maxn=50005;int n,q,A[maxn],S,Area[maxn],tot,cnt1[maxn],cnt2[maxn],p1,p2;LL ans[maxn],now;inline int read()&#123; int ret=0,f=1;char ch=getchar(); while(ch&lt;'0'||ch&gt;'9')&#123;if(ch=='-')f=-f;ch=getchar();&#125; while(ch&gt;='0'&amp;&amp;ch&lt;='9')&#123;ret=ret*10+ch-'0';ch=getchar();&#125; return ret*f;&#125;struct Interval&#123; int R1,R2,f,id; void Init()&#123;if(R1&gt;R2)swap(R1,R2);&#125; bool operator &lt; (const Interval&amp; b)const&#123;return Area[R1]&lt;Area[b.R1]||(Area[R1]==Area[b.R1]&amp;&amp;((Area[R1]&amp;1)?R2&lt;b.R2:R2&gt;b.R2));&#125;&#125;Q[maxn*4];int main()&#123; n=read();S=sqrt(n)+1e-10; for(int i=1;i&lt;=n;i++) A[i]=read(); for(int i=1;i&lt;=n;i++) Area[i]=(i-1)/S+1; q=read(); for(int i=1;i&lt;=q;i++) &#123; int L1=read(),R1=read(),L2=read(),R2=read(); tot++;Q[tot].R1=R1;Q[tot].R2=R2;Q[tot].f=1;Q[tot].Init();Q[tot].id=i; tot++;Q[tot].R1=L1-1;Q[tot].R2=R2;Q[tot].f=-1;Q[tot].Init();Q[tot].id=i; tot++;Q[tot].R1=R1;Q[tot].R2=L2-1;Q[tot].f=-1;Q[tot].Init();Q[tot].id=i; tot++;Q[tot].R1=L1-1;Q[tot].R2=L2-1;Q[tot].f=1;Q[tot].Init();Q[tot].id=i; &#125; sort(Q+1,Q+1+tot); for(int i=1;i&lt;=tot;i++) &#123; while(p2&lt;Q[i].R2)&#123;p2++;cnt2[A[p2]]++;now+=cnt1[A[p2]];&#125; while(p1&gt;Q[i].R1)&#123;cnt1[A[p1]]--;now-=cnt2[A[p1]];p1--;&#125; while(p2&gt;Q[i].R2)&#123;cnt2[A[p2]]--;now-=cnt1[A[p2]];p2--;&#125; while(p1&lt;Q[i].R1)&#123;p1++;cnt1[A[p1]]++;now+=cnt2[A[p1]];&#125; ans[Q[i].id]+=now*Q[i].f; &#125; for(int i=1;i&lt;=q;i++) printf("%lld\n",ans[i]); return 0;&#125;]]></content>
      <categories>
        <category>莫队</category>
      </categories>
      <tags>
        <tag>莫队</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「YNOI2016」掉进兔子洞]]></title>
    <url>%2F2019%2F02%2F25%2F%E3%80%8CYNOI2016%E3%80%8D%E6%8E%89%E8%BF%9B%E5%85%94%E5%AD%90%E6%B4%9E-Solution%2F</url>
    <content type="text"><![CDATA[震惊！我妻由乃掉进了兔子洞里… 传送门洛谷P4688 BZOJ4939 题解这题再YNOI里应该算简单的吧，毕竟代码挺短的。 根据题意，要求的答案就是三个区间的长度和减去三个区间的交集长度的三倍。 因为要求交集，自然而然想到用bitset。只要上莫队求出每个询问的三个区间的bitset，求交集即可。 但是这个交集还不是那么好求，要拐个弯QwQ。 先对原序列进行离散化，定义离散化之后的$A_i$表示原序列中有多少个数小于原$A_i$。 然后考虑一个区间，现在加入一个元素，怎么维护bitset。由于存在相同元素，所以bitset上可能有好多位都是留给与当前元素相同的元素的，那么就需要从第$A_i$个位置从左往右找到第一个空位把新元素按上去，这样进行&amp;运算的时候就没有问题了，找位置的时候事先记一下当前区间每个值已经出现多少次了，就能O(1)找到。 这样进行&amp;运算就没有什么问题了。 还有就是由于直接开$10^5$个长度为$10^5$的bitset会MLE，所以把所有询问分三次处理就好了。 感觉莫队+bitset的题常数都不小，蒟蒻我一般不吸氧过不了QwQ。 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include&lt;map&gt;#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;bitset&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;const int maxn=100005,maxm=34005;int n,tot,m,A[maxn],B[maxn],sum,S,Area[maxn],ans[maxn],cnt[maxn];map&lt;int,int&gt; C;bitset&lt;maxn&gt; col[maxm],tep;bool vis[maxm];inline int read()&#123; int ret=0,f=1;char ch=getchar(); while(ch&lt;'0'||ch&gt;'9')&#123;if(ch=='-')f=-f;ch=getchar();&#125; while(ch&gt;='0'&amp;&amp;ch&lt;='9')&#123;ret=ret*10+ch-'0';ch=getchar();&#125; return ret*f;&#125;struct Interval&#123; int L,R,id; bool operator &lt; (const Interval&amp; b)const&#123;return Area[L]&lt;Area[b.L]||(Area[L]==Area[b.L]&amp;&amp;((Area[L]&amp;1)?Area[R]&lt;Area[b.R]:Area[R]&gt;Area[b.R]));&#125;&#125;Q[maxm*3];inline void inc(int x)&#123;tep[x+cnt[x]]=1;cnt[x]++;&#125;inline void dec(int x)&#123;cnt[x]--;tep[x+cnt[x]]=0;&#125;inline void Solve()&#123; int num=0,L=1,R=1;tep[A[1]]=1;cnt[A[1]]++; for(int i=1;i&lt;=m&amp;&amp;i&lt;=34000;i++) &#123; num++;Q[num].L=read();Q[num].R=read();Q[num].id=i;ans[i]+=Q[num].R-Q[num].L+1; num++;Q[num].L=read();Q[num].R=read();Q[num].id=i;ans[i]+=Q[num].R-Q[num].L+1; num++;Q[num].L=read();Q[num].R=read();Q[num].id=i;ans[i]+=Q[num].R-Q[num].L+1; &#125; sort(Q+1,Q+1+num); for(int i=1;i&lt;=num;i++) &#123; while(L&gt;Q[i].L) inc(A[--L]); while(R&lt;Q[i].R) inc(A[++R]); while(L&lt;Q[i].L) dec(A[L++]); while(R&gt;Q[i].R) dec(A[R--]); if(vis[Q[i].id]) col[Q[i].id]&amp;=tep; else&#123;col[Q[i].id]=tep;vis[Q[i].id]=true;&#125; &#125; for(int i=1;i&lt;=m&amp;&amp;i&lt;=34000;i++) &#123; ans[i]-=col[i].count()*3; printf("%d\n",ans[i]); &#125; m-=34000;memset(ans,0,sizeof(ans));memset(cnt,0,sizeof(cnt));memset(vis,0,sizeof(vis));tep.reset();&#125;int main()&#123; n=read();m=read();S=sqrt(n)+1e-10; for(int i=1;i&lt;=n;i++) A[i]=B[i]=read(); for(int i=1;i&lt;=n;i++) Area[i]=(i-1)/S+1; sort(B+1,B+1+n); for(int i=1,j;i&lt;=n;i=j+1) &#123; j=i; while(j&lt;n&amp;&amp;B[j+1]==B[i]) j++; C[B[i]]=sum;sum+=j-i+1; &#125; for(int i=1;i&lt;=n;i++) A[i]=C[A[i]]; while(m&gt;0) Solve(); return 0;&#125;]]></content>
      <categories>
        <category>莫队</category>
      </categories>
      <tags>
        <tag>莫队</tag>
        <tag>bitset</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「ZJOI2019模拟赛 六」硬币]]></title>
    <url>%2F2019%2F02%2F18%2F%E3%80%8CZJOI2019%E6%A8%A1%E6%8B%9F%E8%B5%9B%20%E5%85%AD%E3%80%8D%E7%A1%AC%E5%B8%81-Solution%2F</url>
    <content type="text"><![CDATA[模拟赛爆炸祭QwQ… 题面硬币coin.cpp coin.in/.out 时间限制:1s 空间限制:512M 题目描述KK有一枚硬币，他想做如下实验： 他会不停抛掷这枚硬币，并且记录下每次硬币是哪面朝上，当出现连续两次都是正面朝上时，就停止实验。 设总共抛掷了 $M$ 次后停止实验（即第 $M$ 次和第 $M-1$ 次都是正面朝上，而之前没有出现过连续两次正面朝上），令 $P(n)$ 表示 $M$ 是 $n$ 的倍数的概率。 比如 $P(2)={3\over 5}，P(3)={9\over 31}$，可以发现 $P(n)$ 总是可以表示成一个分数。 现在KK想知道 $P(n)$ 对 $10^9+9$ 取模后的结果。 输入格式一行，一个数 $n$。 输出格式一行，表示 $P(n)$ 对 $10^9+9$ 取模后的结果。 样例数据input1 13 output1 1548387102 input2 1100 output2 1618264982 input3 1100000000000000000 output3 1346869049 数据规模与约定对于 $30\%$ 的数据 $n\le 100$ 对于 $50\%​$ 的数据 $n\le 1000000​$ 对于 $80\%​$ 的数据 $n\le 1000000000​$ 对于 $100\%​$ 的数据 $n\le 10^{18}​$ 小贴士对于 ${n\over m}​$ 及一个质数 $p​$，${n\over m}​$ 在模 $p​$ 意义下等于 $n\times m^{p-2}​$ $\sqrt{5}​$在模$10^9+9​$的意义下的值为$383008016​$。 题解这道题基本上就没有部分分，做出来了就100，否则就0分。然而蒟蒻我还是太菜了，所以我必定属于后者。然后这场模拟赛我就光荣地爆炸了QwQ 这题推起来其实挺烦的，但是在省选题里面好像应该算简单了的吧。看来我还是太菜了。 废话不多说，接下来马上进入愉快的推式子环节。woc哪里愉快了 设$C(i)$表示抛了$i$次硬币，没有连续两次正面朝上的方案数。 令$1$表示正面朝上，$0$表示反面朝上，那么$C(i)$也就是长度为$i$的不存在连续两个$1$的01串的个数。 假设我们已近求出了$C(i-1)​$和$C(i-2)​$，现在考虑如何来计算出$C(i)​$的值。比如$i=3​$。 长度为$2$的串一共有$4$个，分别是00、01、10、11，其中串11是不合法的，其余的都是合法的。把这些串复制两份，一份前面加0，一次前面加1，这样就能得到长度为3的8个01串。 如果再前面加0，那么原来合法的串依然合法，原来不合法的串依然不合法。所以可以先把$C(i-1)$先累加到$C(i)$上。 如果在前面加1，那么原来以1开头的串就都不合法了，原来以0开头的串合法性不变。原来一共有$C(i-2)$个0开头的合法串，这些串同样也要累加到$C(i)$上。 所以就有递推式：$C(i)=C(i-1)+C(i-2)​$，其中$C(1)=2,C(2)=3​$。所以这就是一个错了2位的斐波那契数列。 再设$F(i)$表示抛了$i$次硬币，恰好结束的概率。 那么就有$F(i)=\frac{C(i-3)}{2^{i-3}}*\frac{1}{8}​$。因为当且仅当前$i-3​$次都要合法，第$i-2​$反面朝上，最后两次都正面朝上才会停止。 所以 F(i)=\frac{C(i-3)}{2^{i-3}}*\frac{1}{8}=\frac{C(i-3)}{2^i}=\frac{Fib(i-1)}{2^i}再根据题意，可得 P(n)=F(n)+F(2n)+\cdots+F(\infty n)=\sum_{i=1}^{\infty}{\frac{Fib(in-1)}{2^{in}}}其中斐波那契数列有一个通项公式 Fib(n)=\frac{\sqrt{5}}{5}((\frac{1+\sqrt{5}}{2})^n-(\frac{1-\sqrt{5}}{2})^n)再设 \alpha=\frac{1+\sqrt{5}}{2},\beta=\frac{1-\sqrt{5}}{2}所以 P(n)=\sum_{i=1}^{\infty}{\frac{Fib(in-1)}{2^{in}}}= \sum_{i=1}^{\infty}{\frac{\sqrt{5}}{5}\cdot\frac{\alpha^{in-1}-\beta^{in-1}}{2^{in}}}然后发现上面那个式子并不好处理，再化简一下 \sum_{i=1}^{\infty}{\frac{\sqrt{5}}{5}\cdot\frac{\alpha^{in-1}-\beta^{in-1}}{2^{in}}}= \frac{\sqrt{5}}{5}\sum_{i=1}^{\infty}{\frac{\alpha^{in-1}}{2^{in}}}-\frac{\sqrt{5}}{5}\sum_{i=1}^{\infty}{\frac{\beta^{in-1}}{2^{in}}}= \frac{\sum_{i=1}^{\infty}{\frac{\alpha^{in-1}}{2^{in}}}- \sum_{i=1}^{\infty}{\frac{\beta^{in-1}}{2^{in}}}}{\sqrt{5}}回想一下，发现带有无穷的式子可以通过等比数列还搞，于是想办法把上式搞出等比数列 上式=\frac{\frac{1}{\alpha}\sum_{i=1}^{\infty}{\frac{\alpha^{in}}{2^{in}}}- \frac{1}{\beta}\sum_{i=1}^{\infty}{\frac{\beta^{in}}{2^{in}}}}{\sqrt{5}}然后$\sum{i=1}^{\infty}{\frac{\alpha^{in}}{2^{in}}}​$就是等比数列，想办法把它的值算出来，后面的$\sum{i=1}^{\infty}{\frac{\beta^{in}}{2^{in}}}​$也一样的。 \sum_{i=1}^{\infty}{\frac{\alpha^{in}}{2^{in}}}=\sum_{i=1}^{\infty}{(\frac{\alpha^{n}}{2^{n}})^{i}}\\ 设q=\frac{\alpha^{n}}{2^{n}}\\ 设S=\sum_{i=1}^{\infty}{(\frac{\alpha^{n}}{2^{n}})^{i}}=q^1+q^2+q^3+\cdots+q^{\infty}\\ 则qS=q^2+q^3+q^4+\cdots+q^{\infty}\\ 故(q-1)S=-q\\ S=\frac{q}{1-q}求出$S$之后再代回原始中就能求出$P(n)$的值了。 终于写完了QwQ… 代码推了一长串，代码是真的短QwQ 123456789101112131415161718192021222324252627282930#include&lt;cmath&gt;#include&lt;cstdio&gt;using namespace std;typedef long long LL;const LL TT=1000000009,sqrt5=383008016,inv2=500000005;LL n;LL QP(LL a,LL b)&#123; LL ret=1,w=a; while(b) &#123; if(b&amp;1) ret=ret*w%TT; w=w*w%TT;b&gt;&gt;=1; &#125; return ret;&#125;LL Sum(LL q)&#123; q=QP(q,n); return q*QP((1-q+TT)%TT,TT-2)%TT;&#125;int main()&#123; freopen("coin.in","r",stdin); freopen("coin.out","w",stdout); scanf("%lld",&amp;n); LL alpha=(1+sqrt5)*inv2%TT,beta=(1+TT-sqrt5)*inv2%TT; printf("%lld\n",(QP(sqrt5,TT-2)*(QP(alpha,TT-2)*Sum(alpha*inv2%TT)%TT-QP(beta,TT-2)*Sum(beta*inv2%TT)%TT)%TT+TT)%TT); return 0; &#125;]]></content>
      <categories>
        <category>概率数学</category>
      </categories>
      <tags>
        <tag>概率</tag>
        <tag>数学</tag>
        <tag>无限</tag>
        <tag>逆元</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「洛谷P1654/BZOJ4318」OSU！]]></title>
    <url>%2F2019%2F02%2F15%2F%E3%80%8C%E6%B4%9B%E8%B0%B7P1654%20BZOJ4318%E3%80%8DOSU!-Solution%2F</url>
    <content type="text"><![CDATA[这题代码是真的短，但我就是做不来QwQ… 传送门洛谷P1654 BZOJ4318 题解感觉这个期望DP真的挺有趣的。 设$X1_i$表示以$i$为结尾的连续$1$串的期望长度，$X2_i$表示 以$i$为结尾的连续$1$串长度的平方的期望，$F_i$表示$i$次操作后的期望得分。 首先来看看$X1$该怎么递推，第$i$次操作有$Pi$的概率成功，贡献为$X1{i-1}+1$；还有$1-P_i$的概率失败，贡献为$0$，所以 X1_i=(X1_{i-1}+1) \cdot Pi+0 \cdot(1-P_i)=(X1_{i-1}+1) \cdot Pi再来看$X2$，根据完全平方公式$(x+1)^2=x^2+2x+1$，同理可得 X2_i=(X2_{i-1}+2\cdot X1_{i-1}+1) \cdot P_i再根据完全立方公式$(x+1)^3=x^3+3x^2+3x+1$，同理可得 F_i=(F_{i-1}+3 \cdot X2_{i-1}+3 \cdot X1_{i-1}+1) \cdot P_i+F_{i-1}(1-P_i)\\ =F_{i-1}+(3 \cdot X2_{i-1}+3 \cdot X1_{i-1}+1) \cdot P_i然后$F_n$就是答案 。 然后，然后就…没了。 代码真的很短哎QwQ。 1234567891011121314151617#include&lt;cstdio&gt;using namespace std;const int maxn=100005;int n;double P[maxn],X1[maxn],X2[maxn],F[maxn];int main()&#123; scanf("%d",&amp;n); for(int i=1;i&lt;=n;i++) &#123; scanf("%lf",&amp;P[i]); X1[i]=(X1[i-1]+1)*P[i]; X2[i]=(X2[i-1]+2*X1[i-1]+1)*P[i]; F[i]=F[i-1]+(3*X2[i-1]+3*X1[i-1]+1)*P[i]; &#125; printf("%.1lf\n",F[n]); return 0;&#125;]]></content>
      <categories>
        <category>期望DP</category>
      </categories>
      <tags>
        <tag>概率</tag>
        <tag>期望DP</tag>
        <tag>期望</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「AHOI2017/HNOI2017」大佬]]></title>
    <url>%2F2019%2F02%2F13%2F%E3%80%8CAHOI2017%20HNOI2017%E3%80%8D%E5%A4%A7%E4%BD%AC-Solution%2F</url>
    <content type="text"><![CDATA[这题面，生动形象，饶有趣味，interesting！出题人呢？ 传送门洛谷P3724 BZOJ4828 题解先把又臭又长的题面读两遍，然后很显然，保证自己不死和把大佬怼死是两个不同的环节，两个问题，分别解决，互不干扰（这话咋这么耳熟呢）。 设$F[i][j]​$表示到了第$i​$天，自己的自信值为$j​$，最多可以多少天不刷水题。 那么就可以腾出$\max{i=1}^{n}{\max{j=0}^{mc}{F[i][j]}}​$天来专门怼大佬。 注意不是$\max_{j=0}^{mc}{F[n][j]}​$，可能还没到第$n​$天就可以把大佬怼死，但是到了第$n​$天不可能不被大佬怼死。 那么问题就转化为：给你$D​$天，每天可以执行操作1、3、4或5，问你能不能把大佬的自信值怼到$0​$？ 注意是怼到$0​$，不能单纯刷DP取最大值，那样可能把大佬的自信值怼到负，而且可以怼的自信值不一定连续。 设一种只用操作3、4、5的怼大佬方案为$(Hurt，Day)​$表示用了$Day​$天对大佬产生了$Hurt​$点伤害，发现数据范围并不大，所以就可以用BFS把所有方案都列出来。至于到底有多少种方案，玄学，反正数组开大点就好了。$Hash​$判重，直接调STL里的map的话时效会差一些。（但是我懒，所以调了map） 然后把所有怼大佬的方案按照伤害排序，用两个指针，一头一尾扫过去就好了，注意两个方案的伤害之和不能超过大佬的自信值，且剩下位怼完的自信值可以用剩余的天数通过操作1把大佬怼死就行了。 代码稍微有点长QwQ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091#include&lt;map&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;typedef long long LL;const int maxn=105,inf=0x3F3F3F3F;int n,m,mc,a[maxn],w[maxn],D,F[maxn][maxn],tot,T[2000005];inline int read()&#123; int ret=0,f=1;char ch=getchar(); while(ch&lt;'0'||ch&gt;'9')&#123;if(ch=='-')f=-f;ch=getchar();&#125; while(ch&gt;='0'&amp;&amp;ch&lt;='9')&#123;ret=ret*10+ch-'0';ch=getchar();&#125; return ret*f;&#125;inline void GetFightDays() //刷DP计算天数&#123; memset(F,-1,sizeof(F));F[0][mc]=0; for(int i=1;i&lt;=n;i++) &#123; for(int j=a[i];j&lt;=mc;j++) //注意不要越界 &#123; F[i][j-a[i]]=max(F[i][j-a[i]],F[i-1][j]+1); int x=min(mc,j-a[i]+w[i] ); F[i][x]=max(F[i][x],F[i-1][j]); &#125; &#125; for(int i=1;i&lt;=n;i++) for(int j=0;j&lt;=mc;j++) if(F[i][j]&gt;D) D=F[i][j];&#125;struct Node&#123;int F,L;&#125;Q[2000005];map&lt;int,map&lt;int,int&gt; &gt; Day;struct Plan&#123; int Hurt,Days; bool operator &lt; (const Plan&amp; b)const&#123;return Hurt&lt;b.Hurt;&#125;&#125;P[2000005];inline void BFS()&#123; int hed=0,til=1,ddd; Q[1]=(Node)&#123;1,0&#125;;Day[1][0]=T[1]=1;//刷BFS搞出所有可能的方案 while(hed!=til) &#123; hed++;ddd=Day[Q[hed].F][Q[hed].L]; if(ddd&gt;=D) continue; if(!Day[Q[hed].F][Q[hed].L+1]) &#123; til++;Q[til].F=Q[hed].F;Q[til].L=Q[hed].L+1; Day[Q[til].F][Q[til].L]=T[til]=ddd+1; &#125; if((LL)Q[hed].F*Q[hed].L&lt;=100000000&amp;&amp;!Day[Q[hed].F*Q[hed].L][Q[hed].L]) &#123; til++;Q[til].F=Q[hed].F*Q[hed].L;Q[til].L=Q[hed].L; Day[Q[til].F][Q[til].L]=T[til]=ddd+1; &#125; &#125; P[++tot]=(Plan)&#123;0,0&#125;; for(int i=1;i&lt;=til;i++) P[++tot]=(Plan)&#123;Q[i].F,Day[Q[i].F][Q[i].L]&#125;; sort(P+1,P+1+tot);&#125;int Check(int C)&#123; int j=1,mi=inf; for(int i=tot;i;i--) &#123; while(i&gt;j&amp;&amp;P[i].Hurt+P[j].Hurt&lt;=C) &#123; mi=min(mi,P[j].Days-P[j].Hurt); j++; &#125; if(D&gt;=C-P[i].Hurt+P[i].Days+mi) return 1; &#125; return 0;&#125;int main()&#123; n=read();m=read();mc=read(); for(int i=1;i&lt;=n;i++) a[i]=read(); for(int i=1;i&lt;=n;i++) w[i]=read(); GetFightDays(); BFS(); while(m--) &#123; int Ci=read(); printf("%d\n",Check(Ci)); &#125; return 0;&#125;]]></content>
      <categories>
        <category>BFS</category>
      </categories>
      <tags>
        <tag>BFS</tag>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「洛谷P5108」仰望半月的夜空]]></title>
    <url>%2F2019%2F02%2F11%2F%E3%80%8C%E6%B4%9B%E8%B0%B7P5108%E3%80%8D%E4%BB%B0%E6%9C%9B%E5%8D%8A%E6%9C%88%E7%9A%84%E5%A4%9C%E7%A9%BA-Solution%2F</url>
    <content type="text"><![CDATA[这是一个标算与瞎搞的故事… 传送门洛谷P5108 题解蒟蒻我人生的第一道1次过样例并AC的黑题。（然而写的并不是标算，这题貌似也没有达到黑题的难度） 这题的标算是后缀数组，然鹅蒟蒻我选择了瞎搞QwQ。 此题瞎搞的关键点在于找出题目中隐藏的单调性。（大雾） 首先，如果先考虑长度为$1$的子串，再考虑长度为$2$的，长度为$3$的…那么分别一共有$n$个、$n-1$个、$n-2$个。 并不好搞。 所以倒着来处理。（汗 长度为$n$的子串可以由$1$开头、长度为$n-2$的子串可以由2开头…每次可能的开头增加一个。 并且其中有一定的单调性：对于合法的开头$i,j$，如果当前$i$比$j$优，那么之后$j$永远不可能比$i$优。 所以构造一个单调栈$stk[]$，每次直接把新增的合法开头扔进栈顶，然后不断比较当前长度下$stk[top]$和$stk[top-1]$。如果此时$stk[top]$不比$stk[top-1]$优，直接弹掉它，维护栈的单调性。 维护操作结束后，栈顶就是当前最优解。 但是还有一个关键问题没有解决：如何快速比较两个较长字符串的大小？ 既然原字符串是静态的，那么可以通过Hash+二分找出两个字符串的最长相同前缀，然后比较下一位即可。 瞎搞完成 ，总时间复杂度为$\Theta(n\log n)$。 然后… ZS：嗯哼？后缀数组的题让你Hash+二分过了？看我拍一宿造数据卡掉你！！！ 蒟蒻我：老师我写了双Hash！！！ ZS：嗯哼！喂？是中国人民解放军国防科技大学吗？麻烦你们把天河二号借我用一宿… 然后就没有然后了QwQ… 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include&lt;cstdio&gt;using namespace std;typedef long long LL;const int maxn=300005;int sig,n,S[maxn],top,stk[maxn],ans[maxn];char tep[maxn];inline int read()&#123; int ret=0,f=1;char ch=getchar(); while(ch&lt;'0'||ch&gt;'9')&#123;if(ch=='-')f=-f;ch=getchar();&#125; while(ch&gt;='0'&amp;&amp;ch&lt;='9')&#123;ret=ret*10+ch-'0';ch=getchar();&#125; return ret*f;&#125;struct Hash&#123; int Base,TT,Pow[maxn],Val[maxn]; void init(int b,int m) &#123; Base=b;TT=m;Pow[0]=1; for(int i=1;i&lt;=n;i++) Pow[i]=(LL)Pow[i-1]*Base%TT; for(int i=1;i&lt;=n;i++) Val[i]=((LL)Val[i-1]*Base+S[i])%TT; &#125; inline int GetHashValue(int L,int R)&#123;return ((Val[R]-(LL)Val[L-1]*Pow[R-L+1])%TT+TT)%TT;&#125;&#125;H1,H2;inline bool IsStringSame(int L,int R,int S,int T)&#123;return H1.GetHashValue(L,R)==H1.GetHashValue(S,T)&amp;&amp;H2.GetHashValue(L,R)==H2.GetHashValue(S,T);&#125;inline bool StrCmp(int S1,int S2,int len)&#123; int L=0,R=len,mid; while(L&lt;=R) &#123; mid=L+R&gt;&gt;1; IsStringSame(S1,S1+mid-1,S2,S2+mid-1)?L=mid+1:R=mid-1; &#125; if(R==len) return true; return S[S1+R]&gt;=S[S2+R];&#125;int main()&#123; sig=read();n=read(); if(sig==26) &#123; scanf("%s",tep+1); for(int i=1;i&lt;=n;i++) S[i]=tep[i]-'a'; &#125; else for(int i=1;i&lt;=n;i++) S[i]=read(); H1.init(19630217,1000000007);H2.init(19260817,1000000009); for(int len=n;len;len--) &#123; top++;stk[top]=n-len+1; while(top&gt;1&amp;&amp;StrCmp(stk[top],stk[top-1],len)) top--; ans[len]=stk[top]; &#125; for(int i=1;i&lt;=n;i++) printf("%d%c",ans[i],i==n?'\n':' '); return 0;&#125;]]></content>
      <categories>
        <category>单调栈</category>
      </categories>
      <tags>
        <tag>后缀数组</tag>
        <tag>二分</tag>
        <tag>哈希</tag>
        <tag>单调栈</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[高斯消元法解线性方程组]]></title>
    <url>%2F2019%2F02%2F07%2F%E9%AB%98%E6%96%AF%E6%B6%88%E5%85%83%E6%B3%95%E8%A7%A3%E7%BA%BF%E6%80%A7%E6%96%B9%E7%A8%8B%E7%BB%84-Algorithm%2F</url>
    <content type="text"><![CDATA[骚年？高斯消元了解一下！！！ 引入问题昨天，蒟蒻我遇到了一道题（传送门）。需要解一个n元非齐次线性方程组，才发现蒟蒻我这些玩意儿都忘得差不多了，吓得我赶紧掏出线性代数小紫书补一补，然后马上写个博客压压惊。 什么？您不知道什么是n元非齐次线性方程组？就是n元一次方程组啊！ 什么？您还是不知道？那肯定是dalao您又在嘲讽蒟蒻我了。请dalao您自行Ctrl+W！！！ 写得可能有不周到或者有问题的地方，还请dalao们多多指教。 理论基础比如说，有这样一个由$n$个方程组成的$n$元线性方程组： \begin{cases} a_{11}x_1+a_{12}x_2+\cdots+a_{1n}x_n=b_1\\ a_{21}x_1+a_{22}x_2+\cdots+a_{2n}x_n=b_2\\ \vdots\\ a_{n1}x_1+a_{n2}x_2+\cdots+a_{nn}x_n=b_n\\ \end{cases}我们可以把它表示成矩阵乘法的形式： \begin{Bmatrix} {a_{11}}&{a_{12}}&{\cdots}&{a_{1n}}\\ {a_{21}}&{a_{22}}&{\cdots}&{a_{2n}}\\ {\vdots}&{\vdots}&{\ddots}&{\vdots}\\ {a_{n1}}&{a_{n2}}&{\cdots}&{a_{nn}}\\ \end{Bmatrix} * \begin{Bmatrix} {x_1}\\ {x_2}\\ {\vdots}\\ {x_n}\\ \end{Bmatrix} = \begin{Bmatrix} {b_1}\\ {b_2}\\ {\vdots}\\ {b_n}\\ \end{Bmatrix}有这样几个有用的矩阵： A=(a_{ij}), x= \begin{Bmatrix} {x_1}\\ {x_2}\\ {\vdots}\\ {x_n}\\ \end{Bmatrix}, b= \begin{Bmatrix} {b_1}\\ {b_2}\\ {\vdots}\\ {b_n}\\ \end{Bmatrix}, B= \begin{Bmatrix} {a_{11}}&{a_{12}}&{\cdots}&{a_{1n}}&{b_1}\\ {a_{21}}&{a_{22}}&{\cdots}&{a_{2n}}&{b_2}\\ {\vdots}&{\vdots}&{\ddots}&{\vdots}&{\vdots}\\ {a_{n1}}&{a_{n2}}&{\cdots}&{a_{nn}}&{b_n}\\ \end{Bmatrix}其中$A$称为系数矩阵，$x$称为未知数矩阵，$b$称为常数项矩阵，$B$称为增广矩阵。 如果系数矩阵是形如下面这个样子上三角矩阵（即对角线以下都为0），那么就很爽了： \begin{Bmatrix} {a_{11}}&{a_{12}}&{\cdots}&{a_{1n}}\\ {0}&{a_{22}}&{\cdots}&{a_{2n}}\\ {\vdots}&{\vdots}&{\ddots}&{\vdots}\\ {0}&{0}&{\cdots}&{a_{nn}}\\ \end{Bmatrix}其中$a{nn}$的值就是$x_n$的值，这样就解出了一个未知数的值，然后代入上一个方程中，就能解出$x{n-1}$的值然后一直往上代入并求解，这样方程组就解出来了耶！ 但是很显然这么好的事情并不是每次都有（特别是对于我这种脸黑的蒟蒻来说`）。 所以我们就要想办法把系数矩阵变成这个样子，高斯消元就是干这个的。 我们就先把增广矩阵拎出来，其他的扔到一边腌制半个小时待用不管了。 我们可以把增广矩阵的一行乘以任意一个系数然后加到另一行，方程组的解不变。 其实就是相当于把原方程组的一个方程乘以一个系数再加到另一个方程组上。 我们可以把第一行的元素乘以一个系数加到第二行，乘以另一个系数加到第三行……一直加到第$n$行。 然后就可以把矩阵变成这样： \begin{Bmatrix} {a_{11}}&{a_{12}}&{\cdots}&{a_{1n}}&{b_1}\\ {0}&{a_{22}'}&{\cdots}&{a_{2n}'}&{b_2'}\\ {\vdots}&{\vdots}&{\ddots}&{\vdots}&{\vdots}\\ {0}&{a_{n2}'}&{\cdots}&{a_{nn}'}&{b_n'}\\ \end{Bmatrix}然后再把操作后的矩阵的第二行乘以一个系数加到第三行、第四行重复上面的操作，然后矩阵就会变成这样： \begin{Bmatrix} {a_{11}}&{a_{12}}&{\cdots}&{a_{1n}}&{b_1}\\ {0}&{a_{22}'}&{\cdots}&{a_{2n}'}&{b_2'}\\ {\vdots}&{\vdots}&{\ddots}&{\vdots}&{\vdots}\\ {0}&{0}&{\cdots}&{a_{nn}''}&{b_n''}\\ \end{Bmatrix}再重复上面的操作，最终矩阵就会变成理想状态了。然后依次代入消元即可。 需要注意的是，如果系数矩阵的对角线上有$0$的话是会出事的，记得特殊处理一下。 然后就没有然后了，理论部分就是这样。 代码实现详见我的上一篇博客 其他参考资料 ： 工程数学——线性代数 第六版 同济大学数学系。 话说MathJax的数学公式用起来真是赏心悦目。]]></content>
      <categories>
        <category>高斯消元</category>
      </categories>
      <tags>
        <tag>高斯消元</tag>
        <tag>数学</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「JSOI2008」球形空间产生器]]></title>
    <url>%2F2019%2F02%2F06%2F%E3%80%8CJSOI2008%E3%80%8D%E7%90%83%E5%BD%A2%E7%A9%BA%E9%97%B4%E4%BA%A7%E7%94%9F%E5%99%A8-Solution%2F</url>
    <content type="text"><![CDATA[纳尼？n维空间？什么鬼？？？ 传送门洛谷P4035 BZOJ1013 题解根据题目的说明，设球心的坐标为$Oj(j \in [1,n])$，$n+1$个点的坐标为$X{ij}(i \in[1,n+1],j\in{1,n})$，$R$为半径，那么就有$n+1$个这样的式子： \sum_{j=1}^{n}{(O_j-X_{ij})^2}=R^2将$R$消去，平方展开，移项后，可以得到$n$个这样的方程： \sum_{j=1}^{n}{2\cdot (X_{i+1j}-X_{ij})}\cdot O_j=\sum_{j=1}^{n}{X_{i+1j}^2-X_{ij}^2}狠狠盯着方程几秒钟，然后你就会发现方程中只有$O_j$是未知数，其他都是常数，所以这$n​$个方程构成了一个n元非齐次线性方程组（说人话叫做n元一次方程组）。 怎么解呢？ 上高斯消元啊啊啊！！！ 才发现什么矩阵行列式之类的东西都忘得差不多了，吓得我赶紧掏出了线性代数小紫书 那么 ，怎么用高斯消元法 解线性方程组呢？且听下回分解请左拐至…！ 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;int n;double a[15][15],A[15][15];double ABS(double x)&#123;return x&lt;0?-x:x;&#125;inline void Gauss() //高斯消元解方程&#123; for(int i=1;i&lt;=n;i++) &#123; int now=i; for(int j=i+1;j&lt;=n;j++) if(ABS(A[j][i]&gt;A[now][i])) now=j; if(now!=i) for(int j=i;j&lt;=n+1;j++) swap(A[now][j],A[i][j]); for(int k=i+1;k&lt;=n;k++) &#123; double t=A[k][i]/A[i][i]; for(int j=i;j&lt;=n+1;j++) A[k][j]-=A[i][j]*t; &#125; &#125; for(int i=n;i;i--) &#123; for(int j=i+1;j&lt;=n;j++) A[i][n+1]-=A[j][n+1]*A[i][j]; A[i][n+1]/=A[i][i]; &#125;&#125;int main()&#123; scanf("%d",&amp;n); for(int i=1;i&lt;=n+1;i++) for(int j=1;j&lt;=n;j++) scanf("%lf",&amp;a[i][j]); for(int i=1;i&lt;=n;i++) &#123; for(int j=1;j&lt;=n;j++) &#123; A[i][j]=2*(a[i+1][j]-a[i][j]); A[i][n+1]+=a[i+1][j]*a[i+1][j]-a[i][j]*a[i][j]; &#125; &#125; //A数组是该n元非齐次线性方程组的增广矩阵 Gauss(); for(int i=1;i&lt;=n;i++) printf("%.3lf%c",A[i][n+1],i==n?'\n':' '); return 0;&#125;]]></content>
      <categories>
        <category>高斯消元</category>
      </categories>
      <tags>
        <tag>高斯消元</tag>
        <tag>解方程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「SCOI2008」奖励关]]></title>
    <url>%2F2019%2F02%2F05%2F%E3%80%8CSCOI2008%E3%80%8D%E5%A5%96%E5%8A%B1%E5%85%B3-Solution%2F</url>
    <content type="text"><![CDATA[又是状压又是期望的，本蒟蒻最不熟了QwQ。 传送门洛谷P2473 BZOJ1076 题解由于种种原因，这题的DP是倒着推的。 设$F[i][s]$表示现在是第$i$关，已经吃的宝物的状态为$s$，吃到最后的得分期望。 由于每一关中每个宝物的概率都相同，所以累加每个宝物的贡献然后除以$n$即可。 转移方程，若可以吃第$j (j \in [1,n])$个宝物，可以选择吃或者不吃 F[i][s]+=max(F[i+1][s],F[i+1][s|(1]]></content>
      <categories>
        <category>状压期望DP</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>概率与期望</tag>
        <tag>期望DP</tag>
        <tag>状态压缩</tag>
        <tag>状压DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「SCOI2009」粉刷匠]]></title>
    <url>%2F2019%2F02%2F04%2F%E3%80%8CSCOI2009%E3%80%8D%E7%B2%89%E5%88%B7%E5%8C%A0-Solution%2F</url>
    <content type="text"><![CDATA[周政是个粉刷匠，粉刷本领强！他把自己的小白脸，刷得黑又脏！ 传送门洛谷P4158 BZOJ1296 题解本蒟蒻难得1A的省选题，虽然很老。 瞅了一眼数据范围，挺小的，直接上DP瞎搞！！！（汗 设$F[i][j][k]​$表示对于第$i​$行的前$j​$列，涂了$k​$次颜料，最多能刷对几个格子。 那么初始值$F[i][j][k]=F[i][j-1][k]​$； 转移方程： F[i][j][k]=\max_{l=0}^{j-1}{F[i][l][k-1]+sum[i][j]-sum[i][l]} \tag{1} F[i][j][k]=\max_{l=0}^{j-1}{F[i][l][k-1]+j-l-sum[i][j]+sum[i][l]} \tag{2}第一个式子表示$[l+1,j]$涂蓝色，第二个表示涂红色。 上式中的$sum[i][j]$表示第$i$行前$j$个格子中有几个希望被染成蓝色，即颜色的前缀和。 所以$F[i][m][k]​$就表示第$i​$行涂$k​$次最多能涂对几个格子。 预处理出了上式之后，然后再DP一趟，就能得出答案了呢（雾 令$G[i][j]​$表示对于前$i​$行，涂了$j​$次颜料，最多能涂对多少个格子。 那么很显然又有转移方程： G[i][j]=\max_{k=0}^{min(m,j)}{G[i-1][j-k]+F[i][m][k]} \tag{3}这趟DP刷完之后，终于得到了答案，即$G[n​$][T]。 就没有然后了QwQ 代码123456789101112131415161718192021222324252627282930313233343536373839#include&lt;cstdio&gt;using namespace std;const int maxn=55,maxt=2505;int n,m,T,F[maxn][maxn][maxn],sum[maxn][maxn],G[maxn][maxt];char GetChar()&#123; char ch=getchar(); while(ch!='0'&amp;&amp;ch!='1') ch=getchar(); return ch;&#125;int main()&#123; scanf("%d%d%d",&amp;n,&amp;m,&amp;T); for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=m;j++) sum[i][j]=sum[i][j-1]+(int)(GetChar()=='1'); for(int i=1;i&lt;=n;i++) &#123; for(int j=1;j&lt;=m;j++) &#123; for(int k=1;k&lt;=m;k++) &#123; F[i][j][k]=F[i][j-1][k]; for(int l=0;l&lt;j;l++) &#123; if(F[i][l][k-1]+sum[i][j]-sum[i][l]&gt;F[i][j][k]) F[i][j][k]=F[i][l][k-1]+sum[i][j]-sum[i][l]; if(F[i][l][k-1]+j-l-sum[i][j]+sum[i][l]&gt;F[i][j][k]) F[i][j][k]=F[i][l][k-1]+j-l-sum[i][j]+sum[i][l]; &#125; &#125; &#125; &#125; for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=T;j++) for(int k=0;k&lt;=m&amp;&amp;k&lt;=j;k++) if(G[i-1][j-k]+F[i][m][k]&gt;G[i][j]) G[i][j]=G[i-1][j-k]+F[i][m][k]; printf("%d\n",G[n][T]); return 0;&#125;]]></content>
      <categories>
        <category>DP</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>三维DP</tag>
        <tag>动态规划</tag>
        <tag>双DP</tag>
        <tag>二维DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「HNOI2008」GT考试]]></title>
    <url>%2F2019%2F02%2F03%2F%E3%80%8CHNOI2008%E3%80%8DGT%E8%80%83%E8%AF%95-Solution%2F</url>
    <content type="text"><![CDATA[继续学数数喽QwQ… 传送门洛谷P3193 BZOJ1009 题解很显然这是一道优化DP数数题 ，可惜我又不会QwQ。 （此处省略0x3F3F3F3F字的思考过程） 令$f[i][j]​$表示长串匹配到第$i​$位，短串匹配到第$j​$位的合法方案数； $g[k][j]$表示短串匹配到第$j$位时，长串再加上一个字符使得最多能匹配$k$位的方案数。 那么就有 f[i][j]=\sum_{k=0}^{m-1}{f[i-1][k]*g[k][j]}最后的答案就是 \sum_{i=0}^{m-1}{f[n][i]}观察一下DP转移方程，发现$g$数组是固定的，可以通过看毛片KMP或者暴力预处理出来（抱歉我这里真的没有毛片看，但是据说隔壁巨佬知道哪里有）。 再狠狠瞅几眼转移方程，艾玛！这不是一个矩阵乘法的式子吗！ 令矩阵$F[i]$的第一行为$f[i][j]​$，那么就有 F[i]=F[i-1]*G所以 F[n]=F[0]*G^n且又知道$f[0][0]=1$、最后答案为$F[n]​$第一行元素之和。 所以这题就解完了。 代码本蒟蒻因为矩阵重载乘法运算符是忘了return调了半天QwQ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include&lt;cstdio&gt;#include&lt;cstring&gt;using namespace std;int n,m,K,nxt[25],ans;char S[25];struct Matrix //矩阵类&#123; int A[25][25]; Matrix()&#123;memset(A,0,sizeof(A));&#125; Matrix operator * (const Matrix&amp; b) //矩阵乘法 &#123; Matrix c; for(int i=0;i&lt;m;i++) &#123; for(int j=0;j&lt;m;j++) &#123; for(int k=0;k&lt;m;k++) &#123; c.A[i][j]+=A[i][k]*b.A[k][j]; c.A[i][j]%=K; //记得mod &#125; &#125; &#125; return c; &#125;&#125;G,F;inline void KMP() //KMP构造矩阵G&#123; for(int i=2;i&lt;=m;i++) &#123; int j=nxt[i-1]; while(j&amp;&amp;S[i]!=S[j+1]) j=nxt[j]; if(S[i]==S[j+1]) nxt[i]=j+1; &#125; for(int i=0;i&lt;m;i++) &#123; for(int j='0';j&lt;='9';j++) &#123; int k=i; while(k&amp;&amp;S[k+1]!=j) k=nxt[k]; if(S[k+1]==j) k++; if(k&lt;m) G.A[i][k]++; &#125; &#125;&#125;Matrix QP(const Matrix&amp; a,int b) //矩阵快速幂&#123; Matrix ret=a,w=a;b--; while(b) &#123; if(b&amp;1) ret=ret*w; w=w*w;b&gt;&gt;=1; &#125; return ret;&#125;int main()&#123; scanf("%d%d%d%s",&amp;n,&amp;m,&amp;K,S+1); KMP();F.A[0][0]=1;F=F*QP(G,n); for(int i=0;i&lt;m;i++) ans=(ans+F.A[0][i])%K; printf("%d\n",ans); return 0;&#125;]]></content>
      <categories>
        <category>矩阵加速DP</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>数数</tag>
        <tag>快速幂</tag>
        <tag>矩阵加速</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「AHOI2009」中国象棋]]></title>
    <url>%2F2019%2F01%2F31%2F%E3%80%8CAHOI2009%E3%80%8D%E4%B8%AD%E5%9B%BD%E8%B1%A1%E6%A3%8B-Solution%2F</url>
    <content type="text"><![CDATA[数数万岁… 前言早晨起床，打开电脑，上了洛谷，打了个卡，发现智能推荐里面有几道上古时代的省选题。随便戳开了一道，发现是个应该是个DP数数题，而我数数又很差，正想补补，于是就很愉快的做起了此题… 传送门洛谷P2051 BZOJ1801 题解感觉2010年之前的省选题都不怎么难、代码量都不大(对于个别题目当我没说)… 首先很显然，每一行每一列里，如果炮的个数都≤2，那么都是合法的啦！ 看了一眼，数据范围很亲切，然后就自然而然地想出了这样一个DP：（汗 F[i][j][k] 表示放了前i行，有j列放了2个炮，k列放了1个炮，那么就有m-i-j列没有放炮首先是初始值$F[0][0][0]=1​$。 然后考虑怎么从第$i-1$行转移过来。 如果第$i$行一个炮也不放，那么就有$F[i][j][k]=F[i-1][j][k]$。 如果放一个，那么有两种情况： 放在空的列上： $F[i][j][k]+=F[i-1][j][k-1]*(m-j-k+1)​$； 放在只放了1个炮的列上： $F[i][j][k]+=F[i-1][j-1][k+1]*(k+1)​$。 如果放两个炮，那么有三种情况： 两个都放在空的列上：$F[i][j][k]+=F[i-1][j][k-2]\cdot(m-j-k+2)\cdot(m-j-k+1)/2$； 一个放在空列，一个放在只有一个的列上：$F[i][j][k]+=F[i-1][j-1][k]\cdot k\cdot(m-j-k+1)$； 两个都放在只有一个的列上：$F[i][j][k]+=F[i-1][j-2][k+2]\cdot(k+2)\cdot(k+1)/2$。 最后的答案： \sum_{1=0}^{m}{\sum_{j=0}^{m-i}{F[n][i][j]}}然后这题就做完了QwQ。 代码123456789101112131415161718192021222324252627282930#include&lt;cstdio&gt;using namespace std;typedef long long LL;const int maxn=105,TT=9999973;int n,m,F[maxn][maxn][maxn],ans;int main()&#123; scanf("%d%d",&amp;n,&amp;m);F[0][0][0]=1; for(int i=1;i&lt;=n;i++) &#123; for(int j=0;j&lt;=m;j++) &#123; for(int k=0;j+k&lt;=m;k++) &#123; F[i][j][k]=F[i-1][j][k];//这题的模数比较小，有些地方不需要马上模，可以写好看一点 if(k&gt;=1) F[i][j][k]+=F[i-1][j][k-1]*(m-j-k+1); if(j&gt;=1) F[i][j][k]+=F[i-1][j-1][k+1]*(k+1); if(k&gt;=2) F[i][j][k]+=F[i-1][j][k-2]*(LL)(m-j-k+2)*(m-j-k+1)/2%TT; if(j&gt;=1) F[i][j][k]+=F[i-1][j-1][k]*(LL)k*(m-j-k+1)%TT; if(j&gt;=2) F[i][j][k]+=F[i-1][j-2][k+2]*(LL)(k+2)*(k+1)/2%TT; F[i][j][k]%=TT; &#125; &#125; &#125; for(int j=0;j&lt;=m;j++) for(int k=0;j+k&lt;=m;k++) ans=(ans+F[n][j][k])%TT; printf("%d\n",ans); return 0;&#125;]]></content>
      <categories>
        <category>DP</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>数数</tag>
        <tag>递推</tag>
        <tag>三维DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「FJOI2007」轮状病毒]]></title>
    <url>%2F2019%2F01%2F30%2F%E3%80%8CFJOI2007%E3%80%8D%E8%BD%AE%E7%8A%B6%E7%97%85%E6%AF%92-Solution%2F</url>
    <content type="text"><![CDATA[数数题怎么这么讨厌呀QwQ… 传送门洛谷P2144 BZOJ1002 题解这种数数题当然要先找规律呀poi！ 通过手玩或者暴力，可以得到以下表格： n ans 1 1 2 5 3 16 4 45 5 121 6 320 咦？当$n$为奇数时，$ans$都是完全平方数哇！！！ 那么当$n$为偶数时呢？ 哟，$ans$加上4之后也都是完全平方数呢！！！ 把这些完全平方数开个方试试看！！！ 就得到了这样的一个序列：1 3 4 7 11 18… 呀呀呀！这不就是一个变形的斐波那契数列么？ 并且$n​$很小，直接上高精度就好了呢poi。 然后这题就做完了QwQ… 别问我为什么有这样的规律，我也不知道QwQ… 码完代码测样例，才发现高精度都写挂了，我好菜啊QwQ 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;const int maxn=105;int n;struct BigInt //封装好的高精度&#123; int a[50],len; BigInt()&#123;len=0;memset(a,0,sizeof(a));&#125; BigInt(int x) &#123; len=0;memset(a,0,sizeof(a)); while(x)&#123;len++;a[len]=x%10;x/=10;&#125; &#125; BigInt operator + (const BigInt&amp; b) &#123; BigInt c; c.len=max(len,b.len); for(int i=1;i&lt;=c.len;i++) &#123; c.a[i]+=a[i]+b.a[i]; c.a[i+1]+=c.a[i]/10; c.a[i]%=10; &#125; if(c.a[c.len+1]) c.len++; return c; &#125; BigInt operator * (const BigInt&amp; b) &#123; BigInt c; c.len=len+b.len-1; for(int i=1;i&lt;=len;i++) &#123; for(int j=1;j&lt;=b.len;j++) &#123; c.a[i+j-1]+=a[i]*b.a[j]; c.a[i+j]+=c.a[i+j-1]/10; c.a[i+j-1]%=10; &#125; &#125; if(c.a[c.len+1]) c.len++; return c; &#125; BigInt operator - (const int&amp; b) //这个减法只能减去10以内的数 &#123; BigInt c=*this; c.a[1]-=b; for(int i=1;i&lt;=c.len&amp;&amp;c.a[i]&lt;0;i++) &#123; c.a[i]+=10; c.a[i+1]--; &#125; while(!c.a[c.len]) c.len--; return c; &#125; inline void Print() &#123; for(int i=len;i;i--) printf("%d",a[i]); printf("\n"); &#125;&#125;F[maxn],ans;int main()&#123; scanf("%d",&amp;n);F[1]=1;F[2]=3; for(int i=3;i&lt;=n;i++) F[i]=F[i-1]+F[i-2]; ans=F[n]*F[n]; if(n%2==0) ans=ans-4; //n为偶数时记得减去4哟 ans.Print(); return 0;&#125;]]></content>
      <categories>
        <category>递推</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>数数</tag>
        <tag>递推</tag>
        <tag>高精度</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「SCOI2009」windy数]]></title>
    <url>%2F2019%2F01%2F30%2F%E3%80%8CSCOI2009%E3%80%8Dwindy%E6%95%B0-Solution%2F</url>
    <content type="text"><![CDATA[分块打表大法好！打表万岁！dalao保佑我打表进省队！（逃 传送门洛谷P2657 BZOJ1026 题解很显然，这题正解是数位DP，但是我觉得上分块打表会更好玩一些！ 设块大为$S$，我们可以先写一个暴力，计算出S、2S、3S、4S……内一共有多少个windy数，把这个表事先打出来。由于$A、B$都比较小，打这个表不会用很长时间。蒟蒻我的机子还不错，八框框的i5 CPU，最高可以睿频到3.4GHz，用了四十多秒就跑完了。然后根据容斥原理，最后的答案是$Solve(B)-Solve(A-1)$，其中$Solve(x)$用于求解共有多少个windy数$\in[1,x]$。且必有$x \in [kS,(k+1)S]$。$Solve(kS)$已经事先打过表了，暴力枚举并检验$[kS+1,x]$中有多少个windy数即可。为了减少最终代码长度，令$S=10^6$或$10^7​$即可。 代码还好，不是很长呢poi。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include&lt;cstdio&gt;using namespace std;const int table[2005]=&#123;0,202174,338305,476808,615022,753274,891526,1029740,1168243,1304374,1459689,1459689,1459689,1459689,1597903,1736155,1874407,2012621,2151124,2287255,2442570,2597885,2597885,2597885,2597885,2736137,2874389,3012603,3151106,3287237,3442552,3597867,3733998,3733998,3733998,3733998,3872250,4010464,4148967,4285098,4440413,4595728,4731859,4870362,4870362,4870362,4870362,5008576,5147079,5283210,5438525,5593840,5729971,5868474,6006688,6006688,6006688,6006688,6145191,6281322,6436637,6591952,6728083,6866586,7004800,7143052,7143052,7143052,7143052,7279183,7434498,7589813,7725944,7864447,8002661,8140913,8279165,8279165,8279165,8279165,8434480,8589795,8725926,8864429,9002643,9140895,9279147,9417361,9417361,9417361,9417361,9572676,9708807,9847310,9985524,10123776,10262028,10400242,10538745,10538745,10538745,10538745,10538745,10538745,10538745,10538745,10538745,10538745,10538745,10538745,10538745,10538745,10538745,10538745,10538745,10538745,10538745,10538745,10538745,10538745,10538745,10538745,10538745,10538745,10538745,10538745,10538745,10538745,10538745,10538745,10538745,10694060,10830191,10830191,10830191,10830191,10968443,11106657,11245160,11381291,11536606,11691921,11828052,11966555,11966555,11966555,11966555,12104769,12243272,12379403,12534718,12690033,12826164,12964667,13102881,13102881,13102881,13102881,13241384,13377515,13532830,13688145,13824276,13962779,14100993,14239245,14239245,14239245,14239245,14375376,14530691,14686006,14822137,14960640,15098854,15237106,15375358,15375358,15375358,15375358,15530673,15685988,15822119,15960622,16098836,16237088,16375340,16513554,16513554,16513554,16513554,16668869,16805000,16943503,17081717,17219969,17358221,17496435,17634938,17634938,17634938,17634938,17634938,17773441,17911655,18049907,18188159,18326373,18464876,18601007,18756322,18756322,18756322,18756322,18756322,18756322,18756322,18756322,18756322,18756322,18756322,18756322,18756322,18756322,18756322,18756322,18756322,18756322,18756322,18756322,18756322,18756322,18756322,18756322,18756322,18756322,18756322,18756322,18756322,18756322,18756322,18911637,19047768,19186271,19186271,19186271,19186271,19324485,19462988,19599119,19754434,19909749,20045880,20184383,20322597,20322597,20322597,20322597,20461100,20597231,20752546,20907861,21043992,21182495,21320709,21458961,21458961,21458961,21458961,21595092,21750407,21905722,22041853,22180356,22318570,22456822,22595074,22595074,22595074,22595074,22750389,22905704,23041835,23180338,23318552,23456804,23595056,23733270,23733270,23733270,23733270,23888585,24024716,24163219,24301433,24439685,24577937,24716151,24854654,24854654,24854654,24854654,24854654,24993157,25131371,25269623,25407875,25546089,25684592,25820723,25976038,25976038,25976038,25976038,26114252,26252504,26390756,26528970,26667473,26803604,26958919,26958919,26958919,26958919,26958919,26958919,26958919,26958919,26958919,26958919,26958919,26958919,26958919,26958919,26958919,26958919,26958919,26958919,26958919,26958919,26958919,26958919,26958919,26958919,26958919,26958919,26958919,26958919,26958919,26958919,26958919,27114234,27250365,27388868,27527082,27527082,27527082,27527082,27665585,27801716,27957031,28112346,28248477,28386980,28525194,28663446,28663446,28663446,28663446,28799577,28954892,29110207,29246338,29384841,29523055,29661307,29799559,29799559,29799559,29799559,29954874,30110189,30246320,30384823,30523037,30661289,30799541,30937755,30937755,30937755,30937755,31093070,31229201,31367704,31505918,31644170,31782422,31920636,32059139,32059139,32059139,32059139,32059139,32197642,32335856,32474108,32612360,32750574,32889077,33025208,33180523,33180523,33180523,33180523,33318737,33456989,33595241,33733455,33871958,34008089,34163404,34318719,34318719,34318719,34318719,34456971,34595223,34733437,34871940,35008071,35163386,35163386,35163386,35163386,35163386,35163386,35163386,35163386,35163386,35163386,35163386,35163386,35163386,35163386,35163386,35163386,35163386,35163386,35163386,35163386,35163386,35163386,35163386,35163386,35163386,35163386,35163386,35163386,35163386,35163386,35163386,35318701,35454832,35593335,35731549,35869801,35869801,35869801,35869801,36005932,36161247,36316562,36452693,36591196,36729410,36867662,37005914,37005914,37005914,37005914,37161229,37316544,37452675,37591178,37729392,37867644,38005896,38144110,38144110,38144110,38144110,38299425,38435556,38574059,38712273,38850525,38988777,39126991,39265494,39265494,39265494,39265494,39265494,39403997,39542211,39680463,39818715,39956929,40095432,40231563,40386878,40386878,40386878,40386878,40525092,40663344,40801596,40939810,41078313,41214444,41369759,41525074,41525074,41525074,41525074,41663326,41801578,41939792,42078295,42214426,42369741,42525056,42661187,42661187,42661187,42661187,42799439,42937653,43076156,43212287,43367602,43367602,43367602,43367602,43367602,43367602,43367602,43367602,43367602,43367602,43367602,43367602,43367602,43367602,43367602,43367602,43367602,43367602,43367602,43367602,43367602,43367602,43367602,43367602,43367602,43367602,43367602,43367602,43367602,43367602,43367602,43522917,43659048,43797551,43935765,44074017,44212269,44212269,44212269,44212269,44367584,44522899,44659030,44797533,44935747,45073999,45212251,45350465,45350465,45350465,45350465,45505780,45641911,45780414,45918628,46056880,46195132,46333346,46471849,46471849,46471849,46471849,46471849,46610352,46748566,46886818,47025070,47163284,47301787,47437918,47593233,47593233,47593233,47593233,47731447,47869699,48007951,48146165,48284668,48420799,48576114,48731429,48731429,48731429,48731429,48869681,49007933,49146147,49284650,49420781,49576096,49731411,49867542,49867542,49867542,49867542,50005794,50144008,50282511,50418642,50573957,50729272,50865403,51003906,51003906,51003906,51003906,51142120,51280623,51416754,51572069,51572069,51572069,51572069,51572069,51572069,51572069,51572069,51572069,51572069,51572069,51572069,51572069,51572069,51572069,51572069,51572069,51572069,51572069,51572069,51572069,51572069,51572069,51572069,51572069,51572069,51572069,51572069,51572069,51572069,51572069,51727384,51863515,52002018,52140232,52278484,52416736,52554950,52554950,52554950,52554950,52710265,52846396,52984899,53123113,53261365,53399617,53537831,53676334,53676334,53676334,53676334,53676334,53814837,53953051,54091303,54229555,54367769,54506272,54642403,54797718,54797718,54797718,54797718,54935932,55074184,55212436,55350650,55489153,55625284,55780599,55935914,55935914,55935914,55935914,56074166,56212418,56350632,56489135,56625266,56780581,56935896,57072027,57072027,57072027,57072027,57210279,57348493,57486996,57623127,57778442,57933757,58069888,58208391,58208391,58208391,58208391,58346605,58485108,58621239,58776554,58931869,59068000,59206503,59344717,59344717,59344717,59344717,59483220,59619351,59774666,59774666,59774666,59774666,59774666,59774666,59774666,59774666,59774666,59774666,59774666,59774666,59774666,59774666,59774666,59774666,59774666,59774666,59774666,59774666,59774666,59774666,59774666,59774666,59774666,59774666,59774666,59774666,59774666,59774666,59774666,59929981,60066112,60204615,60342829,60481081,60619333,60757547,60896050,60896050,60896050,60896050,60896050,61034553,61172767,61311019,61449271,61587485,61725988,61862119,62017434,62017434,62017434,62017434,62155648,62293900,62432152,62570366,62708869,62845000,63000315,63155630,63155630,63155630,63155630,63293882,63432134,63570348,63708851,63844982,64000297,64155612,64291743,64291743,64291743,64291743,64429995,64568209,64706712,64842843,64998158,65153473,65289604,65428107,65428107,65428107,65428107,65566321,65704824,65840955,65996270,66151585,66287716,66426219,66564433,66564433,66564433,66564433,66702936,66839067,66994382,67149697,67285828,67424331,67562545,67700797,67700797,67700797,67700797,67836928,67992243,67992243,67992243,67992243,67992243,67992243,67992243,67992243,67992243,67992243,67992243,67992243,67992243,67992243,67992243,67992243,67992243,67992243,67992243,67992243,67992243,67992243,67992243,67992243,67992243,67992243,67992243,67992243,67992243,67992243,67992243,67992243,67992243,68130746,68268960,68407212,68545464,68683678,68822181,68958312,69113627,69113627,69113627,69113627,69251841,69390093,69528345,69666559,69805062,69941193,70096508,70251823,70251823,70251823,70251823,70390075,70528327,70666541,70805044,70941175,71096490,71251805,71387936,71387936,71387936,71387936,71526188,71664402,71802905,71939036,72094351,72249666,72385797,72524300,72524300,72524300,72524300,72662514,72801017,72937148,73092463,73247778,73383909,73522412,73660626,73660626,73660626,73660626,73799129,73935260,74090575,74245890,74382021,74520524,74658738,74796990,74796990,74796990,74796990,74933121,75088436,75243751,75379882,75518385,75656599,75794851,75933103,75933103,75933103,75933103,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76226921,76365135,76503387,76641639,76779853,76918356,77054487,77209802,77209802,77209802,77209802,77348016,77486268,77624520,77762734,77901237,78037368,78192683,78192683,78192683,78192683,78192683,78192683,78192683,78192683,78192683,78192683,78192683,78192683,78192683,78192683,78192683,78192683,78192683,78192683,78192683,78192683,78192683,78192683,78192683,78192683,78192683,78192683,78192683,78192683,78192683,78192683,78192683,78347998,78484129,78622632,78760846,78760846,78760846,78760846,78899349,79035480,79190795,79346110,79482241,79620744,79758958,79897210,79897210,79897210,79897210,80033341,80188656,80343971,80480102,80618605,80756819,80895071,81033323,81033323,81033323,81033323,81188638,81343953,81480084,81618587,81756801,81895053,82033305,82171519,82171519,82171519,82171519,82326834,82462965,82601468,82739682,82877934,83016186,83154400,83292903,83292903,83292903,83292903,83292903,83431406,83569620,83707872,83846124,83984338,84122841,84258972,84414287,84414287,84414287,84414287,84552501,84690753,84829005,84967219,85105722,85241853,85397168,85552483,85552483,85552483,85552483,85690735,85828987,85967201,86105704,86241835,86397150,86397150,86397150,86397150,86397150,86397150,86397150,86397150,86397150,86397150,86397150,86397150,86397150,86397150,86397150,86397150,86397150,86397150,86397150,86397150,86397150,86397150,86397150,86397150,86397150,86397150,86397150,86397150,86397150,86397150,86397150,86552465,86688596,86827099,86965313,87103565,87103565,87103565,87103565,87239696,87395011,87550326,87686457,87824960,87963174,88101426,88239678,88239678,88239678,88239678,88394993,88550308,88686439,88824942,88963156,89101408,89239660,89377874,89377874,89377874,89377874,89533189,89669320,89807823,89946037,90084289,90222541,90360755,90499258,90499258,90499258,90499258,90499258,90637761,90775975,90914227,91052479,91190693,91329196,91465327,91620642,91620642,91620642,91620642,91758856,91897108,92035360,92173574,92312077,92448208,92603523,92758838,92758838,92758838,92758838,92897090,93035342,93173556,93312059,93448190,93603505,93758820,93894951,93894951,93894951,93894951,94033203,94171417,94309920,94446051,94601366,94601366,94601366,94601366,94601366,94601366,94601366,94601366,94601366,94601366,94601366,94601366,94601366,94601366,94601366,94601366,94601366,94601366,94601366,94601366,94601366,94601366,94601366,94601366,94601366,94601366,94601366,94601366,94601366,94601366,94601366,94756681,94892812,95031315,95169529,95307781,95446033,95446033,95446033,95446033,95601348,95756663,95892794,96031297,96169511,96307763,96446015,96584229,96584229,96584229,96584229,96739544,96875675,97014178,97152392,97290644,97428896,97567110,97705613,97705613,97705613,97705613,97705613,97844116,97982330,98120582,98258834,98397048,98535551,98671682,98826997,98826997,98826997,98826997,98965211,99103463,99241715,99379929,99518432,99654563,99809878,99965193,99965193,99965193,99965193,100103445,100241697,100379911,100518414,100654545,100809860,100965175,101101306,101101306,101101306,101101306,101239558,101377772,101516275,101652406,101807721,101963036,102099167,102237670,102237670,102237670,102237670,102375884,102514387,102650518,102805833,102805833,102805833,102805833,102805833,102805833,102805833,102805833,102805833,102805833,102805833,102805833,102805833,102805833,102805833,102805833,102805833,102805833,102805833,102805833,102805833,102805833,102805833,102805833,102805833,102805833,102805833,102805833,102805833,102805833,102805833,102961148,103097279,103235782,103373996,103512248,103650500,103788714,103788714,103788714,103788714,103944029,104080160,104218663,104356877,104495129,104633381,104771595,104910098,104910098,104910098,104910098,104910098,105048601,105186815,105325067,105463319,105601533,105740036,105876167,106031482,106031482,106031482,106031482,106169696,106307948,106446200,106584414,106722917,106859048,107014363,107169678,107169678,107169678,107169678,107307930,107446182,107584396,107722899,107859030,108014345,108169660,108305791,108305791,108305791,108305791,108444043,108582257,108720760,108856891,109012206,109167521,109303652,109442155,109442155,109442155,109442155,109580369,109718872,109855003,110010318,110165633,110301764,110440267,110578481,110578481,110578481,110578481,110716984,110853115,111008430,111008430,111008430,111008430,111008430,111008430,111008430,111008430,111008430,111008430,111008430,111008430,111008430,111008430,111008430,111008430,111008430,111008430,111008430,111008430,111008430,111008430,111008430,111008430,111008430,111008430,111008430,111008430,111008430,111008430,111008430,111163745,111299876,111438379,111576593,111714845,111853097,111991311,112129814,112129814,112129814,112129814,112129814,112268317,112406531,112544783,112683035,112821249,112959752,113095883,113251198,113251198,113251198,113251198,113389412,113527664,113665916,113804130,113942633,114078764,114234079,114389394,114389394,114389394,114389394,114527646,114665898,114804112,114942615,115078746,115234061,115389376,115525507,115525507,115525507,115525507,115663759,115801973,115940476,116076607,116231922,116387237,116523368,116661871,116661871,116661871,116661871,116800085,116938588,117074719,117230034,117385349,117521480,117659983,117798197,117798197,117798197,117798197,117936700,118072831,118228146,118383461,118519592,118658095,118796309,118934561,118934561,118934561,118934561,119070692,119226007,119226007,119226007,119226007,119226007,119226007,119226007,119226007,119226007,119226007,119226007,119226007,119226007,119226007,119226007,119226007,119226007,119226007,119226007,119226007,119226007,119226007,119226007,119226007,119226007,119226007,119226007,119226007,119226007,119226007,119226007,119226007,119226007,119364510,119502724,119640976,119779228,119917442,120055945,120192076,120347391,120347391,120347391,120347391,120485605,120623857,120762109,120900323,121038826,121174957,121330272,121485587,121485587,121485587,121485587,121623839,121762091,121900305,122038808,122174939,122330254,122485569,122621700,122621700,122621700,122621700,122759952,122898166,123036669,123172800,123328115,123483430,123619561,123758064,123758064,123758064,123758064,123896278,124034781,124170912,124326227,124481542,124617673,124756176,124894390,124894390,124894390,124894390,125032893,125169024,125324339,125479654,125615785,125754288,125892502,126030754,126030754,126030754,126030754,126166885,126322200,126477515,126613646,126752149,126890363,127028615,127166867,127166867,127166867,127166867,127322182,127322182,127322182,127322182,127322182,127322182,127322182,127322182,127322182,127322182,127322182,127322182,127322182,127322182,127322182,127322182,127322182,127322182,127322182,127322182,127322182&#125;;int A,B;inline int read()&#123; int ret=0,f=1;char ch=getchar(); while(ch&lt;'0'||ch&gt;'9')&#123;if(ch=='-')f=-f;ch=getchar();&#125; while(ch&gt;='0'&amp;&amp;ch&lt;='9')&#123;ret=ret*10+ch-'0';ch=getchar();&#125; return ret*f;&#125;int ABS(int x)&#123;return x&lt;0?-x:x;&#125;inline bool check(int x)&#123; static int A[15],len; len=0; while(x)&#123;A[++len]=x%10;x/=10;&#125; for(int i=1;i&lt;len;i++) if(ABS(A[i+1]-A[i])&lt;2) return false; return true;&#125;inline void MakeTable()&#123; freopen("Table.txt","w",stdout); register int i,ans=0; for(i=1;i&lt;=2000000000;i++) &#123; if(check(i)) ans++; if(i%1000000==0) printf("%d,",ans); &#125;&#125;inline int Solve(int n)&#123; int ret=table[n/1000000]; for(int i=n/1000000*1000000+1;i&lt;=n;i++) if(check(i)) ret++; return ret;&#125;int main()&#123;// MakeTable(); scanf("%d%d",&amp;A,&amp;B); printf("%d\n",Solve(B)-Solve(A-1)); return 0;&#125;]]></content>
      <categories>
        <category>分块打表</category>
      </categories>
      <tags>
        <tag>分块</tag>
        <tag>打表</tag>
        <tag>分块打表</tag>
        <tag>数位DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「HNOI2005」狡猾的商人]]></title>
    <url>%2F2019%2F01%2F29%2F%E3%80%8CHNOI2005%E3%80%8D%E7%8B%A1%E7%8C%BE%E7%9A%84%E5%95%86%E4%BA%BA-Solution%2F</url>
    <content type="text"><![CDATA[贪心大法好QwQ！ 传送门洛谷P2294 BZOJ1202 题解这题有好多种解法，可以上差分约束、并查集之类的。 但是贪心大法好啊！！！ 把所有偷看到的信息按左端点排序，然后从前到后两两比较。 如果左端点相同 比较右端点 如果右端点相同 比较权值，如果不相同直接输出false 如果右端点不相同 将重叠部分抵消掉，权值相减得到一个新的信息，扔回去，用堆维护 如果左端点不同 把前面一个信息扔掉即可，不用管 直到最后，堆空了，没有出现问题，那么输出true就好了。 代码其实这题挺水的 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include&lt;queue&gt;#include&lt;vector&gt;#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;int T,n,m;bool fal;inline int read()&#123; int ret=0,f=1;char ch=getchar(); while(ch&lt;'0'||ch&gt;'9')&#123;if(ch=='-')f=-f;ch=getchar();&#125; while(ch&gt;='0'&amp;&amp;ch&lt;='9')&#123;ret=ret*10+ch-'0';ch=getchar();&#125; return ret*f;&#125;struct Node&#123; int L,R,w; bool operator &lt; (const Node&amp; b)const&#123;return L&lt;b.L||(L==b.L&amp;&amp;R&lt;b.R);&#125; bool operator &gt; (const Node&amp; b)const&#123;return L&gt;b.L||(L==b.L&amp;&amp;R&gt;b.R);&#125;&#125;tep1,tep2;priority_queue&lt;Node,vector&lt;Node&gt;,greater&lt;Node&gt; &gt; H;int main()&#123; T=read(); while(T--) &#123; while(H.size()) H.pop(); n=read();m=read();fal=false; for(int i=1;i&lt;=m;i++) &#123; tep1.L=read();tep1.R=read();tep1.w=read(); H.push(tep1); &#125; tep1=H.top();H.pop(); while(H.size()) &#123; tep2=H.top();H.pop(); if(tep1.L==tep2.L) &#123; if(tep1.R==tep2.R) &#123; if(tep1.w!=tep2.w) &#123;printf("false\n");fal=true;break;&#125; &#125; else if(tep1.R!=tep2.R) H.push((Node)&#123;tep1.R+1,tep2.R,tep2.w-tep1.w&#125;); &#125; tep1=tep2; &#125; if(!fal) printf("true\n"); &#125; return 0;&#125;]]></content>
      <categories>
        <category>贪心</category>
      </categories>
      <tags>
        <tag>贪心</tag>
        <tag>并查集</tag>
        <tag>查分约束</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「HNOI2006」马步距离]]></title>
    <url>%2F2019%2F01%2F28%2F%E3%80%8CHNOI2006%E3%80%8D%E9%A9%AC%E6%AD%A5%E8%B7%9D%E7%A6%BB-Solution%2F</url>
    <content type="text"><![CDATA[这题有点水QwQ… 传送门洛谷P2060 BZOJ1193 题解首先很显然不能直接贪心，直接贪心有可能WA，所以要写个DFS之类的东西来搜。 但是数据稍微有点大QwQ，搜不出来。 不难发现，当距离比较远时直接贪心地奔着目标走是肯定没问题的。 所以距离远时贪心，距离近时爆搜就行了QwQ。 其实手玩就能把表打出来。 代码打表万岁 123456789101112131415161718192021222324252627#include&lt;cstdio&gt;using namespace std;const int f[7][7]=&#123; &#123;0,3,2,3,2&#125;, &#123;3,2,1,2,3&#125;, &#123;2,1,4,3,2&#125;, &#123;3,2,3,2,3&#125;, &#123;2,3,2,3,4&#125;&#125;;int xp,yp,xs,ys,x,y,ans;int ABS(int x)&#123;return x&lt;0?-x:x;&#125;int main()&#123; scanf("%d%d%d%d",&amp;xp,&amp;yp,&amp;xs,&amp;ys); x=ABS(xp-xs);y=ABS(yp-ys); while(x&gt;4||y&gt;4) &#123; if(x&lt;y)&#123;x--;y-=2;&#125; else&#123;x-=2;y--;&#125; if(x&lt;0) x=-x;if(y&lt;0) y=-y; ans++; &#125; ans+=f[x][y]; printf("%d\n",ans); return 0;&#125;]]></content>
      <categories>
        <category>贪心</category>
      </categories>
      <tags>
        <tag>贪心</tag>
        <tag>DFS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「BJOI2014」想法]]></title>
    <url>%2F2019%2F01%2F24%2F%E3%80%8CBJOI2014%E3%80%8D%E6%83%B3%E6%B3%95-Solution%2F</url>
    <content type="text"><![CDATA[什么鬼？省选也出这种玄学随机算法题？ 传送门洛谷P4581 题解首先这题一看就很不可解。 所以上随机算法（人家题面都告诉你了QwQ）。 写之前先膜拜一下dalao，保佑AC。 sto 黄霖 orz 对于一个节点，将所用能走到它的叶子节点都存下来是不现实的，所以我们只存$k$个。并且我们要先为每个叶子节点i随机一个权值$W_i$，满足$W_i \in [1,RANDMAX]$。对于每个非叶子节点，我们需要存下所有能走到个节点的叶子节点的权值的前$k$小。设这个节点的答案为$ans$，第$k$小权值为$F_k​$根据期望可得 \frac{F_k}{RANDMAX}=\frac{k}{ans}故有 ans=\frac{k*RANDMAX}{F_k}令$k=50$，多为叶子节点随机几套权值求平均值，吸个氧，放个大悲咒，选个好种子，你就能AC了。 代码这是真的玄学QwQ 1234567891011121314151617181920212223242526272829303132333435363738394041424344#include&lt;cstdio&gt;#include&lt;cstdlib&gt;using namespace std;typedef long long LL;const int maxn=1000005,k=50;int n,m,son[maxn][2],w[maxn],num[maxn],f[maxn][55];LL ans[maxn];inline int read()&#123; int ret=0,f=1;char ch=getchar(); while(ch&lt;'0'||ch&gt;'9')&#123;if(ch=='-')f=-f;ch=getchar();&#125; while(ch&gt;='0'&amp;&amp;ch&lt;='9')&#123;ret=ret*10+ch-'0';ch=getchar();&#125; return ret*f;&#125;inline void Merge(int s1,int s2,int now) //从两个儿子节点合并过来&#123; register int i=1,j=1;num[now]=k; for(register int p=1;p&lt;=k;p++) &#123; while(f[s1][i]==f[now][p-1]&amp;&amp;i&lt;=num[s1]) i++; //注意去重 while(f[s2][j]==f[now][p-1]&amp;&amp;j&lt;=num[s2]) j++; if(i&gt;num[s1]&amp;&amp;j&gt;num[s2])&#123;num[now]=p-1;break;&#125; if(i&lt;=num[s1]&amp;&amp;(f[s1][i]&lt;f[s2][j]||j&gt;num[s2]))&#123;f[now][p]=f[s1][i];i++;&#125; else if(j&lt;=num[s2])&#123;f[now][p]=f[s2][j];j++;&#125; &#125;&#125;int main()&#123; srand(20050429); n=read();m=read(); for(register int i=m+1;i&lt;=n;i++)&#123;son[i][0]=read();son[i][1]=read();&#125; for(int r=1;r&lt;=4;r++) &#123; for(register int i=1;i&lt;=n;i++)&#123;w[i]=rand();while(!w[i])w[i]=rand();&#125; for(register int i=1;i&lt;=m;i++)&#123;f[i][1]=w[i];num[i]=1;&#125; for(register int i=m+1;i&lt;=n;i++) &#123; Merge(son[i][0],son[i][1],i); if(num[i]&lt;k) ans[i]=num[i]*4; //如果还没到k个就不用根据期望计算了 else ans[i]+=(LL)k*RAND_MAX/f[i][k]; &#125; &#125; for(int i=m+1;i&lt;=n;i++) printf("%lld\n",ans[i]/4); return 0;&#125;]]></content>
      <categories>
        <category>随机算法</category>
      </categories>
      <tags>
        <tag>随机算法</tag>
        <tag>DAG</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「洛谷P2617」Dynamic Rankings]]></title>
    <url>%2F2019%2F01%2F23%2F%E3%80%8C%E6%B4%9B%E8%B0%B7P2617%E3%80%8DDynamic-Rankings%2F</url>
    <content type="text"><![CDATA[标算又是树套树？写不来QwQ… 传送门BZOJ(是个权限题QwQ) 洛谷P2617 题解据说这题可以用带修主席树、树套树、整体二分解。由于蒟蒻我实在太菜了QwQ，只好选择了整体二分。 把刚原始序列理解为n个添加操作，将修改操作理解为一个删除操作和一个添加操作。然后直接上整体二分，解法类似于「ZJOI2013」K大数查询。并且由于每次只需要修改一个位置的信息，所以用普通树状数组就行了呢poi，快得飞起（尽管我自带大常数QwQ）。 代码整体二分又好写又好理解呢poi 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283#include&lt;cstdio&gt;using namespace std;const int maxn=100005;int n,m,tot,cnt,ans[maxn],A[maxn];inline int read()&#123; int ret=0,f=1;char ch=getchar(); while(ch&lt;'0'||ch&gt;'9')&#123;if(ch=='-')f=-f;ch=getchar();&#125; while(ch&gt;='0'&amp;&amp;ch&lt;='9')&#123;ret=ret*10+ch-'0';ch=getchar();&#125; return ret*f;&#125;struct BIT //封装好的树状数组&#123; int Tree[maxn]; void Update(int pos,int delta)&#123;while(pos&lt;=n)&#123;Tree[pos]+=delta;pos+=pos&amp;-pos;&#125;&#125; int Query(int pos)&#123;int ret=0;while(pos&gt;0)&#123;ret+=Tree[pos];pos-=pos&amp;-pos;&#125;return ret;&#125;&#125;Tr;struct Command&#123;int typ,idx,num,delta,L,R,k,id;&#125;Q[maxn*4],Q1[maxn*4],Q2[maxn*4];char GetChar() //读取操作类型，排除无用字符&#123; char ch=getchar(); while(ch!='C'&amp;&amp;ch!='Q') ch=getchar(); return ch;&#125;void BinarySearch(int L,int R,int S,int T) //整体二分&#123; if(L&gt;R||S&gt;T) return; int mid=L+R&gt;&gt;1,til1=0,til2=0; if(L==R) &#123; for(int i=S;i&lt;=T;i++) if(Q[i].typ) ans[Q[i].id]=mid; return; &#125; for(int i=S;i&lt;=T;i++) &#123; if(!Q[i].typ) &#123; if(Q[i].num&lt;=mid) &#123; Tr.Update(Q[i].idx,Q[i].delta); Q1[++til1]=Q[i]; &#125; else Q2[++til2]=Q[i]; &#125; else &#123; int cnt=Tr.Query(Q[i].R)-Tr.Query(Q[i].L-1); if(cnt&lt;Q[i].k) &#123; Q[i].k-=cnt; Q2[++til2]=Q[i]; &#125; else Q1[++til1]=Q[i]; &#125; &#125; for(int i=S;i&lt;=T;i++) //别忘了还原树状数组哟poi if(!Q[i].typ) if(Q[i].num&lt;=mid) Tr.Update(Q[i].idx,-Q[i].delta); for(int i=1;i&lt;=til1;i++) Q[S+i-1]=Q1[i]; for(int i=1;i&lt;=til2;i++) Q[S+til1+i-1]=Q2[i]; BinarySearch(L,mid,S,S+til1-1); BinarySearch(mid+1,R,S+til1,T);&#125;int main()&#123; n=read();m=read(); for(int i=1;i&lt;=n;i++)&#123;tot++;Q[tot].idx=i;Q[tot].num=A[i]=read();Q[tot].delta=1;&#125; for(int i=1;i&lt;=m;i++) &#123; if(GetChar()=='Q')&#123;tot++;cnt++;Q[tot].typ=1;Q[tot].L=read();Q[tot].R=read();Q[tot].k=read();Q[tot].id=cnt;&#125; else &#123; tot++;Q[tot].idx=read();Q[tot].num=read();Q[tot].delta=1; tot++;Q[tot].idx=Q[tot-1].idx;Q[tot].num=A[Q[tot-1].idx];A[Q[tot-1].idx]=Q[tot-1].num;Q[tot].delta=-1; &#125; &#125; BinarySearch(0,1000000000,1,tot); for(int i=1;i&lt;=cnt;i++) printf("%d\n",ans[i]); return 0;&#125;]]></content>
      <categories>
        <category>整体二分</category>
      </categories>
      <tags>
        <tag>主席树</tag>
        <tag>整体二分</tag>
        <tag>树套树</tag>
        <tag>树状数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「国家集训队」聪聪可可]]></title>
    <url>%2F2019%2F01%2F16%2F%E3%80%8C%E5%9B%BD%E5%AE%B6%E9%9B%86%E8%AE%AD%E9%98%9F%E3%80%8D%E8%81%AA%E8%81%AA%E5%8F%AF%E5%8F%AF%2F</url>
    <content type="text"><![CDATA[我数数最差了QwQ… 传送门洛谷P2634 BZOJ2152 题解很显然这是一道假的概率题。而是一道数数题，只要数出路径长度为3的倍数的点对的数量就行了呢poi。 隔壁dalao说这是一道点分治裸题，但是我还是觉得树形DP更好写一些QwQ。 定义$F_{ij}(j \in \lbrace 0,1,2 \rbrace)$表示节点$i$的子树中，到i的距离$\mod 3=j$的节点个数。如果当前遍历到的节点为i，我们需要计算出$i$及其子树中满足最短路径经过节点$i$且满足路径长是3的倍数的节点个数，累计到答案里最后除以$n^2$并约分就好了呢poi。 注意起点和终点可以相同，计算时小心点，不要算重复也不要漏算了哟poi。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243#include&lt;cstdio&gt;using namespace std;const int maxn=20005;int n,tot,lnk[maxn],son[maxn*2],w[maxn*2],nxt[maxn*2],F[maxn][3],ans1,ans2;inline int read()&#123; int ret=0,f=1;char ch=getchar(); while(ch&lt;'0'||ch&gt;'9')&#123;if(ch=='-')f=-f;ch=getchar();&#125; while(ch&gt;='0'&amp;&amp;ch&lt;='9')&#123;ret=ret*10+ch-'0';ch=getchar();&#125; return ret*f;&#125;inline void add_e(int x,int y,int z)&#123;tot++;son[tot]=y;w[tot]=z;nxt[tot]=lnk[x];lnk[x]=tot;&#125;int gcd(int x,int y)&#123;return !y?x:gcd(y,x%y);&#125;void DFS(int now,int fa)&#123; F[now][0]=1; for(int i=lnk[now];i;i=nxt[i]) &#123; if(son[i]!=fa) &#123; DFS(son[i],now); for(int j=0;j&lt;3;j++) ans1+=F[son[i]][j]*F[now][((3-j-w[i])%3+3)%3]*2; for(int j=0;j&lt;3;j++) F[now][(j+w[i])%3]+=F[son[i]][j]; &#125; &#125;&#125;int main()&#123; n=read(); for(int i=1;i&lt;n;i++) &#123; int a=read(),b=read(),c=read(); add_e(a,b,c);add_e(b,a,c); &#125; DFS(1,0); ans1+=n;ans2=n*n; int gys=gcd(ans1,ans2); ans1/=gys;ans2/=gys; printf("%d/%d\n",ans1,ans2); return 0;&#125;]]></content>
      <categories>
        <category>树形DP</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>数数</tag>
        <tag>概率</tag>
        <tag>DFS</tag>
        <tag>点分治</tag>
        <tag>树形DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「洛谷P5059」中国象棋]]></title>
    <url>%2F2019%2F01%2F16%2F%E3%80%8C%E6%B4%9B%E8%B0%B7P5059%E3%80%8D%E4%B8%AD%E5%9B%BD%E8%B1%A1%E6%A3%8B%2F</url>
    <content type="text"><![CDATA[又是数数题QwQ… 传送门洛谷P5059 题解首先注意题目中说的是有$n^2$个格子，也就是$(n+1)^2$个格点。 以下是出题人的推导： 首先我们可以发现每一行是独立的，所以只需要处理一行的答案即可 设$F[i][0]$表示一行中摆了$i$个位置且第$i$个位置不摆放棋子的方案数 设$F[i][1]$表示一行中摆了$i$个位置且第$i$个位置摆放棋子的方案数 设$Ans[i]$表示$F[i][0]+F[i][1]$ 那么忽略第二个限制可以发现有: $F[i][0]=F[i-1][0]+F[i-1][1]$ $F[i][1]=F[i-1][0]$ 所以有 $Ans[i]$ $=F[i][0]+F[i][1]$ $=2F[i-1][0]+F[i-1][1]$ $=(F[i-1][0]+F[i-1][1])+(F[i-2][0]+F[i-2][1])$ $=Ans[i-1]+Ans[i-2]$ 好了很显然这是一个斐波那契数列。自己再推一下，注意一下细节，不难发现最后的答案就是 (Fib_{n+3}-n-2)^{n+1}矩阵加快速幂就可以在$\Theta(\log n)$的复杂内求解。 还有一个问题，由于n和P都非常大，直接乘long long也会boom。所以这里用了一个类似于快速幂的方法来求$(a*b)\mod P$的值。虽然复杂度多了一只log，但是很好写，并且避免了高精度又臭又长的代码和大常数复杂度。 代码还挺好写的呢poi。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include&lt;cstdio&gt;using namespace std;typedef long long LL;LL n,P;LL Multiply(LL x,LL y) //两个10^18级别的数在模P意义下的乘法&#123; LL ret=0,w=x; while(y) &#123; if(y&amp;1) ret=(ret+w)%P; w=(w+w)%P;y&gt;&gt;=1; &#125; return ret;&#125;struct Matrix&#123; LL a[2][2]; Matrix()&#123;a[0][0]=a[0][1]=a[1][0]=a[1][1]=0;&#125; Matrix operator * (Matrix b) //矩阵乘法 &#123; Matrix c; for(int i=0;i&lt;2;i++) for(int j=0;j&lt;2;j++) for(int k=0;k&lt;2;k++) c.a[i][j]=(c.a[i][j]+Multiply(a[k][j],b.a[i][k]))%P; return c; &#125;&#125;ans,mat,tep;LL QP(LL a,LL b) //普通快速幂&#123; LL ret=1,w=a; while(b) &#123; if(b&amp;1) ret=Multiply(ret,w); w=Multiply(w,w);b&gt;&gt;=1; &#125; return ret;&#125;int main()&#123; scanf("%lld%lld",&amp;n,&amp;P); ans.a[0][0]=ans.a[0][1]=mat.a[0][0]=mat.a[0][1]=mat.a[1][0]=1; LL b=n+1;tep=mat; while(b) //矩阵加速斐波那契数列 &#123; if(b&amp;1) mat=mat*tep; tep=tep*tep;b&gt;&gt;=1; &#125; ans=ans*mat; printf("%lld\n",QP(((ans.a[0][0]-n-2)%P+P)%P,n+1)); return 0;&#125;]]></content>
      <categories>
        <category>矩阵加速DP</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>数数</tag>
        <tag>快速幂</tag>
        <tag>矩阵加速</tag>
        <tag>斐波那契数列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「JSOI2004」平衡点/吊打XXX]]></title>
    <url>%2F2019%2F01%2F15%2F%E3%80%8CJSOI2004%E3%80%8D%E5%B9%B3%E8%A1%A1%E7%82%B9%20%E5%90%8A%E6%89%93XXX-Solution%2F</url>
    <content type="text"><![CDATA[这是一个欧皇与非酋的故事…… 引言很久很久以前，有一位欧皇叫做黄霖，他热衷于各种随机算法，而且每次都能AC，直到有一天，他看到了张老师（ZS，我的启蒙老师，他水平很高，造数据能力特强）出的一份卷子： 黄霖：嗯！T1模拟退火能AC！T2模拟退火也能AC！T3模拟退火照样AC！ 张老师（冷笑）：嗯哼？三题都写模拟退火？有分吗？ 然后就没有然后了呢poi… 传送门洛谷P1337 题解这是一道物理题。 首先根据最小势能原理，当整个系统的势能最小时，系统平衡。不要问我为什么QwQ，我物理不好呢poi 虽然这题的正解不是模拟退火，但是用这题来当模拟退火的经典题还是很不错的呢poi。 首先我们钦定一个点作为绳结所在的位置作为初始答案，然后计算势能。 每次都在当前答案点附近的一个区域内rand一个点，区域大小由当前温度决定，如果这个点更优（势能更小），那么久接收这个点作为答案。否则有一定的概率接收新答案（概率计算方法很玄学，但是温度越小接收的概率越大）。 然后将温度乘以一个降温系数（降温系数是一个小于1的正数，这一步即退火），然后进行下一次答案搜索。 当温度降到几乎为0时停止就行了呢poi。 退火技巧首先可以多退几次。 降温系数要根据题目细调，太大了会导致时效差，太小可能搜不到最优解QwQ。 初始温度也要根据情况给定，可以用一些历史上特殊的日子，比如某dalao的生日来做初始温度呢poi。 种子也建议用某dalao的生日，或脸滚键盘，最好不要用初始值。 没事时多放放大悲咒，往生咒，般若波罗蜜多心经之类的音乐，你将得到佛祖的保佑。 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;cstdlib&gt;using namespace std;const int maxn=1005;const double delta=0.995; //降温系数int n,X[maxn],Y[maxn],W[maxn];double ansx,ansy,anse;inline int read()&#123; int ret=0,f=1;char ch=getchar(); while(ch&lt;'0'||ch&gt;'9')&#123;if(ch=='-')f=-f;ch=getchar();&#125; while(ch&gt;='0'&amp;&amp;ch&lt;='9')&#123;ret=ret*10+ch-'0';ch=getchar();&#125; return ret*f;&#125;inline double PotentialEnergy(double nowx,double nowy) //计算势能&#123; double ret=0; for(int i=1;i&lt;=n;i++) ret+=sqrt((X[i]-nowx)*(X[i]-nowx)+(Y[i]-nowy)*(Y[i]-nowy))*W[i]; return ret;&#125;inline void SimulateAnneal(double T)&#123; double nowx=ansx,nowy=ansy; while(T&gt;1e-14) &#123; double tempx=nowx+(rand()*2-RAND_MAX)*T; double tempy=nowy+(rand()*2-RAND_MAX)*T; double PE=PotentialEnergy(tempx,tempy); if(PE&lt;anse) //如果更优就马上接受 &#123; ansx=tempx;ansy=tempy; nowx=tempx;nowy=tempy; anse=PE; &#125; else if(exp((anse-PE)/T)*RAND_MAX&gt;rand())&#123;nowx=tempx;nowy=tempy;&#125; //否则有一定概率接收 T*=delta; //降温 &#125;&#125;inline void Solve()&#123; anse=PotentialEnergy(ansx,ansy); SimulateAnneal(2005); //多刷几次，记得洗把脸 SimulateAnneal(1926); SimulateAnneal(1949); SimulateAnneal(1978);&#125;int main()&#123; srand(20050429);//2005年4月29日dalao LTL出生，dalao会为你带来好运 n=read(); for(int i=1;i&lt;=n;i++)&#123;X[i]=read();Y[i]=read();W[i]=read();&#125; Solve(); printf("%.3lf %.3lf\n",ansx,ansy); return 0;&#125;]]></content>
      <categories>
        <category>模拟退火</category>
      </categories>
      <tags>
        <tag>随机算法</tag>
        <tag>模拟退火</tag>
        <tag>物理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「USACO2015JAN」草鉴定Grass Cownoisseur]]></title>
    <url>%2F2019%2F01%2F14%2F%E3%80%8CUSACO2015JAN%E3%80%8D%E8%8D%89%E9%89%B4%E5%AE%9AGrass-Cownoisseur%20-Solution%2F</url>
    <content type="text"><![CDATA[骚年，快来看！奶牛Bessie又在吃草了QwQ。 传送门洛谷P3119 题解单向道路？求一次能遍历到的最大点的数量？二话不说先上个Tarjan缩个点压压惊poi。 如果没有逆行这种操作，那么很显然起点所在强联通分量点的个数就是答案。 可是Bessie就是Bessie，总要搞点事情出来才符合她的性格。 于是乎我们缩点之后正反建图，刷两趟SPFA求每个点到起点的最长路。 然后枚举缩完点的图上的一条边，用来搞事情逆行。设当前枚举到的边为$(u,v)$，那么$u$在正建的图上到起点的最长路加上$v$在反建图上到起点的最长路就是逆行这条边时的最优解。在所有边里刷个最大值就行了呢poi。 有几个坑： 在最后计算答案时起点的权值会被算两次，记得减去一个。 枚举用于逆行的边时需要确保可以走到这条边并且走到这条边后可以走回起点。 由于需要建三套图(没缩过点的一套正建图一套反建图一套)，不要把数组名搞混了。此时封装可能是个好办法（但是会长一些，所以我没封装）。 其实总体上讲这题的想法并不难，但是代码有点难码QwQ。 于是乎这题就解完了。时间复杂度为$\Theta(n)$。 代码我觉得我写的挺简洁的poi。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687#include&lt;cstdio&gt;#include&lt;cstring&gt;using namespace std;const int maxn=100005;int n,m,tot[3],lnk[3][maxn],son[3][maxn],nxt[3][maxn],w[maxn],idx,dfn[maxn],low[maxn],top,stack[maxn],cnt,id[maxn],dist[3][maxn],que[maxn],ans;bool vis[maxn];inline int read()&#123; int ret=0,f=1;char ch=getchar(); while(ch&lt;'0'||ch&gt;'9')&#123;if(ch=='-')f=-f;ch=getchar();&#125; while(ch&gt;='0'&amp;&amp;ch&lt;='9')&#123;ret=ret*10+ch-'0';ch=getchar();&#125; return ret*f;&#125;inline void add_e(int x,int y,int id)&#123;tot[id]++;son[id][tot[id]]=y;nxt[id][tot[id]]=lnk[id][x];lnk[id][x]=tot[id];&#125;void Tarjan(int now)&#123; idx++;top++;vis[now]=true; dfn[now]=low[now]=idx;stack[top]=now; for(int i=lnk[0][now];i;i=nxt[0][i]) &#123; if(!dfn[son[0][i]]) &#123; Tarjan(son[0][i]); if(low[son[0][i]]&lt;low[now]) low[now]=low[son[0][i]]; &#125; else if(vis[son[0][i]]&amp;&amp;dfn[son[0][i]]&lt;low[now]) low[now]=dfn[son[0][i]]; &#125; if(dfn[now]==low[now]) &#123; cnt++; do &#123; id[stack[top]]=cnt;w[cnt]++; vis[stack[top]]=false;top--; &#125;while(stack[top+1]!=now); &#125;&#125;inline void SPFA(int id)&#123; memset(vis,false,sizeof(vis)); int hed=0,til=1; que[1]=::id[1];vis[que[1]]=true;dist[id][que[1]]=w[que[1]]; while(hed!=til) &#123; hed=(hed+1)%maxn;vis[que[hed]]=false; for(int j=lnk[id][que[hed]];j;j=nxt[id][j]) &#123; if(dist[id][que[hed]]+w[son[id][j]]&gt;dist[id][son[id][j]]) &#123; dist[id][son[id][j]]=dist[id][que[hed]]+w[son[id][j]]; if(!vis[son[id][j]]) &#123; vis[son[id][j]]=true; til=(til+1)%maxn; que[til]=son[id][j]; &#125; &#125; &#125; &#125;&#125;int main()&#123; n=read();m=read(); for(int i=1;i&lt;=m;i++) &#123; int a=read(),b=read(); add_e(a,b,0); &#125; for(int i=1;i&lt;=n;i++) if(!dfn[i]) Tarjan(i); for(int i=1;i&lt;=n;i++) &#123; for(int j=lnk[0][i];j;j=nxt[0][j]) &#123; if(id[i]!=id[son[0][j]]) &#123; add_e(id[i],id[son[0][j]],1); add_e(id[son[0][j]],id[i],2); &#125; &#125; &#125; SPFA(1);SPFA(2); for(int i=1;i&lt;=cnt;i++) for(int j=lnk[2][i];j;j=nxt[2][j]) if(dist[1][i]&amp;&amp;dist[2][son[2][j]]&amp;&amp;dist[1][i]+dist[2][son[2][j]]-w[id[1]]&gt;ans) ans=dist[1][i]+dist[2][son[2][j]]-w[id[1]]; printf("%d\n",ans); return 0;&#125;]]></content>
      <categories>
        <category>强联通分量</category>
      </categories>
      <tags>
        <tag>DAG</tag>
        <tag>Tarjan</tag>
        <tag>强联通分量</tag>
        <tag>最短路</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「HNOI2016」树]]></title>
    <url>%2F2019%2F01%2F05%2F%E3%80%8CHNOI2016%E3%80%8D%E6%A0%91-Solution%2F</url>
    <content type="text"><![CDATA[骚年，来看看这棵 真•树套树 吧！ 传送门洛谷 BZOJ 题解蒟蒻我定睛一看，一共有$10^{10}$个点，立马把蒟蒻我给吓到了QwQ。显然这是一道毒瘤题。我深深地感受到了出题人的恶意(然而我还是太菜了，像XHW这种dalao就可以想着要把出题人阿掉，我却不行)。 既然有这么多点，肯定是存不下的。因为每次操作都是copy一整颗子树，所以我们可以用一种叫做 真•树套树 的方法来解决呢poi。 我们构造大树时，令每一个大节点都对应模板树中的一整棵子树，并对新树重新编号，就像这样（样例）： 然后我们定义两个大节点之间的边的变权为两个大节点所包含的树的树根之间的距离。如上图中大节点1和2之间的边权为2,1与3之间的边权为3。 每一个大节点还需要存储以下信息： S[],T[]：该大节点包含的小节点的编号区间的起点和终点，如上图节点1的编号区间是[1,5]，节点2是[6,8]，节点3是[9,9]。 pre[]：该大节点对应的是模板树中哪一个节点的子树，如pre[1]=1，pre[2]=4，pre[3]=3。 lnk[]：该大节点挂在大树中的哪一个节点底下，如lnk[2]=3，lnk[3]=2。 以及常见的倍增LCA所需的信息。 还需要写几个函数： int GetRoot(long long u);用于查找小节点u所在的大节点。构造好S[],T[0]后，二分即可实现。 int GetPre(long long u);用于查找小节点u在模板树中对应的是哪个节点。假设小节点u在大节点rt里，那么根据题意，我们要找的就是rt对应的模板树的子树中该子树编号第$u-S[rt]+1$小的节点。这个我们可以把模板树一巴掌拍扁求个DFS序，然后用主席树解决（不会主席树的童鞋戳这里）。 int GetDist(int u,int v);用于求模板树上的节点u,v之间的距离。LCA解决。 然后就可以开始考虑如何计算答案了。 计算答案的主要思想就是在大树上通过倍增LCA求解，但是与普通LCA不同的是，不能纯粹地就在大树上LCA，需要注意很多细节。比如当再跳一步就跳到最近的大节点公共祖先时，不能马上往上跳，而需要往上跳一小步后转到模板树上去LCA。因为计算答案的细节，劳资%@#@￥%(文明靠大家)地交了4次才AC(不过好像也不算多)。 这样这题就解完了。时空复杂度都是大约$\Theta(超大常数*n\log n)$呢poi。 总结&amp;反思这是一道十分毒瘤的代码题(但是在某些dalao眼里就是送分题)，思维难度一般，但蒟蒻我前前后后一共花了3个多小时才AC(听说隔壁XCW一看题就秒掉了)QwQ。这道题很好地反映出蒟蒻我的代码实现能力还是太差，可能是由于做题太少的缘故。我虽然很菜，但是如果ZJOI2019真的出了像这样的一道题(或者类似于猪国杀什么的)，空有想法却没时间写代码和调试，那可就亏大发了QwQ。 代码蒟蒻我为了避免变量重名，于是开了两个namespace（不知代码是更好看了还是更丑了）。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;typedef long long LL;const int maxn=100005,LOG=20;int Q;inline LL read()&#123; LL ret=0,f=1;char ch=getchar(); while(ch&lt;'0'||ch&gt;'9')&#123;if(ch=='-')f=-f;ch=getchar();&#125; while(ch&gt;='0'&amp;&amp;ch&lt;='9')&#123;ret=ret*10+ch-'0';ch=getchar();&#125; return ret*f;&#125;struct ChairmanTree //封装好的主席树&#123; int tot,T[maxn]; struct Node&#123;int L,R,Sum;&#125;Tree[maxn*LOG]; int Build(int L,int R) &#123; int rt=++tot,mid=L+R&gt;&gt;1; if(L&gt;=R) return rt; Tree[rt].L=Build(L,mid); Tree[rt].R=Build(mid+1,R); if(rt==1) T[0]=rt; return rt; &#125; int Update(int num,int pre,int L,int R) &#123; int rt=++tot,mid=L+R&gt;&gt;1; Tree[rt].L=Tree[pre].L;Tree[rt].R=Tree[pre].R;Tree[rt].Sum=Tree[pre].Sum+1; if(L&gt;=R) return rt; if(num&lt;=mid) Tree[rt].L=Update(num,Tree[pre].L,L,mid); else Tree[rt].R=Update(num,Tree[pre].R,mid+1,R); return rt; &#125; int Query(int u,int v,int k,int L,int R) &#123; int mid=L+R&gt;&gt;1,x=Tree[Tree[v].L].Sum-Tree[Tree[u].L].Sum; if(L==R) return mid; if(x&gt;=k) return Query(Tree[u].L,Tree[v].L,k,L,mid); else return Query(Tree[u].R,Tree[v].R,k-x,mid+1,R); &#125;&#125;CT;namespace TemplateTree //模板树&#123; int n,father[maxn][LOG],dep[maxn],idx,que[maxn],S[maxn],T[maxn],tot,lnk[maxn],son[maxn*2],nxt[maxn*2]; inline void add_e(int x,int y)&#123;tot++;son[tot]=y;nxt[tot]=lnk[x];lnk[x]=tot;&#125; void Build(int now,int fa) //把树上的一些信息构造好 &#123; S[now]=++idx;que[idx]=now;father[now][0]=fa;dep[now]=dep[fa]+1; for(int i=1;i&lt;=16;i++) father[now][i]=father[father[now][i-1]][i-1]; for(int i=lnk[now];i;i=nxt[i]) if(son[i]!=fa) Build(son[i],now); T[now]=idx; &#125; inline void BuildCT() //初始化主席树 &#123; CT.Build(1,n); for(int i=1;i&lt;=n;i++) CT.T[i]=CT.Update(que[i],CT.T[i-1],1,n); &#125; inline void Input() //读入数据 &#123; for(int i=1;i&lt;n;i++) &#123; int a=read(),b=read(); add_e(a,b);add_e(b,a); &#125; Build(1,0);BuildCT(); &#125; int GetDist(int u,int v) //LCA求亮点间距离 &#123; int ret=0; if(dep[u]&lt;dep[v]) swap(u,v); for(int i=16;i&gt;=0;i--) if(dep[father[u][i]]&gt;=dep[v])&#123;ret+=(1&lt;&lt;i);u=father[u][i];&#125; for(int i=16;i&gt;=0;i--) if(father[u][i]!=father[v][i])&#123;ret+=(1&lt;&lt;i+1);u=father[u][i];v=father[v][i];&#125; if(u==v) return ret; return ret+2; &#125;&#125;namespace BigTree //大树&#123; int n,m,father[maxn][LOG],dep[maxn],pre[maxn];LL dist[maxn][LOG],S[maxn],T[maxn],lnk[maxn],cnt; inline int GetRoot(LL u) &#123; int L=1,R=n,mid; while(L&lt;=R) &#123; mid=L+R&gt;&gt;1; S[mid]&lt;=u?L=mid+1:R=mid-1; &#125; return R; &#125; inline int GetPre(LL u) &#123; int rt=GetRoot(u); return CT.Query(CT.T[TemplateTree::S[pre[rt]]-1],CT.T[TemplateTree::T[pre[rt]]],u-S[rt]+1,1,TemplateTree::n); &#125; inline void Build() //初始化大树 &#123; n=1;dep[1]=1;pre[1]=1;S[1]=1;T[1]=TemplateTree::n;cnt=T[1]; for(int i=1;i&lt;=m;i++) &#123; int fr=read();LL to=read();int rt=GetRoot(to); n++;dep[n]=dep[rt]+1;lnk[n]=to;pre[n]=fr;S[n]=cnt+1;T[n]=cnt+TemplateTree::T[fr]-TemplateTree::S[fr]+1;cnt=T[n]; father[n][0]=rt;dist[n][0]=TemplateTree::dep[GetPre(to)]-TemplateTree::dep[pre[rt]]+1; for(int j=1;j&lt;=16;j++)&#123;father[n][j]=father[father[n][j-1]][j-1];dist[n][j]=dist[n][j-1]+dist[father[n][j-1]][j-1];&#125; &#125; &#125; inline LL Solve(LL u,LL v) //计算答案(写的真丑QwQ) &#123; LL ret=0;int rtu=GetRoot(u),rtv=GetRoot(v); if(rtu==rtv) return TemplateTree::GetDist(GetPre(u),GetPre(v)); if(dep[rtu]&lt;dep[rtv])&#123;swap(u,v);swap(rtu,rtv);&#125; ret+=TemplateTree::dep[GetPre(u)]-TemplateTree::dep[pre[rtu]];u=rtu; for(int i=16;i&gt;=0;i--) if(dep[father[u][i]]&gt;dep[rtv])&#123;ret+=dist[u][i];u=father[u][i];&#125; if(GetRoot(lnk[u])==rtv) return ret+1+TemplateTree::GetDist(GetPre(lnk[u]),GetPre(v)); ret+=TemplateTree::dep[GetPre(v)]-TemplateTree::dep[pre[rtv]];v=rtv; if(dep[u]&gt;dep[v])&#123;ret+=dist[u][0];u=father[u][0];&#125; for(int i=16;i&gt;=0;i--) if(father[u][i]!=father[v][i])&#123;ret+=dist[u][i]+dist[v][i];u=father[u][i];v=father[v][i];&#125; u=lnk[u];v=lnk[v];ret+=2; return ret+TemplateTree::GetDist(GetPre(u),GetPre(v)); &#125;&#125;int main() //好简洁的主函数&#123; TemplateTree::n=read();BigTree::m=read();Q=read(); TemplateTree::Input();BigTree::Build(); while(Q--) printf("%lld\n",BigTree::Solve(read(),read())); return 0;&#125;]]></content>
      <categories>
        <category>树上问题</category>
      </categories>
      <tags>
        <tag>树上问题</tag>
        <tag>LCA</tag>
        <tag>主席树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[主席树（可持久化线段树）]]></title>
    <url>%2F2019%2F01%2F04%2F%E4%B8%BB%E5%B8%AD%E6%A0%91%EF%BC%88%E5%8F%AF%E6%8C%81%E4%B9%85%E5%8C%96%E7%BA%BF%E6%AE%B5%E6%A0%91%EF%BC%89%2F</url>
    <content type="text"><![CDATA[骚年，你需要一棵主席树！它会赐予你力量！ 传送门洛谷的主席树模板题 正文引入问题我们可能时常会遇到这样的一类问题：给定一个序列$A$和若干组询问，每次给定一个区间$[L,R]$和一个参数$k$，问序列上该区间中第$k$大的元素是多少。 对于这类问题，暴力算法显而易见(但是会T飞)。一个很好的解决办法就是用主席树(其实洛谷上的这道模板题不强制在线，分块+莫队可以AC，还跑得贼快)。 说一句题外话，主席树这种数据结构据说是一位名字缩写是HJT的神仙在考场上现场yy出来的，而HJT正是新中国历史上一位著名主席的名字缩写，因此得名。 考虑初始版本首先请确保你已经掌握普通线段树的写法，不会的童鞋请自行Ctrl+W。 我们建$n$权值棵线段树，第$i$棵线段树需要维护序列$A_1$~$A_i$中，每个权值出现的次数。比如说第$i$棵线段树上的一个节点管辖的权值区间是$[S,T]$，该节点需要储存满足$A_j\inS,T$的元素$A_j$的个数。可以将这些线段树一开始就构造好。 当进行询问的时候，如果当前的询问区间是$[L,R]$那么我们就把第$L-1$棵线段树和第$R$棵线段树拎出来，根据容斥的原理，将两棵线段树每个节点的权值相减就能得到一颗有我们想要用的包含$A_L$~$A_R$的信息的权值线段树。 然后我们就在这棵线段树上计算答案。 首先先遍历树根，假设当前节点管辖的权值区间是$[L,R]$，权值在该区间内的元素的个数和是$sum$。 如果$sum\leq k$，那么遍历当前节点的左儿子。 否则将$k$的值减去$sum$，然后遍历右儿子。 循环以上步骤，直到$L=R$，此时的$L$就是答案。 完善初始版本说真的，初始版本又难码又慢，比暴力算法还垃圾QwQ 现在考虑完善一下初始版本，让它成为一棵真正的主席树！ 首先在询问的时候，不需要每次都重构一棵线段树，用两个指针同时在两棵线段树上遍历，查个数的时候再相减就行了。 其次，如果真的开$n$棵完整的权值线段树，内存不炸才怪QwQ。 我们发现，第$i$棵权值线段树是在继承第$i-1$棵的信息的基础上，再添加第$i$个元素的信息。而根据线段树的性质，每进行一次修改，最多只会改变$\log n$个节点的信息。所以我们动态开点，在开第$i$棵线段树时，只新开修改过的节点，并把新开的节点直接接到没有修改过的已有节点上就可以了QwQ。骚年，你感受到了可持久化的力量了吗？ 还有，由于元素的权值可能很大，我们需要将原序列先离散化。 这样，我们就成功地把时间复杂度和空间复杂度都下压至$\Theta(n\log n)$的水平。主席树万岁！ 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include&lt;map&gt;#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;const int maxn=200005,LOG=20;int n,m,cnt,A[maxn],B[maxn];map&lt;int,int&gt; H;inline int read()&#123; int ret=0,f=1;char ch=getchar(); while(ch&lt;'0'||ch&gt;'9')&#123;if(ch=='-')f=-f;ch=getchar();&#125; while(ch&gt;='0'&amp;&amp;ch&lt;='9')&#123;ret=ret*10+ch-'0';ch=getchar();&#125; return ret*f;&#125;struct ChairmanTree //封装大法好&#123; int tot,T[maxn]; struct Node&#123;int L,R,Sum;&#125;Tree[maxn*LOG]; int Build(int L,int R) //在开始添加信息之前，先初始化 &#123; int rt=++tot,mid=L+R&gt;&gt;1; if(L&gt;=R) return rt; Tree[rt].L=Build(L,mid); Tree[rt].R=Build(mid+1,R); if(rt==1) T[0]=rt; return rt; &#125; int Update(int num,int pre,int L,int R) //添加信息 &#123; int rt=++tot,mid=L+R&gt;&gt;1; Tree[rt].L=Tree[pre].L;Tree[rt].R=Tree[pre].R;Tree[rt].Sum=Tree[pre].Sum+1; if(L&gt;=R) return rt; if(num&lt;=mid) Tree[rt].L=Update(num,Tree[pre].L,L,mid); else Tree[rt].R=Update(num,Tree[pre].R,mid+1,R); return rt; &#125; int Query(int u,int v,int k,int L,int R) //询问 &#123; int mid=L+R&gt;&gt;1,x=Tree[Tree[v].L].Sum-Tree[Tree[u].L].Sum; if(L==R) return mid; //找到了 if(x&gt;=k) return Query(Tree[u].L,Tree[v].L,k,L,mid); //分类讨论 else return Query(Tree[u].R,Tree[v].R,k-x,mid+1,R); &#125;&#125;CT;int main()&#123; n=read();m=read(); for(int i=1;i&lt;=n;i++) A[i]=B[i]=read(); sort(B+1,B+1+n);cnt=unique(B+1,B+1+n)-B-1; //离散化 for(int i=1;i&lt;=cnt;i++) H[B[i]]=i; CT.Build(1,cnt); for(int i=1;i&lt;=n;i++) CT.T[i]=CT.Update(H[A[i]],CT.T[i-1],1,cnt); while(m--) &#123; int L=read(),R=read(),k=read(); printf("%d\n",B[CT.Query(CT.T[L-1],CT.T[R],k,1,cnt)]); &#125; return 0;&#125; 其他其实主席树也可以维护带修改操作的序列，但是蒟蒻我现在还不会QwQ。]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>主席树</tag>
        <tag>数据结构</tag>
        <tag>线段树</tag>
        <tag>可持久化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[XZY的女装flag(捂脸]]></title>
    <url>%2F2018%2F12%2F31%2FXZY%E7%9A%84%E5%A5%B3%E8%A3%85flag%2F</url>
    <content type="text"><![CDATA[震惊！蒟蒻XZY竟在大年夜当众….. 如果你想了解蒟蒻我女装的原因，右拐公告。 蒟蒻我虽然NOIP翻车了，翻得挺惨，但是CCF很仁慈，可怜了一下蒟蒻我，为此，我忍不住又吟诗一首： 咳咳，XZY的女装flag已近兑现入土了。 照片在底下(蒟蒻我和巨佬XXC女装的合照) % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % 瘦一点的，穿白色蕾丝裙的是蒟蒻我，旁边穿日款夏装的是巨佬XXC(妈的，冻死宝宝了)。 XXC巨佬的blog 晚上光线真的不好qwq，拍出来不好看poi。 警告：照片看看就好，不要用作任何非法用途qwq。]]></content>
      <categories>
        <category>公告</category>
      </categories>
      <tags>
        <tag>flag</tag>
        <tag>女装</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「国家集训队」数颜色/维护队列]]></title>
    <url>%2F2018%2F12%2F27%2F%E3%80%8C%E5%9B%BD%E5%AE%B6%E9%9B%86%E8%AE%AD%E9%98%9F%E3%80%8D%E6%95%B0%E9%A2%9C%E8%89%B2%20%E7%BB%B4%E6%8A%A4%E9%98%9F%E5%88%97%2F</url>
    <content type="text"><![CDATA[什么？维护序列的题？当然是上莫队啦poi！ 传送门洛谷传送门 BZOJ传送门 题解很显然这是一道莫队的题呢poi！ 但是有修改操作QwQ。 怎么办呢poi？ 当然是写一个资瓷修改的莫队啦！(好像都是废话) 首先我们要把所有操作分成两坨，一坨修改操作，一坨询问操作。 并且我们需要预处理出进行每一个修改操作之前这个要修改的位置上的颜色。 还要预处理出进行每一个询问操作时已近完成了几个修改操作。 然后在莫队的时候，如果当前已经进行了的修改操作的个数与当前询问操作所记录的已经进行了的修改操作数不一致，暴力更新一下就行了呢poi！ 据说这样带修改的莫队只要把块的大小设置为$n^\frac{2}{3}$就能将时间内复杂度控制在可接受的范围内呢poi。 其他的按照普通莫队写就行啦poi！ 还有洛谷上这题数据比较强，如果不按玄学方法排序要吸个氧才能AC(也有可能是蒟蒻我的常数太大了QwQ)。 代码其实还挺好写的呢poi 还有不要问我为什么那么喜欢poi呢poi 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;const int maxn=50005;int n,m,m1,m2,S,A[maxn],B[maxn],Area[maxn],ans[maxn],L,R,now,ncnt,hsh[1000005];inline int read()&#123; int ret=0,f=1;char ch=getchar(); while(ch&lt;'0'||ch&gt;'9')&#123;if(ch=='-')f=-f;ch=getchar();&#125; while(ch&gt;='0'&amp;&amp;ch&lt;='9')&#123;ret=ret*10+ch-'0';ch=getchar();&#125; return ret*f;&#125;char GetChar()&#123; char ch=getchar(); while(ch!='Q'&amp;&amp;ch!='R') ch=getchar(); return ch;&#125;struct Query&#123; int L,R,id,cnt; bool operator &lt; (const Query&amp; b)const&#123;return Area[L]&lt;Area[b.L]||(Area[L]==Area[b.L]&amp;&amp;((Area[L]&amp;1)?R&gt;b.R:R&lt;b.R));&#125;&#125;Q[maxn];struct Update&#123;int P,C,lst;&#125;U[maxn];inline void inc(int num)&#123;if(!hsh[num]++) now++;&#125;inline void dec(int num)&#123;if(!--hsh[num]) now--;&#125;int main()&#123; n=read();m=read();S=pow(n,0.666666)+1e-10; for(int i=1;i&lt;=n;i++) Area[i]=(i-1)/S+1; for(int i=1;i&lt;=n;i++) A[i]=B[i]=read(); for(int i=1;i&lt;=m;i++) &#123; if(GetChar()=='Q')&#123;Q[++m1].L=read();Q[m1].R=read();Q[m1].id=m1;Q[m1].cnt=m2;&#125; else&#123;U[++m2].P=read();U[m2].C=read();U[m2].lst=B[U[m2].P];B[U[m2].P]=U[m2].C;&#125; &#125; sort(Q+1,Q+1+m1); L=1;R=1;hsh[A[1]]++;now=1; for(int i=1;i&lt;=m1;i++) &#123; while(R&lt;Q[i].R) inc(A[++R]); while(L&gt;Q[i].L) inc(A[--L]); while(R&gt;Q[i].R) dec(A[R--]); while(L&lt;Q[i].L) dec(A[L++]); while(ncnt&gt;Q[i].cnt) &#123; A[U[ncnt].P]=U[ncnt].lst; if(L&lt;=U[ncnt].P&amp;&amp;U[ncnt].P&lt;=R)&#123;dec(U[ncnt].C);inc(U[ncnt].lst);&#125; ncnt--; &#125; while(ncnt&lt;Q[i].cnt) &#123; ncnt++; A[U[ncnt].P]=U[ncnt].C; if(L&lt;=U[ncnt].P&amp;&amp;U[ncnt].P&lt;=R)&#123;inc(U[ncnt].C);dec(U[ncnt].lst);&#125; &#125; ans[Q[i].id]=now; &#125; for(int i=1;i&lt;=m1;i++) printf("%d\n",ans[i]); return 0;&#125;]]></content>
      <categories>
        <category>莫队</category>
      </categories>
      <tags>
        <tag>分块</tag>
        <tag>莫队</tag>
        <tag>带修改莫队</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「ZJOI2013」K大数查询|整体二分]]></title>
    <url>%2F2018%2F12%2F26%2F%E3%80%8CZJOI2013%E3%80%8DK%E5%A4%A7%E6%95%B0%E6%9F%A5%E8%AF%A2%20%E6%95%B4%E4%BD%93%E4%BA%8C%E5%88%86%2F</url>
    <content type="text"><![CDATA[什么？树套树？不存在的。 传送门洛谷传送门 BZOJ传送门 在您开始阅读本题解之前，蒟蒻我建议您先把题面多看几遍，并仔细阅读样例和样例说明。 我才不会告诉你蒟蒻我就是因为看错题面然后白忙活了一个小时。 题解据说本题可以用树套树解，但是树套树这种东西常数稍微一大就TLE，这位dalao的树套树就咕掉了。而且树套树对于蒟蒻我来说太*难了，所以我们需要整体二分这种东西。 首先确保您已经掌握普通二分的写法，不会普通二分的请自行Ctrl+w。 整体二分的主要思想就是把这一大坨询问一起处理。 首先让我们来考虑只有一个询问操作的情况： 二分权值(即答案)，每次分到一个$mid$，我们就把这个询问之前所有的有贡献的添加操作(即$c$值大于$mid$的添加操作)用一个支持区间修改的树状数组或者线段树预处理，然后我们就可以很快地得到区间$[a,b]$中权值大于$mid$的数的个数$tot$。如果$tot$小于这个询问操作的$c$值，那么我们就把$c$值减去$tot$，然后把之前产生过贡献的添加操作扔掉删除，并修改二分的边界值继续二分；否则直接修改二分的边界值继续二分即可。 好了现在再来考虑有一坨询问的情况。 方便起见，我们把询问操作和添加操作一起处理。设当前二分的值是$mid$，二分的权值区间是$[L,R]$要处理的操作区间是$[s,t]$。那我们先遍历一遍操作区间，如果当前遍历到的是有贡献的添加操作，就更新一下线段树；若果是询问操作，就在线段树上查询一下该询问区间内权值大于$mid$的个数$tot$，根据$tot$是否大于$c$并把操作分成两堆，然后递归分别处理两堆，直到$L=R$时$mid$就是当前所有询问操作的答案。(添加操作也要根据$c$值是否大于$mid$也一起分成两堆) 注意将操作分堆时每一堆内不要打乱操作的顺序。 时间复杂度$\Theta(n\log^2{n})$，常数是真的小QwQ。 代码貌似真的比树套树好懂 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697#include&lt;cstdio&gt;using namespace std;typedef long long LL;const int maxn=50005;int n,m,cnt,ans[maxn];inline LL read()&#123; LL ret=0,f=1;char ch=getchar(); while(ch&lt;'0'||ch&gt;'9')&#123;if(ch=='-')f=-f;ch=getchar();&#125; while(ch&gt;='0'&amp;&amp;ch&lt;='9')&#123;ret=ret*10+ch-'0';ch=getchar();&#125; return ret*f;&#125;struct Command&#123; int typ,L,R,id;LL C;&#125;Q[maxn],Q1[maxn],Q2[maxn];struct SegmentTree //一个普普通通的线段树&#123;private: struct Node&#123;LL Sum,Tag;&#125;Tree[maxn*4]; void PushUp(int rt)&#123;Tree[rt].Sum=Tree[rt*2].Sum+Tree[rt*2+1].Sum;&#125; void PushDown(int rt,int LC,int RC) &#123; Tree[rt*2].Tag+=Tree[rt].Tag;Tree[rt*2+1].Tag+=Tree[rt].Tag; Tree[rt*2].Sum+=LC*Tree[rt].Tag;Tree[rt*2+1].Sum+=RC*Tree[rt].Tag; Tree[rt].Tag=0; &#125;public: void RangeUpdate(int LL,int RR,int delta,int L=1,int R=n,int rt=1) &#123; if(LL&lt;=L&amp;&amp;R&lt;=RR)&#123;Tree[rt].Sum+=(R-L+1)*delta;Tree[rt].Tag+=delta;return;&#125; int M=L+R&gt;&gt;1; PushDown(rt,M-L+1,R-M); if(LL&lt;=M) RangeUpdate(LL,RR,delta,L,M,rt*2); if(M&lt;RR) RangeUpdate(LL,RR,delta,M+1,R,rt*2+1); PushUp(rt); &#125; LL RangeQuery(int LL,int RR,int L=1,int R=n,int rt=1) &#123; if(LL&lt;=L&amp;&amp;R&lt;=RR) return Tree[rt].Sum; int M=L+R&gt;&gt;1;::LL ret=0; PushDown(rt,M-L+1,R-M); if(LL&lt;=M) ret+=RangeQuery(LL,RR,L,M,rt*2); if(M&lt;RR) ret+=RangeQuery(LL,RR,M+1,R,rt*2+1); return ret; &#125;&#125;S;void BinarySearch(int L,int R,int s,int t) //整体二分&#123; if(L&gt;R||s&gt;t) return; int mid=L+R&gt;&gt;1,len1=0,len2=0; if(L==R) &#123; for(int i=s;i&lt;=t;i++) if(Q[i].typ==2) //只有询问操作才需要回答 ans[Q[i].id]=mid; return; &#125; for(int i=s;i&lt;=t;i++) &#123; if(Q[i].typ==1) &#123; if(Q[i].C&gt;mid) &#123; S.RangeUpdate(Q[i].L,Q[i].R,1); Q1[++len1]=Q[i]; //操作分堆 &#125; else Q2[++len2]=Q[i]; &#125; else &#123; LL tot=S.RangeQuery(Q[i].L,Q[i].R); if(Q[i].C&lt;=tot) Q1[++len1]=Q[i]; //操作分堆 else&#123;Q2[++len2]=Q[i];Q2[len2].C-=tot;&#125; &#125; &#125; for(int i=s;i&lt;=t;i++) //撤销操作，清空线段树 if(Q[i].typ==1&amp;&amp;Q[i].C&gt;mid) S.RangeUpdate(Q[i].L,Q[i].R,-1); int j=s; for(int i=1;i&lt;=len1;i++,j++) Q[j]=Q1[i]; for(int i=1;i&lt;=len2;i++,j++) Q[j]=Q2[i]; BinarySearch(L,mid,s+len1,t);BinarySearch(mid+1,R,s,s+len1-1);&#125;int main()&#123; n=read();m=read(); for(int i=1;i&lt;=m;i++) &#123; Q[i].typ=read(); if(Q[i].typ==2) Q[i].id=++cnt; Q[i].L=read();Q[i].R=read();Q[i].C=read(); &#125; BinarySearch(-n,n,1,m); for(int i=1;i&lt;=cnt;i++) printf("%d\n",ans[i]); return 0;&#125;]]></content>
      <categories>
        <category>整体二分</category>
      </categories>
      <tags>
        <tag>整体二分</tag>
        <tag>树套树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「HNOI2010」弹飞绵羊]]></title>
    <url>%2F2018%2F12%2F24%2F%E3%80%8CHNOI2010%E3%80%8D%E5%BC%B9%E9%A3%9E%E7%BB%B5%E7%BE%8A-Solution%2F</url>
    <content type="text"><![CDATA[什么？LCT？不存在的。蒟蒻我怎么可能会LCT。 传送门洛谷传送门(咕咕咕) 爆炸BZOJ传送门 题解听说这题的标算是LCT？我这么菜！怎么可能会LCT！！！看了一眼数据范围，很亲切啊！二话不说直接上分块！ 首先，按照分块的套路，把$n$个弹力装置分成若干个块(块的大小取$\sqrt{n}$即可)。然后需要提前构造好两个数组： 1：$step[]$。$step[i]$表示落到第i个弹力装置上的绵羊还需几次才能跳到下一个块里（或者被弹飞）。 2：$pos[]$。$pos[i]$表示落到第i个弹力装置上的绵羊在被弹出当前块后会被弹到哪一个位置上。 这两个数组可以一开始从后往前在$\Theta(n*\sqrt{n})$的时间复杂度内构造出来。(我才不会告诉你我写这个是为了测试markdown的数学公式)询问的时候借助这两个数组就可以在$\Theta(\sqrt{n})$的时间复杂度内通过模拟计算出答案。 然后让我们再来考虑修改的问题。 自己思考一下，不难发现，修改了一个弹力系数之后，只有该块内的两个数组的值可能发生改变，然后从后往前暴力更新一下即可。 代码比LCT短了不少 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include&lt;cmath&gt;#include&lt;cstdio&gt;using namespace std;const int maxn=200005;int n,m,S,Area[maxn],K[maxn],step[maxn],pos[maxn];inline int read()&#123; int ret=0,f=1;char ch=getchar(); while(ch&lt;'0'||ch&gt;'9')&#123;if(ch=='-')f=-f;ch=getchar();&#125; while(ch&gt;='0'&amp;&amp;ch&lt;='9')&#123;ret=ret*10+ch-'0';ch=getchar();&#125; return ret*f;&#125;inline void Solve(int s)&#123; int p=s+K[s],ret=1; while(Area[p]==Area[s])&#123;p=p+K[p];ret++;&#125; step[s]=ret;pos[s]=p;&#125;inline void Update(int s)&#123; int p=s+K[s],ret=1; while(Area[p]==Area[s])&#123;p=p+K[p];ret++;&#125; step[s]=ret;pos[s]=p; for(int i=s-1;Area[i]==Area[s];i--) if(Area[i+K[i]]==Area[i]) &#123;step[i]=step[i+K[i]]+1;pos[i]=pos[i+K[i]];&#125;&#125;inline void Query(int s)&#123; int p=s,ret=0; while(p&lt;=n)&#123;ret+=step[p];p=pos[p];&#125; printf("%d\n",ret);&#125;int main()&#123; n=read();S=sqrt(n)+1e-10; for(int i=1;i&lt;=n;i++) Area[i]=(i-1)/S+1; for(int i=1;i&lt;=n;i++) K[i]=read(); for(int i=n;i&gt;=1;i--) Solve(i); m=read(); while(m--) &#123; int a=read(),b=read()+1; if(a==1) Query(b); else&#123;int c=read();K[b]=c;Update(b);&#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>分块</category>
      </categories>
      <tags>
        <tag>分块</tag>
        <tag>LCT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[公告]]></title>
    <url>%2F2018%2F12%2F22%2F%E5%85%AC%E5%91%8A%2F</url>
    <content type="text"><![CDATA[什么？女装发blog？不存在的… 欢迎访问蒟蒻我的blog. 蒟蒻我万年不更新的Blog终于在网站开通后n个星期准备开始更新了。。。 蒟蒻我和巨佬XXC女装的事，想必各位dalao都知道了。 关于女装，可说来话长了。是这么一回事： NOIP2018 day2考完出场，ZJ初三小蒟蒻我感觉两腿绵软无力，很显然我这只蒟蒻是考boom了。day2 T1我傻逼样得想用一种奇妙的方法来解决这棵基环外向树，然后写了两个小时还没有结果，CCF给的大样例也过不了。出了考场和各位大佬一起交流了一下才发现暴力枚举删掉的边然后重构图即可。因为T1没做出来，T2的45分结论分也没拿到。自己估摸了一下，不该丢的分一共丢了85分，预估不翻车的情况下分数为应该379，省一GG… 事后，蒟蒻我写了一首诗来表达自己内心的想法(我有一句mmp不知当不当讲)： 于是乎，我便当众立了一个flag：我CCF评出来400分以上就那啥！ 然鹅等到CCF出成绩的那天，由于CCF的数据非常友好，我总分399(CCF万岁) 但是成绩出来之后，跟各位dalao一讨论，参考了一下CCF的文件，发现蒟蒻我省一仍然没有太大希望qwq。 于是乎，我又当众立了一个flag：我省一就那啥！ 12.04，CCF发布获奖名单，我惊奇地发现CCF修改了省一获奖名额的分配方案。CCF万岁万岁万万岁。蒟蒻我先是高兴了一会儿，然后想起了之前立的flag… 我&amp;^%￥#T@(文明你我他) 然后就没有然后了… 为了不让Matsusaki这位dalao破费，我决定等XXC巨佬女装后把衣服借来用用。 听说我已近被安排上了？好像就在81022018年12月30/31号？ XXC巨佬的blog(据说这里会放上他她的女装图)]]></content>
      <categories>
        <category>公告</category>
      </categories>
      <tags>
        <tag>女装</tag>
        <tag>公告</tag>
      </tags>
  </entry>
</search>
