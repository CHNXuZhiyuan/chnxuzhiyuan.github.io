<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[「ZJOI2008」骑士]]></title>
    <url>%2F2019%2F04%2F22%2F%E3%80%8CZJOI2008%E3%80%8D%E9%AA%91%E5%A3%AB-Solution%2F</url>
    <content type="text"><![CDATA[好一个树形DP。 传送门洛谷P2607 BZOJ1040 题解他出题人要是敢去掉一条边，我就敢做！！！ 首先对于每一个骑士，向他最痛恨的人建一条边。 如果只有$n-1$条边的话，就是一个裸的带权的树上最大独立集。 但是由于要$n$条边，所以最后建出来的应该是一个基环内向树森林。 比如这样： 对于在环上的每一个点，可以直接DP出该点选与不选时它与它的子树的最大权值和。 对于环，我们可以再来一趟DP，定义$G[i][0/1/2/3]$： $G[i][0]$环上第一个点可以选，第$i$个点选时的最大权值和。 $G[i][1]$环上第一个点可以选，第$i$个点不选时的最大权值和。 $G[i][2]$环上第一个点不可以选，第$i$个点选时的最大权值和。 $G[i][3]$环上第一个点不可以选，第$i$个点不选时的最大权值和。 最后的答案为$max(G[n][0],G[n][2],G[n][3])​$。 对于每一个环，分别DP，然后把答案加在一起即可。 复杂度：$\Theta(n)$。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384#include&lt;cstdio&gt;#include&lt;vector&gt;using namespace std;typedef long long LL;const int maxn=1000005;int n,A[maxn],fa[maxn],in[maxn],len,C[maxn];vector &lt;int&gt; so[maxn];LL ans,G[maxn][4],F[maxn][2];inline int read()&#123; int ret=0,f=1;char ch=getchar(); while(ch&lt;'0'||ch&gt;'9')&#123;if(ch=='-')f=-f;ch=getchar();&#125; while(ch&gt;='0'&amp;&amp;ch&lt;='9')&#123;ret=ret*10+ch-'0';ch=getchar();&#125; return ret*f;&#125;inline void Toposort() //拓扑排序找环+建图&#123; static int que[maxn],hed,til; for(int i=1;i&lt;=n;i++) if(in[i]==0) que[++til]=i; while(hed!=til) &#123; hed++; in[fa[que[hed]]]--; so[fa[que[hed]]].push_back(que[hed]); if(!in[fa[que[hed]]]) que[++til]=fa[que[hed]]; &#125;&#125;void DFS(int now,int fa)&#123; F[now][1]=A[now]; for(int i=0;i&lt;(int)so[now].size();i++) &#123; DFS(so[now][i],now); F[now][1]+=F[so[now][i]][0]; F[now][0]+=max(F[so[now][i]][0],F[so[now][i]][1]); &#125;&#125;void GetCircle(int now)&#123; if(in[fa[now]]==0) return; C[++len]=now; in[fa[now]]--; GetCircle(fa[now]);&#125;void Solve() //对于每个环分别DP&#123; G[1][0]=F[C[1]][0]; G[1][1]=F[C[1]][1]; G[1][2]=F[C[1]][0]; G[1][3]=0; for(int i=2;i&lt;=len;i++) &#123; G[i][0]=G[i][2]=F[C[i]][0]; G[i][1]=G[i][3]=F[C[i]][1]; G[i][0]+=max(G[i-1][0],G[i-1][1]); G[i][1]+=G[i-1][0]; G[i][2]+=max(G[i-1][2],G[i-1][3]); G[i][3]+=G[i-1][2]; &#125; ans+=max(G[len][0],max(G[len][2],G[len][3]));&#125;int main()&#123; n=read(); for(int i=1;i&lt;=n;i++) &#123; A[i]=read(); fa[i]=read(); in[fa[i]]++; &#125; Toposort(); for(int i=1;i&lt;=n;i++) if(in[i]&gt;0) DFS(i,0); for(int i=1;i&lt;=n;i++) &#123; if(in[i]&gt;0) &#123; len=0; GetCircle(i); Solve(); &#125; &#125; printf("%lld\n",ans); return 0;&#125;]]></content>
      <categories>
        <category>树形DP</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>树形DP</tag>
        <tag>基环树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「BZOJ3155|洛谷P4868」Preprefix sum]]></title>
    <url>%2F2019%2F04%2F22%2F%E3%80%8CBZOJ3155%20%E6%B4%9B%E8%B0%B7P4868%E3%80%8DPreprefix-sum%20-Solution%2F</url>
    <content type="text"><![CDATA[线段树大水题？？？ 传送门洛谷P4868 BZOJ3155 题解不难发现，如果$A_i$的值增加了$\Delta$，那么$S_i$~$S_n$都增加了$\Delta$。 又$SSi=\sum{i=1}^{i}{S_i}$。 所以直接弄个线段树维护一下就好了。 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#include&lt;cstdio&gt;#include&lt;cstring&gt;using namespace std;typedef long long LL;const int maxn=100005;int n,m,A[maxn];LL S[maxn];char cmd[16];inline int read()&#123; int ret=0,f=1;char ch=getchar(); while(ch&lt;'0'||ch&gt;'9')&#123;if(ch=='-')f=-f;ch=getchar();&#125; while(ch&gt;='0'&amp;&amp;ch&lt;='9')&#123;ret=ret*10+ch-'0';ch=getchar();&#125; return ret*f;&#125;struct SegmentTree&#123; struct Node&#123;LL Sum,Tag;&#125;Tree[maxn*4]; inline void PushUp(int rt)&#123;Tree[rt].Sum=Tree[rt*2].Sum+Tree[rt*2+1].Sum;&#125; inline void PushDown(int rt,int LC,int RC) &#123; if(!Tree[rt].Tag) return; Tree[rt*2].Tag+=Tree[rt].Tag;Tree[rt*2+1].Tag+=Tree[rt].Tag; Tree[rt*2].Sum+=Tree[rt].Tag*LC;Tree[rt*2+1].Sum+=Tree[rt].Tag*RC; Tree[rt].Tag=0; &#125; inline void Build(int L=1,int R=n,int rt=1) &#123; if(L==R)&#123;Tree[rt].Sum=S[L];return;&#125; int M=(L+R)&gt;&gt;1; Build(L,M,rt*2); Build(M+1,R,rt*2+1); PushUp(rt); &#125; inline void RangeUpdate(int LL,int RR,int delta,int L=1,int R=n,int rt=1) &#123; if(LL&lt;=L&amp;&amp;R&lt;=RR)&#123;Tree[rt].Sum+=(::LL)delta*(R-L+1);Tree[rt].Tag+=delta;return;&#125; int M=(L+R)&gt;&gt;1; PushDown(rt,M-L+1,R-M); if(LL&lt;=M) RangeUpdate(LL,RR,delta,L,M,rt*2); if(M&lt;RR) RangeUpdate(LL,RR,delta,M+1,R,rt*2+1); PushUp(rt); &#125; inline LL RangeQuery(int LL,int RR,int L=1,int R=n,int rt=1) &#123; if(LL&lt;=L&amp;&amp;R&lt;=RR) return Tree[rt].Sum; int M=(L+R)&gt;&gt;1;::LL ret=0; PushDown(rt,M-L+1,R-M); if(LL&lt;=M) ret+=RangeQuery(LL,RR,L,M,rt*2); if(M&lt;RR) ret+=RangeQuery(LL,RR,M+1,R,rt*2+1); return ret; &#125;&#125;ST;int main()&#123; n=read();m=read(); for(int i=1;i&lt;=n;i++) A[i]=read(); for(int i=1;i&lt;=n;i++) S[i]=S[i-1]+A[i]; ST.Build(); while(m--) &#123; scanf("%s",cmd); if(strcmp(cmd,"Query")==0) &#123; int x=read(); printf("%lld\n",ST.RangeQuery(1,x)); &#125; else &#123; int x=read(),a=read(); ST.RangeUpdate(x,n,a-A[x]); A[x]=a; &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>线段树</category>
      </categories>
      <tags>
        <tag>线段树</tag>
        <tag>前缀和</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「CQOI2016」手机号码]]></title>
    <url>%2F2019%2F04%2F22%2F%E3%80%8CCQOI2016%E3%80%8D%E6%89%8B%E6%9C%BA%E5%8F%B7%E7%A0%81-Solution%2F</url>
    <content type="text"><![CDATA[蒟蒻我得好好学学数位DP。 传送门洛谷P4124 BZOJ4521 题解这题定义出来的数组有点长QwQ。 定义$F[pos][pre][pree][thr][fur][eig]$表示长度为$pos$，上一个数字为$pre$，上上个数字为$pree$，是/否出现过连续三个相同数字，是/否出现过4，是/否出现8，时的合法方案数。 然后写个记忆化DFS就好了。 代码12345678910111213141516171819202122232425262728293031#include&lt;cstdio&gt;#include&lt;cstring&gt;using namespace std;typedef long long LL;int A[15],len;LL L,R,F[15][11][11][2][2][2][2];LL DFS(int pos,int pre,int pree,bool thr,bool fur,bool eig,bool lim)&#123; if(fur&amp;&amp;eig) return 0; if(pos==0) return thr; LL&amp; ret=F[pos][pre][pree][thr][fur][eig][lim]; if(ret!=-1) return ret; ret=0; int end=lim?A[pos]:9; for(int i=(pos==11?1:0);i&lt;=end;i++) ret+=DFS(pos-1,i,pre,thr||(i==pre&amp;&amp;pre==pree),fur||i==4,eig||i==8,lim&amp;&amp;i==end); return ret;&#125;LL Solve(LL n)&#123; if(n&lt;10000000000ll) return 0; len=0; while(n)&#123;A[++len]=n%10;n/=10;&#125; memset(F,-1,sizeof(F)); return DFS(11,10,10,0,0,0,1);&#125;int main()&#123; scanf("%lld%lld",&amp;L,&amp;R); printf("%lld\n",Solve(R)-Solve(L-1)); return 0;&#125;]]></content>
      <categories>
        <category>数位DP</category>
      </categories>
      <tags>
        <tag>数位DP</tag>
        <tag>记忆化搜索</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「HNOI2012」永无乡]]></title>
    <url>%2F2019%2F04%2F07%2F%E3%80%8CHNOI2012%E3%80%8D%E6%B0%B8%E6%97%A0%E4%B9%A1-Solution%2F</url>
    <content type="text"><![CDATA[平衡树真是神奇。 传送门洛谷P3224 BZOJ2733 题解对于每一个联通块，都可以用一棵Splay来维护。 对于合并操作，可以采用启发式合并的方法，将小Splay接到大的Splay上去，然后把小的Splay的每一个节点都旋转到根节点（其实就是相当于把小的Splay拆了之后一个个加入到大的Splay里）。 对于一个节点，由于每次都是由小树往大树里加，所以进行一次合并之后，树的大小至少变到原来小树的两倍。所以每一个节点最多被合并$\log n​$次。 所以时间复杂度为$\Theta(n\log^2n)$。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;const int maxn=100005;int n,m,q;inline int read()&#123; int ret=0,f=1;char ch=getchar(); while(ch&lt;'0'||ch&gt;'9')&#123;if(ch=='-')f=-f;ch=getchar();&#125; while(ch&gt;='0'&amp;&amp;ch&lt;='9')&#123;ret=ret*10+ch-'0';ch=getchar();&#125; return ret*f;&#125;inline char GetCmd()&#123; char ch=getchar(); while(ch!='B'&amp;&amp;ch!='Q') ch=getchar(); return ch;&#125;struct SplayTree&#123; int fa[maxn],cnt[maxn],que[maxn]; inline int getfa(int x)&#123;return fa[x]==x?x:fa[x]=getfa(fa[x]);&#125; struct Node&#123;int siz,val,fa,son[2];&#125;Tree[maxn]; inline void PushUp(int rt)&#123;Tree[rt].siz=Tree[Tree[rt].son[0]].siz+Tree[Tree[rt].son[1]].siz+1;&#125; inline int check(int x)&#123;return Tree[Tree[x].fa].son[1]==x?1:0;&#125; inline void Rotate(int x) &#123; int y=Tree[x].fa,z=Tree[y].fa,k=check(x),w=Tree[x].son[k^1]; Tree[w].fa=y; Tree[y].son[k]=w; Tree[x].fa=z; Tree[z].son[check(y)]=x; Tree[y].fa=x; Tree[x].son[k^1]=y; PushUp(y); PushUp(x); &#125; inline void Splay(int x) &#123; while(Tree[x].fa) &#123; int y=Tree[x].fa; if(Tree[y].fa) &#123; if(check(x)==check(y)) Rotate(y); else Rotate(x); &#125; Rotate(x); &#125; &#125; inline void Link(int a,int b) &#123; if(getfa(a)==getfa(b)) return; if(cnt[getfa(a)]&lt;cnt[getfa(b)]) swap(a,b); cnt[getfa(a)]+=cnt[getfa(b)];cnt[getfa(b)]=0; fa[fa[b]]=fa[a]; Splay(b);Splay(a); int p=a,fa=0; while(p) &#123; fa=p; p=Tree[p].son[Tree[b].val&gt;Tree[p].val]; &#125; Tree[fa].son[Tree[b].val&gt;Tree[fa].val]=b; Tree[b].fa=fa; int hed=0,til=1; que[1]=b; while(hed!=til) &#123; hed++; if(Tree[que[hed]].son[0]) que[++til]=Tree[que[hed]].son[0]; if(Tree[que[hed]].son[1]) que[++til]=Tree[que[hed]].son[1]; &#125; for(int i=1;i&lt;=til;i++) Splay(que[i]); &#125; inline int Kth(int x,int k) &#123; Splay(x); int p=x; while(p) &#123; if(Tree[Tree[p].son[0]].siz+1==k) return p; if(Tree[Tree[p].son[0]].siz+1&gt;k) p=Tree[p].son[0]; else&#123;k-=Tree[Tree[p].son[0]].siz+1;p=Tree[p].son[1];&#125; &#125; return -1; &#125;&#125;ST;int main()&#123; n=read();m=read(); for(int i=1;i&lt;=n;i++) &#123; ST.fa[i]=i;ST.cnt[i]=1; ST.Tree[i].siz=1; ST.Tree[i].val=read(); &#125; for(int i=1;i&lt;=m;i++) &#123; int a=read(),b=read(); ST.Link(a,b); &#125; q=read(); while(q--) &#123; if(GetCmd()=='B') &#123; int a=read(),b=read(); ST.Link(a,b); &#125; else &#123; int x=read(),k=read(); printf("%d\n",ST.Kth(x,k)); &#125; &#125; return 0;&#125;]]></content>
      <tags>
        <tag>平衡树</tag>
        <tag>SplayTree</tag>
        <tag>启发式合并</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「SDOI2011」染色]]></title>
    <url>%2F2019%2F04%2F07%2F%E3%80%8CSDOI2011%E3%80%8D%E6%9F%93%E8%89%B2-Solution%2F</url>
    <content type="text"><![CDATA[再来水一发树剖QwQ。 传送门洛谷P2486 BZOJ2243 题解首先这题上来先树剖。 然后考虑线段树怎么写。 对于每一个节点，需要记录它所控制的区间中颜色的段数、开头的颜色和结尾的颜色。 合并两个区间的时候，需要判断前面区间结尾颜色是否等于后面区间的开头颜色，如果相同区间颜色段数要减一。 其他按照树剖的套路写就行了。 然后就没了QwQ… 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;const int maxn=100005;int n,m,tot,lnk[maxn],son[maxn*2],C[maxn],nxt[maxn*2],idx,siz[maxn],wson[maxn],fa[maxn],top[maxn],seg[maxn],dep[maxn],rev[maxn],ans;inline int read()&#123; int ret=0,f=1;char ch=getchar(); while(ch&lt;'0'||ch&gt;'9')&#123;if(ch=='-')f=-f;ch=getchar();&#125; while(ch&gt;='0'&amp;&amp;ch&lt;='9')&#123;ret=ret*10+ch-'0';ch=getchar();&#125; return ret*f;&#125;inline char GetCmd()&#123; char ch=getchar(); while(ch!='Q'&amp;&amp;ch!='C') ch=getchar(); return ch;&#125;struct SegmentTree&#123; struct Node&#123;int FC,BC,Sum,Tag;&#125;Tree[maxn*4]; void PushUp(int rt) &#123; Tree[rt].Sum=Tree[rt*2].Sum+Tree[rt*2+1].Sum-(int)(Tree[rt*2].BC==Tree[rt*2+1].FC); Tree[rt].FC=Tree[rt*2].FC; Tree[rt].BC=Tree[rt*2+1].BC; &#125; void PushDown(int rt) &#123; if(Tree[rt].Tag==0) return; Tree[rt*2].Sum=1; Tree[rt*2+1].Sum=1; Tree[rt*2].FC=Tree[rt*2].BC=Tree[rt*2+1].FC=Tree[rt*2+1].BC=Tree[rt].Tag; Tree[rt*2].Tag=Tree[rt].Tag; Tree[rt*2+1].Tag=Tree[rt].Tag; Tree[rt].Tag=0; &#125; void Build(int L=1,int R=n,int rt=1) &#123; if(L==R) &#123; Tree[rt].Sum=1; Tree[rt].FC=Tree[rt].BC=C[rev[L]]; return; &#125; int M=(L+R)&gt;&gt;1; Build(L,M,rt*2); Build(M+1,R,rt*2+1); PushUp(rt); &#125; void RangeUpdate(int LL,int RR,int co,int L=1,int R=n,int rt=1) &#123; if(LL&lt;=L&amp;&amp;R&lt;=RR) &#123; Tree[rt].Sum=1; Tree[rt].Tag=co; Tree[rt].FC=Tree[rt].BC=co; return; &#125; int M=(L+R)/2; PushDown(rt); if(LL&lt;=M) RangeUpdate(LL,RR,co,L,M,rt*2); if(M&lt;RR) RangeUpdate(LL,RR,co,M+1,R,rt*2+1); PushUp(rt); &#125; Node RangeQuery(int LL,int RR,int L=1,int R=n,int rt=1) &#123; if(LL&lt;=L&amp;&amp;R&lt;=RR) return Tree[rt]; int M=(L+R)&gt;&gt;1;Node IL,IR,ret; PushDown(rt); if(LL&lt;=M) IL=RangeQuery(LL,RR,L,M,rt*2); if(M&lt;RR) IR=RangeQuery(LL,RR,M+1,R,rt*2+1); if(LL&lt;=M&amp;&amp;M&gt;=RR) return IL; if(LL&gt;M&amp;&amp;M&lt;RR) return IR; ret.Sum=IL.Sum+IR.Sum-(int)(IL.BC==IR.FC); ret.FC=IL.FC;ret.BC=IR.BC; return ret; &#125;&#125;T;inline void add_e(int x,int y)&#123;tot++;son[tot]=y;nxt[tot]=lnk[x];lnk[x]=tot;&#125;void DFS1(int now)&#123; siz[now]=1;dep[now]=dep[fa[now]]+1; for(int i=lnk[now];i;i=nxt[i]) &#123; if(son[i]==fa[now]) continue; fa[son[i]]=now; DFS1(son[i]); siz[now]+=siz[son[i]]; &#125; for(int i=lnk[now];i;i=nxt[i]) if(son[i]!=fa[now]&amp;&amp;siz[son[i]]&gt;siz[wson[now]]) wson[now]=son[i];&#125;void DFS2(int now)&#123; seg[now]=++idx;rev[seg[now]]=now; if(now==1) top[now]=1; if(wson[now]) &#123; top[wson[now]]=top[now]; DFS2(wson[now]); &#125; for(int i=lnk[now];i;i=nxt[i]) &#123; if(son[i]==fa[now]||son[i]==wson[now]) continue; top[son[i]]=son[i]; DFS2(son[i]); &#125;&#125;inline void PathUpdate(int u,int v,int nc)&#123; while(top[u]!=top[v]) &#123; if(dep[top[u]]&lt;dep[top[v]]) swap(u,v); T.RangeUpdate(seg[top[u]],seg[u],nc); u=fa[top[u]]; &#125; if(dep[u]&lt;dep[v]) swap(u,v); T.RangeUpdate(seg[v],seg[u],nc);&#125;inline void PathQuery(int u,int v)&#123; ans=0; while(top[u]!=top[v]) &#123; if(dep[top[u]]&lt;dep[top[v]]) swap(u,v); ans+=T.RangeQuery(seg[top[u]],seg[u]).Sum; if(T.RangeQuery(seg[top[u]],seg[top[u]]).BC==T.RangeQuery(seg[fa[top[u]]],seg[fa[top[u]]]).BC) ans--; u=fa[top[u]]; &#125; if(dep[u]&lt;dep[v]) swap(u,v); ans+=T.RangeQuery(seg[v],seg[u]).Sum; printf("%d\n",ans);&#125;int main()&#123; n=read();m=read(); for(int i=1;i&lt;=n;i++) C[i]=read(); for(int i=1;i&lt;n;i++) &#123; int a=read(),b=read(); add_e(a,b);add_e(b,a); &#125; DFS1(1);DFS2(1);T.Build(); while(m--) &#123; if(GetCmd()=='C') &#123; int a=read(),b=read(),c=read(); PathUpdate(a,b,c); &#125; else &#123; int a=read(),b=read(); PathQuery(a,b); &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>树链剖分</category>
      </categories>
      <tags>
        <tag>线段树</tag>
        <tag>树链剖分</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「HNOI2004」宠物收养场]]></title>
    <url>%2F2019%2F04%2F07%2F%E3%80%8CHNOI2004%E3%80%8D%E5%AE%A0%E7%89%A9%E6%94%B6%E5%85%BB%E5%9C%BA-Solution%2F</url>
    <content type="text"><![CDATA[set真香。 传送门洛谷P2286 BZOJ1208 题解只要记一下当前是人多还是宠物多，然后弄个平衡树维护一下。 每次找个前驱和后继，挑个接近的来。 也可以用STL里的set来维护。 然后注意一下细节就行了。 记得答案要取模。 代码set真香 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include&lt;set&gt;#include&lt;cstdio&gt;using namespace std;int n,peo,pet,ans;set&lt;int&gt; S;set&lt;int&gt;::iterator p1,p2;inline int read()&#123; int ret=0,f=1;char ch=getchar(); while(ch&lt;'0'||ch&gt;'9')&#123;if(ch=='-')f=-f;ch=getchar();&#125; while(ch&gt;='0'&amp;&amp;ch&lt;='9')&#123;ret=ret*10+ch-'0';ch=getchar();&#125; return ret*f;&#125;inline int ABS(int x)&#123;return x&lt;0?-x:x;&#125;int main()&#123; n=read(); for(int i=1;i&lt;=n;i++) &#123; int opt=read(),a=read(); if(opt==0) &#123; if(peo==0)&#123;S.insert(a);pet++;&#125; else &#123; p1=p2=S.lower_bound(a);p2--; if(p1!=S.begin()&amp;&amp;(p1==S.end()||ABS(*p1-a)&gt;=ABS(*p2-a))) p1--; ans+=ABS(*p1-a); S.erase(p1);peo--; &#125; &#125; else &#123; if(pet==0)&#123;S.insert(a);peo++;&#125; else &#123; p1=p2=S.lower_bound(a);p2--; if(p1!=S.begin()&amp;&amp;(p1==S.end()||ABS(*p1-a)&gt;=ABS(*p2-a))) p1--; ans+=ABS(*p1-a); S.erase(p1);pet--; &#125; &#125; ans%=1000000; &#125; printf("%d\n",ans); return 0;&#125;]]></content>
      <categories>
        <category>平衡树</category>
      </categories>
      <tags>
        <tag>平衡树</tag>
        <tag>set</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「HNOI2002」营业额统计]]></title>
    <url>%2F2019%2F04%2F07%2F%E3%80%8CHNOI2002%E3%80%8D%E8%90%A5%E4%B8%9A%E9%A2%9D%E7%BB%9F%E8%AE%A1-Solution%2F</url>
    <content type="text"><![CDATA[裸的平衡树？ 题解我们需要求出每一天营业额的前驱和后继，然后挑一个更接近的就行了。 直接上平衡树搞就行。 或者调用STL里的set。 代码蒟蒻我手写了个伸展树。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;const int maxn=32800,inf=0X3F3F3F3F;int n,ans;bool vis[2000010];inline int read()&#123; int ret=0,f=1;char ch=getchar(); while(ch&lt;'0'||ch&gt;'9')&#123;if(ch=='-')f=-f;ch=getchar();&#125; while(ch&gt;='0'&amp;&amp;ch&lt;='9')&#123;ret=ret*10+ch-'0';ch=getchar();&#125; return ret*f;&#125;struct SplayTree&#123; int tot,root; struct Node&#123;int val,siz,fa,son[2];&#125;Tree[maxn]; inline int check(int x)&#123;return Tree[Tree[x].fa].son[1]==x?1:0;&#125; inline void PushUp(int x)&#123;Tree[x].siz=Tree[Tree[x].son[0]].siz+Tree[Tree[x].son[1]].siz+1;&#125; inline void Rotate(int x) &#123; int y=Tree[x].fa,z=Tree[y].fa,k=check(x),w=Tree[x].son[k^1]; Tree[y].son[k]=w; Tree[w].fa=y; Tree[x].fa=z; Tree[z].son[check(y)]=x; Tree[x].son[k^1]=y; Tree[y].fa=x; PushUp(y); PushUp(x); &#125; inline void Splay(int x) &#123; while(Tree[x].fa) &#123; int y=Tree[x].fa; if(Tree[y].fa) &#123; if(check(x)==check(y)) Rotate(y); else Rotate(x); &#125; Rotate(x); &#125; root=x; &#125; inline void Insert(int v) &#123; int p=root,fa=0; while(p) &#123; fa=p; p=Tree[p].son[v&gt;Tree[p].val]; &#125; p=++tot; Tree[fa].son[v&gt;Tree[fa].val]=p; Tree[p].fa=fa; Tree[p].siz=1; Tree[p].val=v; Splay(p); &#125; int FindPre(int v) &#123; int p=Tree[root].son[0]; if(!p) return -inf; while(Tree[p].son[1]) p=Tree[p].son[1]; return Tree[p].val; &#125; int FindSuf(int v) &#123; int p=Tree[root].son[1]; if(!p) return inf; while(Tree[p].son[0]) p=Tree[p].son[0]; return Tree[p].val; &#125;&#125;ST;int main()&#123; n=read(); for(int i=1;i&lt;=n;i++) &#123; int Ai=read(); if(i==1) ans+=Ai; if(!vis[Ai+1000005]) &#123; ST.Insert(Ai); if(i!=1) ans+=min(Ai-ST.FindPre(Ai),ST.FindSuf(Ai)-Ai); vis[Ai+1000005]=true; &#125; &#125; printf("%d\n",ans); return 0;&#125;]]></content>
      <categories>
        <category>平衡树</category>
      </categories>
      <tags>
        <tag>平衡树</tag>
        <tag>set</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「JLOI2014」松鼠的新家]]></title>
    <url>%2F2019%2F04%2F07%2F%E3%80%8CJLOI2014%E3%80%8D%E6%9D%BE%E9%BC%A0%E7%9A%84%E6%96%B0%E5%AE%B6-Solution%2F</url>
    <content type="text"><![CDATA[蒟蒻我差点把简单问题复杂化QwQ。 传送门洛谷P3258 BZOJ3631 题解这两天刚做了几道树剖题。 害得我这题一上来就像码树剖。 其实完全没必要。 由于修改操作只有将一整条路劲上的点都加1，所以直接树上差分就可以了。 设修改的路径的两个端点分别为$a,b$，那么只要让a和b的权值加1，LCA(a,b)和它的父亲的权值分别减1。然后对于任意一个节点，它整个子树的权值加和便是该节点真正的权值。 然后注意一下细节即可。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;const int maxn=300005;int n,A[maxn],tot,lnk[maxn],son[maxn*2],nxt[maxn*2],F[maxn],father[maxn][20],dep[maxn];inline char nc()&#123; const int S=131072;static char buf[S],*L,*R; return L==R&amp;&amp;(R=(L=buf)+fread(buf,1,S,stdin),L==R)?EOF:*L++;&#125;inline int read()&#123; int ret=0,f=1;char ch=nc(); while(ch&lt;'0'||ch&gt;'9')&#123;if(ch=='-')f=-f;ch=nc();&#125; while(ch&gt;='0'&amp;&amp;ch&lt;='9')&#123;ret=ret*10+ch-'0';ch=nc();&#125; return ret*f;&#125;inline void add_e(int x,int y)&#123;tot++;son[tot]=y;nxt[tot]=lnk[x];lnk[x]=tot;&#125;void Build(int now,int fa)&#123; father[now][0]=fa;dep[now]=dep[fa]+1; for(int i=1;i&lt;=18;i++) father[now][i]=father[father[now][i-1]][i-1]; for(int i=lnk[now];i;i=nxt[i]) if(son[i]!=fa) Build(son[i],now);&#125;inline int LCA(int u,int v)&#123; if(dep[u]&lt;dep[v]) swap(u,v); for(int i=18;i&gt;=0;i--) if(dep[father[u][i]]&gt;=dep[v]) u=father[u][i]; for(int i=18;i&gt;=0;i--) if(father[u][i]!=father[v][i])&#123;u=father[u][i];v=father[v][i];&#125; if(u!=v) return father[u][0]; return u;&#125;void DFS(int now,int fa)&#123; for(int i=lnk[now];i;i=nxt[i]) if(son[i]!=fa) &#123;DFS(son[i],now);F[now]+=F[son[i]];&#125;&#125;int main()&#123; n=read(); for(int i=1;i&lt;=n;i++) A[i]=read(); for(int i=1;i&lt;n;i++) &#123; int a=read(),b=read(); add_e(a,b);add_e(b,a); &#125; Build(1,0); for(int i=1;i&lt;n;i++) &#123; F[A[i]]++; F[A[i+1]]++; int lca=LCA(A[i],A[i+1]); F[lca]--; F[father[lca][0]]--; &#125; DFS(1,0); for(int i=1;i&lt;n;i++) F[A[i+1]]--; for(int i=1;i&lt;=n;i++) printf("%d\n",F[i]); return 0;&#125;]]></content>
      <categories>
        <category>树上差分</category>
      </categories>
      <tags>
        <tag>LCA</tag>
        <tag>线段树</tag>
        <tag>树链剖分</tag>
        <tag>树上差分</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「NOI2015」软件包管理器]]></title>
    <url>%2F2019%2F04%2F06%2F%E3%80%8CNOI2015%E3%80%8D%E8%BD%AF%E4%BB%B6%E5%8C%85%E7%AE%A1%E7%90%86%E5%99%A8-Solution%2F</url>
    <content type="text"><![CDATA[又是一个树剖题QwQ。 传送门洛谷P2146 BZOJ4196 题解不难发现，各个软件包之间的依赖关系构成了一棵树。 所以先把树建出来，每一个节点设一个权值，权值为$0$表示还未安装，权值为$1$表示已安装。 当安装软件$x$的时候，答案为$x$到根节点的路径上没有安装的软件的数量，然后把一整条路径上的节点的权值都设成1。 卸载软件$x$的时候，答案为$x$的子树中已经安装的软件的数量，然后把整棵子树中所有节点的权值都设为0。 然后弄个支持区间覆盖查询区间加和的线段树维护下就好了。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114#include&lt;cstdio&gt;#include&lt;cstring&gt;using namespace std;const int maxn=100005;int n,m,tot,lnk[maxn],son[maxn*2],w[maxn],nxt[maxn*2],idx,siz[maxn],wson[maxn],fa[maxn],top[maxn],seg[maxn],rev[maxn],ans;char cmd[10];inline int read()&#123; int ret=0,f=1;char ch=getchar(); while(ch&lt;'0'||ch&gt;'9')&#123;if(ch=='-')f=-f;ch=getchar();&#125; while(ch&gt;='0'&amp;&amp;ch&lt;='9')&#123;ret=ret*10+ch-'0';ch=getchar();&#125; return ret*f;&#125;struct SegmentTree&#123; struct Node&#123;int Sum,Tag;&#125;Tree[maxn*4]; void PushUp(int rt)&#123;Tree[rt].Sum=Tree[rt*2].Sum+Tree[rt*2+1].Sum;&#125; void PushDown(int rt,int LC,int RC) &#123; if(Tree[rt].Tag==-1) return; Tree[rt*2].Sum=Tree[rt].Tag*LC; Tree[rt*2+1].Sum=Tree[rt].Tag*RC; Tree[rt*2].Tag=Tree[rt].Tag; Tree[rt*2+1].Tag=Tree[rt].Tag; Tree[rt].Tag=-1; &#125; void RangeUpdate(int LL,int RR,int delta,int L=1,int R=n,int rt=1) &#123; if(LL&lt;=L&amp;&amp;R&lt;=RR) &#123; Tree[rt].Sum=delta*(R-L+1); Tree[rt].Tag=delta; return; &#125; int M=(L+R)/2; PushDown(rt,M-L+1,R-M); if(LL&lt;=M) RangeUpdate(LL,RR,delta,L,M,rt*2); if(M&lt;RR) RangeUpdate(LL,RR,delta,M+1,R,rt*2+1); PushUp(rt); &#125; int QueryRange(int LL,int RR,int L=1,int R=n,int rt=1) &#123; if(LL&lt;=L&amp;&amp;R&lt;=RR) return Tree[rt].Sum; int M=(L+R)/2,ret=0; PushDown(rt,M-L+1,R-M); if(LL&lt;=M) ret+=QueryRange(LL,RR,L,M,rt*2); if(M&lt;RR) ret+=QueryRange(LL,RR,M+1,R,rt*2+1); return ret; &#125;&#125;T;inline void add_e(int x,int y)&#123;tot++;son[tot]=y;nxt[tot]=lnk[x];lnk[x]=tot;&#125;void DFS1(int now)&#123; siz[now]=1; for(int i=lnk[now];i;i=nxt[i]) &#123; if(son[i]==fa[now]) continue; fa[son[i]]=now; DFS1(son[i]); siz[now]+=siz[son[i]]; &#125; for(int i=lnk[now];i;i=nxt[i]) if(son[i]!=fa[now]&amp;&amp;siz[son[i]]&gt;siz[wson[now]]) wson[now]=son[i];&#125;void DFS2(int now)&#123; seg[now]=++idx;rev[seg[now]]=now; if(now==1) top[now]=1; if(wson[now]) &#123; top[wson[now]]=top[now]; DFS2(wson[now]); &#125; for(int i=lnk[now];i;i=nxt[i]) &#123; if(son[i]==fa[now]||son[i]==wson[now]) continue; top[son[i]]=son[i]; DFS2(son[i]); &#125;&#125;int main()&#123; n=read(); for(int i=2;i&lt;=n;i++) &#123; int a=read()+1; add_e(a,i);add_e(i,a); &#125; for(int i=1;i&lt;=n*4;i++) T.Tree[i].Tag=-1; DFS1(1);DFS2(1); m=read(); while(m--) &#123; scanf("%s",cmd); int x=read()+1;ans=0; if(strcmp(cmd,"install")==0) &#123; while(x&gt;0) &#123; ans+=seg[x]-seg[top[x]]+1-T.QueryRange(seg[top[x]],seg[x]); T.RangeUpdate(seg[top[x]],seg[x],1); x=fa[top[x]]; &#125; printf("%d\n",ans); &#125; else &#123; ans=T.QueryRange(seg[x],seg[x]+siz[x]-1); T.RangeUpdate(seg[x],seg[x]+siz[x]-1,0); printf("%d\n",ans); &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>树链剖分</category>
      </categories>
      <tags>
        <tag>线段树</tag>
        <tag>树链剖分</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「HAOI2015」树上操作]]></title>
    <url>%2F2019%2F04%2F06%2F%E3%80%8CHAOI2015%E3%80%8D%E6%A0%91%E4%B8%8A%E6%93%8D%E4%BD%9C-Solution%2F</url>
    <content type="text"><![CDATA[赤裸裸的树剖啊。 传送门洛谷P3178 BZOJ4034 题解裸的树链剖分，没啥好说的。直接搞就好了 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124#include&lt;cstdio&gt;using namespace std;typedef long long LL;const int maxn=100005;int n,m,tot,lnk[maxn],son[maxn*2],w[maxn],nxt[maxn*2],idx,siz[maxn],wson[maxn],fa[maxn],top[maxn],seg[maxn],rev[maxn];LL ans;inline int read()&#123; int ret=0,f=1;char ch=getchar(); while(ch&lt;'0'||ch&gt;'9')&#123;if(ch=='-')f=-f;ch=getchar();&#125; while(ch&gt;='0'&amp;&amp;ch&lt;='9')&#123;ret=ret*10+ch-'0';ch=getchar();&#125; return ret*f;&#125;struct SegmentTree&#123; struct Node&#123;LL Sum,Tag;&#125;Tree[maxn*4]; void PushUp(int rt)&#123;Tree[rt].Sum=Tree[rt*2].Sum+Tree[rt*2+1].Sum;&#125; void PushDown(int rt,int LC,int RC) &#123; if(!Tree[rt].Tag) return; Tree[rt*2].Sum+=Tree[rt].Tag*LC; Tree[rt*2+1].Sum+=Tree[rt].Tag*RC; Tree[rt*2].Tag+=Tree[rt].Tag; Tree[rt*2+1].Tag+=Tree[rt].Tag; Tree[rt].Tag=0; &#125; void Build(int L=1,int R=n,int rt=1) &#123; if(L==R)&#123;Tree[rt].Sum=w[rev[L]];return;&#125; int M=(L+R)&gt;&gt;1; Build(L,M,rt*2); Build(M+1,R,rt*2+1); PushUp(rt); &#125; void RangeUpdate(int LL,int RR,int delta,int L=1,int R=n,int rt=1) &#123; if(LL&lt;=L&amp;&amp;R&lt;=RR) &#123; Tree[rt].Sum+=(long long)delta*(R-L+1); Tree[rt].Tag+=delta; return; &#125; int M=(L+R)/2; PushDown(rt,M-L+1,R-M); if(LL&lt;=M) RangeUpdate(LL,RR,delta,L,M,rt*2); if(M&lt;RR) RangeUpdate(LL,RR,delta,M+1,R,rt*2+1); PushUp(rt); &#125; LL QueryRange(int LL,int RR,int L=1,int R=n,int rt=1) &#123; if(LL&lt;=L&amp;&amp;R&lt;=RR) return Tree[rt].Sum; int M=(L+R)/2;::LL ret=0; PushDown(rt,M-L+1,R-M); if(LL&lt;=M) ret+=QueryRange(LL,RR,L,M,rt*2); if(M&lt;RR) ret+=QueryRange(LL,RR,M+1,R,rt*2+1); return ret; &#125;&#125;T;inline void add_e(int x,int y)&#123;tot++;son[tot]=y;nxt[tot]=lnk[x];lnk[x]=tot;&#125;void DFS1(int now)&#123; siz[now]=1; for(int i=lnk[now];i;i=nxt[i]) &#123; if(son[i]==fa[now]) continue; fa[son[i]]=now; DFS1(son[i]); siz[now]+=siz[son[i]]; &#125; for(int i=lnk[now];i;i=nxt[i]) if(son[i]!=fa[now]&amp;&amp;siz[son[i]]&gt;siz[wson[now]]) wson[now]=son[i];&#125;void DFS2(int now)&#123; seg[now]=++idx;rev[seg[now]]=now; if(now==1) top[now]=1; if(wson[now]) &#123; top[wson[now]]=top[now]; DFS2(wson[now]); &#125; for(int i=lnk[now];i;i=nxt[i]) &#123; if(son[i]==fa[now]||son[i]==wson[now]) continue; top[son[i]]=son[i]; DFS2(son[i]); &#125;&#125;int main()&#123; n=read();m=read(); for(int i=1;i&lt;=n;i++) w[i]=read(); for(int i=1;i&lt;n;i++) &#123; int a=read(),b=read(); add_e(a,b);add_e(b,a); &#125; DFS1(1);DFS2(1);T.Build(); while(m--) &#123; int opt=read(),x=read(); if(opt==1) &#123; int a=read(); T.RangeUpdate(seg[x],seg[x],a); &#125; else if(opt==2) &#123; int a=read(); T.RangeUpdate(seg[x],seg[x]+siz[x]-1,a); &#125; else &#123; ans=0; while(x&gt;0) &#123; ans+=T.QueryRange(seg[top[x]],seg[x]); x=fa[top[x]]; &#125; printf("%lld\n",ans); &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>树链剖分</category>
      </categories>
      <tags>
        <tag>线段树</tag>
        <tag>树链剖分</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「国家集训队」跳跳棋]]></title>
    <url>%2F2019%2F04%2F06%2F%E3%80%8C%E5%9B%BD%E5%AE%B6%E9%9B%86%E8%AE%AD%E9%98%9F%E3%80%8D%E8%B7%B3%E8%B7%B3%E6%A3%8B-Solution%2F</url>
    <content type="text"><![CDATA[这题藏得有点深啊。 传送门洛谷P1852 BZOJ2144 题解这题的建模有点神仙。 根据题意，设三颗棋子的位置分别为$a,b,c(a&lt;b&lt;c)​$，令$d1=b-a,d2=c-b​$。 由题意可知，一共有三种移动方式： 中间的棋子往左跳。 中间的棋子往右跳。 两边的棋子中离中间棋子近的一颗往中间跳。 假如不断使用第三种跳法，那么对于任意一个状态，最后它将会跳到一个$d1=d2$的状态，此时便不能继续跳了。 并且对于任意一个状态，它只可能由两种状态执行操作三而转移过来。 所以如果以一个$d1=d2​$的状态作为根，每个状态向可能转移到该状态的两个状态建边，那么这将会是一颗二叉树。 对于两个状态，它们所对应的节点在树上的最短路径的长度就是转移所需的最小步数。 如果这两个状态不在同一棵树上，那么它们之间就不可能相互转移。 于是乎建出树之后，直接求LCA就行了。 但是还有一个问题就是树太大了，存不下。 那就可以先求出两个状态到根的深度，然后先把深度大的向上跳到深度相同，接着二分到LCA的距离即可。 注意当$d1$和$d2​$相差了好多倍时，可以一次性跳好几步，以免TLE。 然后就，没了… 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;int dep1,dep2,ans;struct Ball&#123; int a,b,c; inline void Sort() &#123; if(a&gt;b) swap(a,b); if(a&gt;c) swap(a,c); if(b&gt;c) swap(b,c); &#125; bool operator == (const Ball&amp; b)const&#123;return a==b.a&amp;&amp;this-&gt;b==b.b&amp;&amp;c==b.c;&#125;&#125;A,B,tep1,tep2;int GetFather(Ball x,int stp,Ball&amp; lst)&#123; int d1=x.b-x.a,d2=x.c-x.b,ret=0; while(d1!=d2&amp;&amp;stp&gt;0) &#123; if(d1&lt;d2) &#123; if(d2%d1==0) &#123; int nt=min(stp,d2/d1-1); x.a+=nt*d1;x.b+=nt*d1; stp=0;ret+=nt; &#125; else &#123; int nt=min(stp,d2/d1); x.a+=nt*d1;x.b+=nt*d1; stp-=nt;ret+=nt; &#125; &#125; else &#123; if(d1%d2==0) &#123; int nt=min(stp,d1/d2-1); x.b-=nt*d2;x.c-=nt*d2; stp=0;ret+=nt; &#125; else &#123; int nt=min(stp,d1/d2); x.b-=nt*d2;x.c-=nt*d2; stp-=nt;ret+=nt; &#125; &#125; d1=x.b-x.a;d2=x.c-x.b; &#125; lst=x; return ret;&#125;int main()&#123; scanf("%d%d%d%d%d%d",&amp;A.a,&amp;A.b,&amp;A.c,&amp;B.a,&amp;B.b,&amp;B.c); A.Sort();B.Sort(); dep1=GetFather(A,2147483647,tep1); dep2=GetFather(B,2147483647,tep2); if(!(tep1==tep2)) &#123; printf("NO\n"); return 0; &#125; if(dep1&gt;dep2) &#123; ans+=dep1-dep2; GetFather(A,dep1-dep2,tep1); A=tep1;dep1=dep2; &#125; if(dep2&gt;dep1) &#123; ans+=dep2-dep1; GetFather(B,dep2-dep1,tep2); B=tep2;dep2=dep1; &#125; int L=0,R=dep1,mid; while(L&lt;=R) &#123; mid=(L+R)&gt;&gt;1; GetFather(A,mid,tep1); GetFather(B,mid,tep2); tep1==tep2?R=mid-1:L=mid+1; &#125; ans+=L*2; printf("YES\n%d\n",ans); return 0;&#125;]]></content>
      <categories>
        <category>LCA</category>
      </categories>
      <tags>
        <tag>二分</tag>
        <tag>LCA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「国家集训队」middle]]></title>
    <url>%2F2019%2F03%2F29%2F%E3%80%8C%E5%9B%BD%E5%AE%B6%E9%9B%86%E8%AE%AD%E9%98%9F%E3%80%8Dmiddle-Solution%2F</url>
    <content type="text"><![CDATA[丽洁姐的题目，不错不错。 传送门洛谷P2839 BZOJ2653 题解这题还是挺好玩的。 首先可以二分枚举答案。设当前枚举到的答案为$mid$，那么就把大于等于当前答案的数标为1，小于的标为-1。如果两个端点分别在指定区间内的加和最大的区间的加和大于等于0，那么当前二分到的值可以再大一些，否则就应该小一些。 由于最后的区间必然包括$[b+1,c-1]$，所以需要求出区间$[a,b]$的最大后缀和以及区间$[c,d]$的最大前缀和。 先对原序列离散化，这样最后可能二分到的答案就只剩下$n$个。然以后对于每一个可能二分到的答案，将以它为基准构造出的由1和-1组成的序列预处理出来，用线段树就可以维护一个区间的加和、最大前缀和、最大后缀和。但是这样复杂度是爆炸的。所以可以先排序，然后由于每次按顺序修改基准数只会将一个位置的值由1改为-1，所以用主席树维护就好了。 原序列中可能有相同元数字，注意细节即可。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101#include&lt;map&gt;#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;const int maxn=20005,LOG=16;int n,Q,cnt,A[maxn],id[maxn],q[10],ans;map&lt;int,int&gt; CR;inline int read()&#123; int ret=0,f=1;char ch=getchar(); while(ch&lt;'0'||ch&gt;'9')&#123;if(ch=='-')f=-f;ch=getchar();&#125; while(ch&gt;='0'&amp;&amp;ch&lt;='9')&#123;ret=ret*10+ch-'0';ch=getchar();&#125; return ret*f;&#125;struct ChairmanTree&#123; int tot,R[maxn]; struct Node&#123;int L,R,Sum,FMS,BMS;&#125;Tree[maxn*2*LOG]; inline void PushUp(int rt) &#123; Tree[rt].Sum=Tree[Tree[rt].L].Sum+Tree[Tree[rt].R].Sum; Tree[rt].FMS=max(Tree[Tree[rt].L].FMS,Tree[Tree[rt].L].Sum+Tree[Tree[rt].R].FMS); Tree[rt].BMS=max(Tree[Tree[rt].R].BMS,Tree[Tree[rt].R].Sum+Tree[Tree[rt].L].BMS); &#125; inline int New()&#123;return ++tot;&#125; void Build(int rt,int L=1,int R=n) &#123; if(L==R)&#123;Tree[rt].Sum=Tree[rt].FMS=Tree[rt].BMS=1;return;&#125; Tree[rt].L=New(); Tree[rt].R=New(); int M=(L+R)&gt;&gt;1; Build(Tree[rt].L,L,M); Build(Tree[rt].R,M+1,R); PushUp(rt); &#125; void Update(int rt,int pre,int p,int L=1,int R=n) &#123; if(L==R)&#123;Tree[rt].Sum=Tree[rt].FMS=Tree[rt].BMS=-1;return;&#125; Tree[rt]=Tree[pre]; int M=(L+R)&gt;&gt;1; if(p&lt;=M) &#123; Tree[rt].L=New(); Update(Tree[rt].L,Tree[pre].L,p,L,M); &#125; if(M&lt;p) &#123; Tree[rt].R=New(); Update(Tree[rt].R,Tree[pre].R,p,M+1,R); &#125; PushUp(rt); &#125; Node Query(int rt,int LL,int RR,int L=1,int R=n) &#123; if(LL&gt;RR)&#123;return (Node)&#123;0,0,0,0,0&#125;;&#125; if(LL&lt;=L&amp;&amp;R&lt;=RR) return Tree[rt]; int M=(L+R)&gt;&gt;1;Node IL,IR,ret; if(LL&lt;=M) IL=Query(Tree[rt].L,LL,RR,L,M); if(M&lt;RR) IR=Query(Tree[rt].R,LL,RR,M+1,R); if(LL&lt;=M&amp;&amp;M&gt;=RR) return IL; if(LL&gt;M&amp;&amp;M&lt;RR) return IR; ret.Sum=IL.Sum+IR.Sum; ret.FMS=max(IL.FMS,IL.Sum+IR.FMS); ret.BMS=max(IR.BMS,IR.Sum+IL.BMS); return ret; &#125;&#125;CT;inline bool cmp(int x,int y)&#123;return A[x]&lt;A[y];&#125;inline void Solve(int a,int b,int c,int d)&#123; int L=1,R=n,mid; while(L&lt;=R) &#123; mid=(L+R)&gt;&gt;1; ChairmanTree::Node IL=CT.Query(CT.R[CR[A[id[mid]]]],a,b),IM=CT.Query(CT.R[CR[A[id[mid]]]],b+1,c-1),IR=CT.Query(CT.R[CR[A[id[mid]]]],c,d); IL.BMS+IM.Sum+IR.FMS&gt;=0?L=mid+1:R=mid-1; &#125; ans=A[id[R]]; printf("%d\n",ans);&#125;int main()&#123; n=read(); for(int i=1;i&lt;=n;i++) A[i]=read(); for(int i=1;i&lt;=n;i++) id[i]=i; sort(id+1,id+1+n,cmp); CT.R[1]=CT.New();CT.Build(1);CR[A[id[1]]]=1; for(int i=2;i&lt;=n;i++) &#123; CT.R[i]=CT.New(); if(!CR[A[id[i]]]) CR[A[id[i]]]=i; CT.Update(CT.R[i],CT.R[i-1],id[i-1]); &#125; Q=read(); while(Q--) &#123; q[1]=(read()+ans)%n+1;q[2]=(read()+ans)%n+1;q[3]=(read()+ans)%n+1;q[4]=(read()+ans)%n+1; sort(q+1,q+1+4); Solve(q[1],q[2],q[3],q[4]); &#125; return 0;&#125;]]></content>
      <categories>
        <category>主席树</category>
      </categories>
      <tags>
        <tag>二分</tag>
        <tag>主席树</tag>
        <tag>可持久化线段树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「BZOJ5164」餐厅计划问题]]></title>
    <url>%2F2019%2F03%2F25%2F%E3%80%8CBZOJ5164%E3%80%8D%E9%A4%90%E5%8E%85%E8%AE%A1%E5%88%92%E9%97%AE%E9%A2%98-Solution%2F</url>
    <content type="text"><![CDATA[什么鬼，数据范围直接加上两个0？ 传送门BZOJ5164 题解前两天刚做过这题的简化版，数据范围比较小，那题直接上网络流搞就好了。 但是这题数据范围大了好多，没法n方过百万了。 考虑一下，不难发现，总的购买餐巾的数量与购买餐巾数量一定时的最小话费呈一个单谷函数哎！ 然后就可三分或者二分了查找最小值了！ 但是怎么计算购买餐巾数量一定时的最小话费呢？ 当然是贪心啦！ 先一次性把新的餐巾都买来，有新的就用新的，没新的就尝试找一天的旧餐巾送到慢洗部，如果还是不够的话就找离当前最近的一天的旧餐巾送到快西部。 找的时候弄个并查集维护一下就好了。计算最小费用的是$O(n)$的。 注意如果不存在合法方案的话费用为$\infty$。 所以总的时间复杂度为$O(nlog\sum_{i=1}^{n}{ri})$。 然后写完之后交掉发现自己BZOJ竟然rank1。（好吧总共也没几个人A掉） 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;const int maxn=200005,inf=2147483647;int n,m1,m2,c1,c2,p,r[maxn],L=1,R,mid,lst[maxn],fa[maxn];inline char nc()&#123; const int S=131072;static char buf[S],*L,*R; return L==R&amp;&amp;(R=(L=buf)+fread(buf,1,S,stdin),L==R)?EOF:*L++;&#125;inline int read()&#123; int ret=0,f=1;char ch=nc(); while(ch&lt;'0'||ch&gt;'9')&#123;if(ch=='-')f=-f;ch=nc();&#125; while(ch&gt;='0'&amp;&amp;ch&lt;='9')&#123;ret=ret*10+ch-'0';ch=nc();&#125; return ret*f;&#125;inline int getfa(int x)&#123;return fa[x]==x?x:fa[x]=getfa(fa[x]);&#125;inline int check(int cnt)&#123; int ret=cnt*p,p1=1,p2; memset(lst,0,sizeof(lst)); for(int i=1;i&lt;=n;i++) fa[i]=i; for(int i=1;i&lt;=n;i++) &#123; int ri=r[i]; if(cnt&gt;0) &#123; int t=min(ri,cnt); ri-=t;cnt-=t; &#125; if(ri&gt;0) &#123; while(p1&lt;i&amp;&amp;ri&gt;0&amp;&amp;i-p1&gt;=m1) &#123; int t=min(ri,lst[p1]); ri-=t;lst[p1]-=t;ret+=t*c1; if(lst[p1]==0) p1++; &#125; p2=i-m2; while(ri&gt;0&amp;&amp;p2&gt;0&amp;&amp;i-p2&gt;=m2) &#123; int t=min(ri,lst[p2]); ri-=t;lst[p2]-=t;ret+=t*c2; if(lst[p2]==0)&#123;fa[p2]=p2-1;p2=getfa(p2-1);&#125; &#125; if(ri) return inf; &#125; lst[i]=r[i]; &#125; return ret;&#125;int main()&#123; n=read();m1=read();m2=read();c1=read();c2=read();p=read(); if(c1&gt;c2)&#123;swap(m1,m2);swap(c1,c2);&#125; for(int i=1;i&lt;=n;i++) &#123; r[i]=read(); R+=r[i]; &#125; while(L&lt;=R) &#123; mid=(L+R)&gt;&gt;1; check(mid)&gt;=check(mid+1)?L=mid+1:R=mid-1; &#125; printf("%d\n",check(R+1)); return 0;&#125;]]></content>
      <categories>
        <category>贪心</category>
      </categories>
      <tags>
        <tag>网络流</tag>
        <tag>三分</tag>
        <tag>二分</tag>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「ZJOI2019」游记]]></title>
    <url>%2F2019%2F03%2F24%2F%E3%80%8CZJOI2019%E3%80%8D%E6%B8%B8%E8%AE%B0-Diary%2F</url>
    <content type="text"><![CDATA[一个蒟蒻的ZJOI游记。 Day1-2019.03.24今天早上8点过就早早到了机房，发现只有神仙黄霖和蒟蒻我。 过了一会儿8:30过了大家都到了。9:00左右乘车出发。 中午服务区吃饭，吃了一个十块钱的烤饼，血亏。 下午1点多钟到了镇海，先去了宾馆，老叶直接制定了宿舍分配方案，我有幸和哥哥陈浩杰分到一起。房间在二楼，进了房间，卧槽，一个硕大的CRT电视出现在了面前，连个HDMI接口都没有，看来电脑不能接到电视上爽了。差评。 然后去了填海镇海中学，镇中的建筑风格我真是欣赏不来，古色古香的。 报到领了狗牌、餐票，听说伙食贼差，不知道是不是真的。 门口有免费的旅游手册，好评。 学校里有小姐姐夹道欢迎，好评。 去了报告厅参加颁奖大会（然而并没有蒟蒻我的奖，可能是因为今年收不到钱了，所以没几个人有奖）。看到了兴华的郭老师和杭二的李建老师上台领奖。 然后又回到了宾馆。尝试联网，发现网速贼慢。就将就着用吧。 晚饭是在镇中的食堂吃的，老叶给一个寝室买了一套饭票，让大家轮流到外面吃。一张票25块钱，有点小贵。一顿是两荤两素一水果。对于平时在学校里一荤一素都吃不完的我来说有点多。味道一般吧。 晚上在宾馆做了几道题，其中有一道是网络流24题之一的餐巾计划问题的加强版，数据范围直接加上了两个0。这回真的是没法n方过百万了。陈浩杰看了一下题解，发现直接三分加贪心就好了，比网络流还好搞。写好一交结果不知什么原因就排到BZOJ的rank2了，然后又写了个读优就rank1了。陈浩杰又调了一会儿才过。东弄一下西搞一下就晚上11点多了，赶紧睡觉。 Day2-2019.03.25早上6:00钟的闹钟准时叫醒了自己，想再睡一会，结果就一觉睡到了7点钟。还好小威来叫了哥哥又叫了我，不然又要迟到了。 早饭是酒店里吃的，一般般。 早上集训队爷罗煜翔大佬给大家讲课。 先讲了下降幂的定义等，然后就是与下降幂形式多项式相关的一大坨东西。 蒟蒻我实在是太菜了，基本上全程掉线。 9:40左右休息了一下，然后又开始讲斯特林数。 斯特林数又被集训队爷写成了下降幂的形式。 讲了斯特林数单行的求法。 多项式平移。 斯特林数列的求法。 斯特林数单个的求法。 我数学还是太差了，真的没办法。 中午在外面吃的，吃了一碗红烧牛肉面，牛肉贼多，弄得我都开始怀疑是不是牛肉了。 下午是杂题选讲，孔朝哲大佬讲课。 感觉还是可以听懂一些的。 有一题是BZOJ4657，昨天刚做过一个类似的题目叫做方格取数问题，于是我便一眼看出来是网络流，建模后求最小割然后转为最大流，然后用不一定合法的最优方案的值减去最大流就是答案。但是我网络流建模不咋地，所以还是没能当场建出模型然后切掉。 下午和徐锐扬、徐瀚文坐在了一起，还看见了徐安矣。 不可思议的是我这机子竟然用了一天还是有电。 食堂吃了晚饭，然后去试机。 机子的显示器长宽比例很有问题，是5:4的，1280*1024的分辨率，差评。 键盘的手感不错，好评。 机子比较老，酷睿2的处理器，只有两个框框，差评。 其他都还好，就是软件的版本也有些旧。 总之机器没有衢二的好。 晚上回了宾馆，又写了会儿题，神仙赵章恺来了我们房间，我感觉明后天的运气不会差了。 泡了一杯宾馆里免费的雀巢咖啡喝，因为怕苦，咖啡放得很少，而糖放得很多。感觉味道不错。 今天睡得比昨天早，打算明天早一点起来。 Day3-2019.03.26今天早上5点半左右就醒了，春分刚过，太阳很早就出来了。又在床上躺了一会儿，6点过便起来了。早上也没干什么事，就看了一下板子。然后早早地就下楼去吃早饭。吃了早饭还是挺早的，又回房间待了一会儿，然后和大家一起出发去镇中。 早上是范致远大佬讲课。又是杂题选讲。 有一道题是以前在二中NOIP模拟赛的题，叫Maximum Tree Path，赵章恺上台切掉了，直接暴力枚举gcd然后动态加边维护直径即可。 还有一道题叫做“Count on a Treap ”，赵章恺以前准备NOIP的时候做过，就给我讲了一下，感觉还是不怎么难的，然后我就上台口胡了。这题再想清楚一些性质之后就转化为了动态维护最长上升子序列，弄个线段树瞎搞一下就好了。 ZJOI每年任务：上台口胡（1/1） 中午跑到外面吃了一碗脆皮鸡米饭，一般般。 下午是一位从来没有听说过名字的大佬给我们讲随机算法。 讲到了DZY lovs Chinese II，然后衢州二中初三神仙华外之光黄霖便上台秒了此题。 还讲到了什么Pollard Rho算法，这个算法以前听同学讲过，晚上就看到神仙学弟徐锐扬在切这个算法的模板题了。 下午讲课的时候讲课人给大家下了半个小时的课，然后我就看到很多听得不耐烦的人走了。我便去找徐瀚文大佬，还看到了Dilute、张亲翰、欧阳锳杰、邵嘉男、memset0等大佬。之前只是在网上听过他们的名字，这回还真让我见到了。结果因为一些原因差点被他们一起阿掉。 下午的课讲完之后，老叶请大家到学校边上的一家饭店吃饭，菜挺多的，还有海鲜，吃饭的时候我们这桌一直在互相fake。老叶说今年省选可能会比较简单，蒟蒻我的内心又划过一丝凉意。和徐锐扬开玩笑说如果明天我爆零了他就发三张女装照，没爆零我就发三张女装照。 吃完晚饭，去边上的一鸣真鲜奶吧买了个面包当做明天考试的时候的点心，然后就回宾馆了。 晚上感觉挺紧张的，明天就要省选考试了，不知道会不会爆零。更不知道能不能苟到二试。希望能考好点吧。晚上放了大悲咒、往生咒、般若波罗蜜多心经什么的，希望获得佛祖的保佑。 今天房间里的雀巢咖啡换了一种，看起来更高大上，泡了一点喝，还不错。 明天要考试了，今天打算再早一点睡觉。 晚上洗了个澡，就早早地躺床上了。很担心明天会不会爆零。 Day4-2019.03.27今天就是ZJOI2019的一试了。 早上准时起了床，看了会儿手机。才看到学弟徐锐扬又学习到凌晨。可怕。今天怕是要被踩了。然后下去吃了早饭。因为今天是考试，所以就不带电脑了。于是把电脑放在宾馆里，调大音量，继续放大悲咒。 然后就和各路神仙一起去ZJOI考场了。 密码迟了十分钟才公布，只好先打读优板子。 密码公布之前，看了一下加密过的压缩包，发现大样例中题目的英文名并没有被加密。我去！竟然有麻将！ 密码公布之后，打开了试卷。T1果真是麻将。就是在只有一个人打的情况下，问期望的最小胡牌巡目数。想了半天，还是连$n=5$的暴力都没想到，复杂度都很假。主要还是不知道该怎样快速判断一副牌胡了没。本来想DP，但是发现复杂度过不去。后来才发现，好像直接爆搜组面子和对子就好了。终于知道20分的暴力大概怎么写了，于是蒟蒻我赶紧写掉了。样例很水，是一个叫做什么纯正九莲宝灯的牌型，随便来一张牌都能胡。但是由于复杂度实在太大，连样例都出不来。 看T2，我去又是一个叫做线段树的题。 我也没想什么高级一点的东西，直接先把20分的暴力写了。但是样例实在是太水了，一开始忘记PushDown都过了。由于每次非询问操作都会将线段树的数量扩大一倍，所以我写的大暴力的复杂度仍然是指数级的。 接着看T3，题面又臭又长，跟什minimax搜索有关。我直接看部分分，瞎写了一个复杂度又是指数级的大暴力。由于没有细想性质，到底对不对也不知道。 因为T1一个样例都没过，所以回头去造了几个小样例手玩检查正确性。不知不觉中时间就过去了。 考试结束后，出来和同学们一交流，才发现原来T1在暴枚排列的时候可以加入很多剪枝。而我却为了图方便直接调用了STL里的next_permutation()，一点剪枝也没加。加了剪枝之后说不定能有50分，而我这个最多最多也就20分了。再一次因为自己傻逼没拿全部分分。不知道他们加剪枝的会不会被卡掉。 后来听谁一说，才发现今年的三道题打的暴力都不是多项式级别的复杂度。 然后会宾馆收拾了一下，就和大家一起坐车回家了。车上老叶给大家登记了一下预计的分数，神仙蓝天朗估分90，而且T1只算了20分，如果数据稍微水一点，就100+了，估计可以进队。 哎，回想起去年ZJOI的情形，不禁想要感叹时间怎么过得这样快。感觉这一年又这样荒废掉了，我还是这么菜。以后继续努力吧。 本来按照往年惯例，成绩应该下午还在路上的时候就出来了。但是今年好像说是领导有事情，所以要过两天才能知道成绩。 回来的路上在东阳服务区休息了一下，买了个汉堡吃。一个小小的汉堡要15块钱，服务区的东西就是贵啊。 在车上继续听大悲咒，苟进二试怕是没有希望了。希望佛祖保佑我暴力不要写挂吧。 ZJOI，再见OI。 才想起了翘了许久的文化课。回去之后怕是又要垫底了。]]></content>
      <categories>
        <category>游记</category>
      </categories>
      <tags>
        <tag>游记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「ICPC-Beijing 2006」狼抓兔子]]></title>
    <url>%2F2019%2F03%2F24%2F%E3%80%8CICPC-Beijing-2006%E3%80%8D%E7%8B%BC%E6%8A%93%E5%85%94%E5%AD%90-Solution%2F</url>
    <content type="text"><![CDATA[又是一个网络流。 传送门洛谷P4001 BZOJ1001 题解最大流最小割定理的一个简单运用。 很显然题目中要求的就是图中网络的最小割。 所以直接求最大流就好了。 注意题目中的边是双向的。 数据稍微有点大，但是毕竟Dinic可是n方过百万的，直接搞就好了，注意要稍微加一些优化。 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;const int maxn=1000005,maxe=6000005,inf=0x3F3F3F3F;int n,m,S,T,tot,lnk[maxn],son[maxe],nxt[maxe],cap[maxe],que[maxn],dep[maxn],ans;inline char nc()&#123; const int S=131072;static char buf[S],*L,*R; return L==R&amp;&amp;(R=(L=buf)+fread(buf,1,S,stdin),L==R)?EOF:*L++;&#125;inline int read()&#123; int ret=0,f=1;char ch=nc(); while(ch&lt;'0'||ch&gt;'9')&#123;if(ch=='-')f=-f;ch=nc();&#125; while(ch&gt;='0'&amp;&amp;ch&lt;='9')&#123;ret=ret*10+ch-'0';ch=nc();&#125; return ret*f;&#125;inline void add_e(int x,int y,int z)&#123;tot++;son[tot]=y;cap[tot]=z;nxt[tot]=lnk[x];lnk[x]=tot;&#125;int DFS(int now,int lim)&#123; if(lim==0||now==T) return lim; int ret=0; for(int i=lnk[now];i&amp;&amp;lim;i=nxt[i]) &#123; if(cap[i]&gt;0&amp;&amp;dep[now]+1==dep[son[i]]) &#123; int tep=DFS(son[i],min(lim,cap[i])); if(tep) &#123; ret+=tep; lim-=tep; cap[i]-=tep; cap[(i&amp;1)?i+1:i-1]+=tep; &#125; else dep[son[i]]=-1; &#125; &#125; return ret;&#125;inline void Dinic()&#123; while(true) &#123; int hed=0,til=1; memset(dep,63,sizeof(dep)); que[1]=S;dep[S]=1; while(hed!=til) &#123; hed++; for(int i=lnk[que[hed]];i;i=nxt[i]) &#123; if(cap[i]&gt;0&amp;&amp;dep[que[hed]]+1&lt;dep[son[i]]) &#123; dep[son[i]]=dep[que[hed]]+1; til++; que[til]=son[i]; &#125; &#125; &#125; if(dep[T]==inf) return; ans+=DFS(S,inf); &#125;&#125;int main()&#123; n=read();m=read();S=1;T=n*m; for(int i=1;i&lt;=n;i++) &#123; for(int j=1;j&lt;m;j++) &#123; int a=(i-1)*m+j,b=(i-1)*m+j+1,c=read(); add_e(a,b,c);add_e(b,a,c); &#125; &#125; for(int i=1;i&lt;n;i++) &#123; for(int j=1;j&lt;=m;j++) &#123; int a=(i-1)*m+j,b=i*m+j,c=read(); add_e(a,b,c);add_e(b,a,c); &#125; &#125; for(int i=1;i&lt;n;i++) &#123; for(int j=1;j&lt;m;j++) &#123; int a=(i-1)*m+j,b=i*m+j+1,c=read(); add_e(a,b,c);add_e(b,a,c); &#125; &#125; Dinic(); printf("%d\n",ans); return 0;&#125;]]></content>
      <categories>
        <category>最大流</category>
      </categories>
      <tags>
        <tag>网络流</tag>
        <tag>最大流</tag>
        <tag>Dinic</tag>
        <tag>最小割</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「ZJOI模拟赛」线段树]]></title>
    <url>%2F2019%2F03%2F19%2F%E3%80%8CZJOI%E6%A8%A1%E6%8B%9F%E8%B5%9B%E3%80%8D%E7%BA%BF%E6%AE%B5%E6%A0%91-Solution%2F</url>
    <content type="text"><![CDATA[骚年，你只要种一棵主席树和两棵线段树就能A了这题了，多环保啊！ 题面出于一些原因，这里不放题面。 题解考虑询问的实质。 其实询问的答案必然是序列A中一整段连续区间的最大值。 将$m$个操作进行处理，每个操作都往离它最近的有交集的两个操作（一个操作向左延伸，一个向右）建边。 然后询问的时候倍增，就能很快找到询问实际的左右边界。 用主席树又可以很快找到一个点在操作区间$[L,R]$中最后覆盖它的是哪一个操作。 于是乎建边的时候开一棵线段树，维护全局最大值的时候再开一棵，一共三棵树。 然后就好了。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;const int maxn=100005,LOG=18;int n,m,q,A[maxn],QL[maxn],QR[maxn],FL[maxn][LOG],FR[maxn][LOG];inline int read()&#123; int ret=0,f=1;char ch=getchar(); while(ch&lt;'0'||ch&gt;'9')&#123;if(ch=='-')f=-f;ch=getchar();&#125; while(ch&gt;='0'&amp;&amp;ch&lt;='9')&#123;ret=ret*10+ch-'0';ch=getchar();&#125; return ret*f;&#125;struct SegmentTree&#123; struct Node&#123;int Max,Tag;&#125;Tree[maxn*4]; inline void PushUp(int rt)&#123;Tree[rt].Max=max(Tree[rt*2].Max,Tree[rt*2+1].Max);&#125; inline void PushDown(int rt) &#123; if(Tree[rt].Tag==0) return; Tree[rt*2].Max=Tree[rt].Tag;Tree[rt*2+1].Max=Tree[rt].Tag; Tree[rt*2].Tag=Tree[rt].Tag;Tree[rt*2+1].Tag=Tree[rt].Tag; Tree[rt].Tag=0; &#125; inline void RangeUpdate(int LL,int RR,int num,int L=1,int R=n,int rt=1) &#123; if(LL&lt;=L&amp;&amp;R&lt;=RR)&#123;Tree[rt].Max=Tree[rt].Tag=num;return;&#125; PushDown(rt); int M=(L+R)&gt;&gt;1; if(LL&lt;=M) RangeUpdate(LL,RR,num,L,M,rt*2); if(M&lt;RR) RangeUpdate(LL,RR,num,M+1,R,rt*2+1); PushUp(rt); &#125; inline int RangeQuery(int LL,int RR,int L=1,int R=n,int rt=1) &#123; if(LL&lt;=L&amp;&amp;R&lt;=RR) return Tree[rt].Max; PushDown(rt); int M=(L+R)&gt;&gt;1,ret=0; if(LL&lt;=M) ret=max(ret,RangeQuery(LL,RR,L,M,rt*2)); if(M&lt;RR) ret=max(ret,RangeQuery(LL,RR,M+1,R,rt*2+1)); return ret; &#125; void Build(int* A,int L=1,int R=n,int rt=1) &#123; if(L==R)&#123;Tree[rt].Max=A[L];return;&#125; int M=(L+R)&gt;&gt;1; Build(A,L,M,rt*2); Build(A,M+1,R,rt*2+1); PushUp(rt); &#125;&#125;TA,TB;struct ChairmanTree&#123; int tot,R[maxn]; struct Node&#123;int L,R,Val;&#125;Tree[maxn*4*LOG]; int New()&#123;return ++tot;&#125; void Build(int rt,int L=1,int R=n) &#123; if(L==R) return; if(rt==1) this-&gt;R[0]=1; Tree[rt].L=New(); Tree[rt].R=New(); int M=(L+R)&gt;&gt;1; Build(Tree[rt].L,L,M); Build(Tree[rt].R,M+1,R); &#125; void RangeUpdate(int LL,int RR,int num,int pre,int rt,int L=1,int R=n) &#123; Tree[rt]=Tree[pre]; if(LL&lt;=L&amp;&amp;R&lt;=RR)&#123;Tree[rt].Val=num;return;&#125; int M=(L+R)&gt;&gt;1; if(LL&lt;=M) &#123; Tree[rt].L=New(); RangeUpdate(LL,RR,num,Tree[pre].L,Tree[rt].L,L,M); &#125; if(M&lt;RR) &#123; Tree[rt].R=New(); RangeUpdate(LL,RR,num,Tree[pre].R,Tree[rt].R,M+1,R); &#125; &#125; int Query(int P,int rt,int L=1,int R=n) &#123; if(L==R) return Tree[rt].Val; int M=(L+R)&gt;&gt;1,ret=Tree[rt].Val; if(P&lt;=M) return max(ret,Query(P,Tree[rt].L,L,M)); else return max(ret,Query(P,Tree[rt].R,M+1,R)); &#125;&#125;TC;int main()&#123; freopen("segment.in","r",stdin); freopen("segment.out","w",stdout); n=read();m=read();q=read(); for(int i=1;i&lt;=n;i++) A[i]=read(); TA.Build(A); TC.Build(TC.New()); for(int i=1;i&lt;=m;i++) &#123; QL[i]=read();QR[i]=read(); FL[i][0]=TB.RangeQuery(QL[i],QL[i]); FR[i][0]=TB.RangeQuery(QR[i],QR[i]); TC.R[i]=TC.New(); TC.RangeUpdate(QL[i],QR[i],i,TC.R[i-1],TC.R[i]); TB.RangeUpdate(QL[i],QR[i],i); &#125; for(int i=1;i&lt;=m;i++) &#123; for(int j=1;j&lt;=16;j++) &#123; FL[i][j]=FL[FL[i][j-1]][j-1]; FR[i][j]=FR[FR[i][j-1]][j-1]; &#125; &#125; while(q--) &#123; if(read()==1) &#123; int u=read(),v=read(); TA.RangeUpdate(u,u,v); &#125; else &#123; int L=read(),R=read(),K=read(); int Lm=TC.Query(K,TC.R[R]),Rm=Lm; if(Lm&lt;L) Lm=Rm=0; for(int i=16;i&gt;=0;i--) &#123; if(FL[Lm][i]&gt;=L) Lm=FL[Lm][i]; if(FR[Rm][i]&gt;=L) Rm=FR[Rm][i]; &#125; Lm=QL[Lm];Rm=QR[Rm]; if(Lm&gt;0) printf("%d\n",TA.RangeQuery(Lm,Rm)); else printf("%d\n",TA.RangeQuery(K,K)); &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>倍增</category>
      </categories>
      <tags>
        <tag>主席树</tag>
        <tag>线段树</tag>
        <tag>倍增</tag>
        <tag>可持久化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「网络流24题」魔术球问题]]></title>
    <url>%2F2019%2F03%2F18%2F%E3%80%8C%E7%BD%91%E7%BB%9C%E6%B5%8124%E9%A2%98%E3%80%8D%E9%AD%94%E6%9C%AF%E7%90%83%E9%97%AE%E9%A2%98-Solution%2F</url>
    <content type="text"><![CDATA[纳尼？这是网络流？？？ 传送门洛谷P2765 LOJ6003 题解这题一眼看上去就是一个贪心。 从小到大枚举球的编号，然后从$1$到$n$枚举柱子，找到第一个可以放上去的柱子后就把球放上去，直到放不了位置。 这个贪心看起来很假，但是是对的。 考虑网络流的做法，对于两个球，如果编号加和为完全平方数，那么就从编号小的球往编号大的球建一条边。然后整张图的最小路径覆盖就等于所需柱子的数量。从小到大枚举球的个数，当所需柱子的数量大于$n​$时就上一次的个数就是答案。 考虑贪心和网络流的关系。 其实贪心的过程就是往网络里加点的过程。由于优先考虑加到有球的柱子上，所以就相当于在维护最小路径覆盖是的数量。 所以贪心的做法本质上和网络流的做法是一样的。 代码123456789101112131415161718192021222324252627#include&lt;cmath&gt;#include&lt;cstdio&gt;using namespace std;const int maxn=60;int n,ans,top[maxn],A[maxn][maxn];inline bool check(int x)&#123; int sq=sqrt(x)+1e-10; return sq*sq==x;&#125;int main()&#123; scanf("%d",&amp;n); while(true) &#123; bool suc=false; for(int i=1;i&lt;=n;i++) if(top[i]==0||check(A[i][top[i]]+ans+1)) &#123;ans++;top[i]++;A[i][top[i]]=ans;suc=true;break;&#125; if(!suc) break; &#125; printf("%d\n",ans); for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=top[i];j++) printf("%d%c",A[i][j],j==top[i]?'\n':' '); return 0;&#125;]]></content>
      <categories>
        <category>贪心</category>
      </categories>
      <tags>
        <tag>网络流</tag>
        <tag>贪心</tag>
        <tag>最大流</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「网络流24题」家园]]></title>
    <url>%2F2019%2F03%2F18%2F%E3%80%8C%E7%BD%91%E7%BB%9C%E6%B5%8124%E9%A2%98%E3%80%8D%E5%AE%B6%E5%9B%AD-Solution%2F</url>
    <content type="text"><![CDATA[你必须从四维空间的角度来解这一题… 传送门洛谷P2754 LOJ6015 题解此题的重难点在于建模。 不难发现，如果单单考虑空间，这题的模型还是难以建立。 所以需要将时间也考虑在内，从四维空间的角度来建模。（什么鬼？？？） 设图中的每一个节点都表示某一个时间上的一个星球，比如“第$i$天的第$j$个星球”。 考虑宇宙飞船的飞行，其实就是在四维空间内穿梭，每一次飞行相当于“从第$i$天的第$j$个星球飞往第$i+1$天的第$k$个星球”。 然后建模就很方便了。 对于第$i​$天的星球$j​$，都连向第$i+1​$天的星球$j​$，容量为$+\infty​$。 弄一个源，连向每一天的地球；再由每一天的月球连向一个汇，容量均为为$+\infty$。 对于一次飞行，在起点与终点之间连一条容量为飞船大小的边。 然后最大流就是当前最多能运送的人员数量。 于是乎就可以从小到大枚举答案，每次答案增加时就在网络中加入一套新的节点和边。 当最大流大于等于人数的时候就行了。 由于每次都是在上一次的基础之上继续刷最大流，用Dinic会比较快。（网络流管什么时间复杂度） 如果地球和月球不在一个联通块里，就无解，通过并查集可以解决。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;const int maxn=12000,maxe=31000,inf=0x3F3F3F3F;int n,m,k,S=1,T=2,tot,lnk[maxn],dep[maxn],son[maxe],nxt[maxe],cap[maxe],que[maxn],ans,MF,fa[100];inline int read()&#123; int ret=0,f=1;char ch=getchar(); while(ch&lt;'0'||ch&gt;'9')&#123;if(ch=='-')f=-f;ch=getchar();&#125; while(ch&gt;='0'&amp;&amp;ch&lt;='9')&#123;ret=ret*10+ch-'0';ch=getchar();&#125; return ret*f;&#125;inline void add_e(int x,int y,int z)&#123;tot++;son[tot]=y;cap[tot]=z;nxt[tot]=lnk[x];lnk[x]=tot;&#125;struct SpaceShip&#123;int r,S[20],H;&#125;A[25];inline int getfa(int x)&#123;return fa[x]==x?x:fa[x]=getfa(fa[x]);&#125;inline void Merge(int x,int y)&#123; if(getfa(x)==getfa(y)) return; fa[fa[x]]=fa[y];&#125;inline int id(int x)&#123; if(x==0) return 1; if(x==-1) return 2; return x+2;&#125;int DFS(int now,int lim)&#123; if(lim==0||now==T) return lim; int ret=0; for(int i=lnk[now];i;i=nxt[i]) &#123; if(dep[now]+1==dep[son[i]]) &#123; int tep=DFS(son[i],min(lim,cap[i])); ret+=tep; cap[i]-=tep; cap[(i&amp;1)?i+1:i-1]+=tep; &#125; &#125; return ret;&#125;inline void Dinic()&#123; while(true) &#123; memset(dep,63,sizeof(dep)); int hed=0,til=1; que[1]=S;dep[S]=1; while(hed!=til) &#123; hed++; for(int i=lnk[que[hed]];i;i=nxt[i]) &#123; if(cap[i]&gt;0&amp;&amp;dep[que[hed]]+1&lt;dep[son[i]]) &#123; dep[son[i]]=dep[que[hed]]+1; til++;que[til]=son[i]; &#125; &#125; &#125; if(dep[T]==inf) return; MF+=DFS(S,inf); &#125;&#125;int main()&#123; n=read();m=read();k=read(); for(int i=1;i&lt;=n+2;i++) fa[i]=i; for(int i=1;i&lt;=m;i++) &#123; A[i].H=read();A[i].r=read(); for(int j=1;j&lt;=A[i].r;j++) A[i].S[j]=read(); for(int j=1;j&lt;A[i].r;j++) Merge(id(A[i].S[j]),id(A[i].S[j+1])); &#125; if(getfa(id(0))!=getfa(id(-1)))&#123;printf("%d\n",0);return 0;&#125; add_e(S,3,inf);add_e(3,S,0);add_e(4,T,inf);add_e(T,4,0); while(true) &#123; ans++; add_e(S,ans*(n+2)+3,inf); add_e(ans*(n+2)+3,S,0); add_e(ans*(n+2)+4,T,inf); add_e(T,ans*(n+2)+4,0); for(int i=1;i&lt;=m;i++) &#123; int a=(ans-1)*(n+2)+2+id(A[i].S[(ans-1)%A[i].r+1]),b=ans*(n+2)+2+id(A[i].S[ans%A[i].r+1]); add_e(a,b,A[i].H);add_e(b,a,0); &#125; add_e((ans-1)*(n+2)+3,ans*(n+2)+3,inf); add_e(ans*(n+2)+3,(ans-1)*(n+2)+3,0); add_e((ans-1)*(n+2)+4,ans*(n+2)+4,inf); add_e(ans*(n+2)+4,(ans-1)*(n+2)+4,0); for(int i=1;i&lt;=n;i++) &#123; int a=(ans-1)*(n+2)+2+i+2,b=ans*(n+2)+2+i+2; add_e(a,b,inf);add_e(b,a,0); &#125; Dinic(); if(MF&gt;=k)&#123;printf("%d\n",ans);return 0;&#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>最大流</category>
      </categories>
      <tags>
        <tag>网络流</tag>
        <tag>最大流</tag>
        <tag>Dinic</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「网络流24题」餐巾计划问题]]></title>
    <url>%2F2019%2F03%2F18%2F%E3%80%8C%E7%BD%91%E7%BB%9C%E6%B5%8124%E9%A2%98%E3%80%8D%E9%A4%90%E5%B7%BE%E8%AE%A1%E5%88%92%E9%97%AE%E9%A2%98-Solution%2F</url>
    <content type="text"><![CDATA[又是一道有意思的网络流。 传送门洛谷P1251 LOJ6008 数据输入格式略有不同 题解此题重点在于建模。 首先很显然这题是一个费用流。 但是建模不是很好搞，需要绕几个弯。 首先拆点，将每一天分为早上和下午，早上需要准备好$r_i​$块干净的餐巾，晚上又免费获得了$r_i​$块脏的餐巾。 于是乎可以这样建图： 从源点连出$n$条边（绿的那些）到早上（下面那一排点），容量为$+\infty$，代价为$p$。如果需要买新的餐巾，从这些边流过来。 表示早上的$n$个点再连出来$n$条边到汇，容量为$r_i$，代价为$0$。正常情况下这些变必须满载。表示每天早上都可以提供$r_i$条干净的餐巾。 从源点再连出来$n$条边到每一个表示晚上的节点（上面一排），容量为$r_i$，代价为$0$。表示每天晚上可以免费获得$r_i$条脏餐巾。这些边不一定满载，因为脏的餐巾可以扔掉。 表示每一天晚上的节点再连出来一条边到下一天晚上（红的边），容量为$+\infty​$，代价为$0​$。当天的脏餐巾可以放到下一天再处理。 表示每一天晚上的节点连出一条边到$m$天后的早上（蓝的边），容量为$+ \infty$，代价为$f$。表示送去快洗部。 送去慢洗部的同上。 然后直接刷最小费用最大流即可。 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;typedef long long LL;const int maxn=4005,maxe=24005,inf=0x3F3F3F3F;int N,r[2005],p,m,f,n,s,tot,S,T,lnk[maxn],son[maxe],nxt[maxe],w[maxe],cap[maxe],que[maxn],dist[maxn],lst[maxn],pre[maxn],flow[maxn];bool vis[maxn];LL ans;inline int read()&#123; int ret=0,f=1;char ch=getchar(); while(ch&lt;'0'||ch&gt;'9')&#123;if(ch=='-')f=-f;ch=getchar();&#125; while(ch&gt;='0'&amp;&amp;ch&lt;='9')&#123;ret=ret*10+ch-'0';ch=getchar();&#125; return ret*f;&#125;inline void add_e(int x,int y,int z,int c)&#123; tot++;son[tot]=y;w[tot]=z;cap[tot]=c;nxt[tot]=lnk[x];lnk[x]=tot; tot++;son[tot]=x;w[tot]=-z;cap[tot]=0;nxt[tot]=lnk[y];lnk[y]=tot;&#125;inline void MinCostMaxFlow()&#123; while(true) &#123; memset(dist,63,sizeof(dist)); memset(flow,63,sizeof(flow)); int hed=0,til=1; que[1]=S;dist[S]=0;vis[S]=true;pre[T]=0; while(hed!=til) &#123; hed=(hed+1)%maxn;vis[que[hed]]=false; for(int i=lnk[que[hed]];i;i=nxt[i]) &#123; if(cap[i]&gt;0&amp;&amp;dist[que[hed]]+w[i]&lt;dist[son[i]]) &#123; dist[son[i]]=dist[que[hed]]+w[i]; lst[son[i]]=i; pre[son[i]]=que[hed]; flow[son[i]]=min(flow[que[hed]],cap[i]); if(!vis[son[i]]) &#123; vis[son[i]]=true; til=(til+1)%maxn; que[til]=son[i]; &#125; &#125; &#125; &#125; if(pre[T]==0) return; ans+=(LL)dist[T]*flow[T]; int p=T; while(p!=S) &#123; cap[lst[p]]-=flow[T]; cap[(lst[p]&amp;1)?lst[p]+1:lst[p]-1]+=flow[T]; p=pre[p]; &#125; &#125;&#125;int main()&#123; N=read();S=2*N+1;T=2*N+2; for(int i=1;i&lt;=N;i++) r[i]=read(); p=read();m=read();f=read();n=read();s=read(); for(int i=1;i&lt;=N;i++) add_e(S,i,p,inf); for(int i=1;i&lt;=N;i++) add_e(i,T,0,r[i]); for(int i=1;i&lt;=N;i++) add_e(S,i+N,0,r[i]); for(int i=1;i&lt;N;i++) add_e(i+N,i+N+1,0,inf); for(int i=1;i&lt;=N;i++) &#123; int to1=i+m,to2=i+n; if(to1&lt;=N) add_e(i+N,to1,f,inf); if(to2&lt;=N) add_e(i+N,to2,s,inf); &#125; MinCostMaxFlow(); printf("%lld\n",ans); return 0;&#125;]]></content>
      <categories>
        <category>最小费用最大流</category>
      </categories>
      <tags>
        <tag>网络流</tag>
        <tag>最大流</tag>
        <tag>费用流</tag>
        <tag>最小费用最大流</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「网络流24题」试题库问题]]></title>
    <url>%2F2019%2F03%2F18%2F%E3%80%8C%E7%BD%91%E7%BB%9C%E6%B5%8124%E9%A2%98%E3%80%8D%E8%AF%95%E9%A2%98%E5%BA%93%E9%97%AE%E9%A2%98-Solution%2F</url>
    <content type="text"><![CDATA[又是一道经典题。 传送门洛谷P2763 LOJ6006 题解考虑如何建模。 很显然这是一个二分图。 对于题库中的每一道题，像试卷中的所有可行的空位连边。 比如题库中一道题可以属于$1$类或者$2类$，那么就往试卷中所有$1类$和$2$类的位置连边。 由于一道题只能用在试卷上的一个位置，且试卷上的一个位置也只能放一道题。 所以直接上匈牙利算法求解该二分图的最大匹配即可。 当最大匹配数小于$m$时即为无解。（洛谷上的数据真水，一开始我没考虑无解的情况竟然AC了） 也可以转化成最大流问题，然后用EK、Dinic等求解。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include&lt;cstdio&gt;#include&lt;cstring&gt;using namespace std;const int maxn=1005;int k,st[maxn],grp[maxn],n,m,tot,lnk[maxn],son[maxn*maxn],nxt[maxn*maxn],cp[maxn],len[maxn],A[25][maxn],sum;bool vis[maxn];inline int read()&#123; int ret=0,f=1;char ch=getchar(); while(ch&lt;'0'||ch&gt;'9')&#123;if(ch=='-')f=-f;ch=getchar();&#125; while(ch&gt;='0'&amp;&amp;ch&lt;='9')&#123;ret=ret*10+ch-'0';ch=getchar();&#125; return ret*f;&#125;inline void add_e(int x,int y)&#123;tot++;son[tot]=y;nxt[tot]=lnk[x];lnk[x]=tot;&#125;bool Hungary(int now)&#123; for(int i=lnk[now];i;i=nxt[i]) &#123; if(!vis[son[i]]) &#123; vis[son[i]]=true; if(!cp[son[i]]||Hungary(cp[son[i]])) &#123; cp[son[i]]=now; return true; &#125; &#125; &#125; return false;&#125;int main()&#123; k=read();n=read(); for(int i=1;i&lt;=k;i++) &#123; int cnt=read();st[i]=m+1; for(int j=1;j&lt;=cnt;j++) grp[++m]=i; &#125; for(int i=1;i&lt;=n;i++) &#123; int cnt=read(); for(int j=1;j&lt;=cnt;j++) &#123; int to=read(); for(int k=st[to];grp[k]==to;k++) add_e(i,k); &#125; &#125; for(int i=1;i&lt;=n;i++)&#123;memset(vis,false,n+3);Hungary(i);&#125; for(int i=1;i&lt;=m;i++) if(cp[i]) &#123;len[grp[i]]++;A[grp[i]][len[grp[i]]]=cp[i];&#125; for(int i=1;i&lt;=k;i++) sum+=len[i]; if(sum&lt;m)&#123;printf("No Solution!");return 0;&#125; for(int i=1;i&lt;=k;i++) &#123; printf("%d:",i); for(int j=1;j&lt;=len[i];j++) printf(" %d",A[i][j]); printf("\n"); &#125; return 0;&#125;]]></content>
      <categories>
        <category>二分图最大匹配</category>
      </categories>
      <tags>
        <tag>网络流</tag>
        <tag>最大流</tag>
        <tag>匈牙利算法</tag>
        <tag>二分图</tag>
        <tag>二分图最大匹配</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「网络流24题」运输问题]]></title>
    <url>%2F2019%2F03%2F18%2F%E3%80%8C%E7%BD%91%E7%BB%9C%E6%B5%8124%E9%A2%98%E3%80%8D%E8%BF%90%E8%BE%93%E9%97%AE%E9%A2%98-Solution%2F</url>
    <content type="text"><![CDATA[好经典的模型。 传送门洛谷P4015 LOJ6011 题解乍一看就是一个二分图。 但是要求很明显要求最小费用最大流。 考虑如何建模。 由于每一个仓库只能流出定量的货物，但是又不能把每一个仓库看做源。 所以把所有货物都连到同一个源上，连到第$i​$个仓库的边嘚的容量为$A_i​$，费用为$0​$。 每一家零售店又都连到一个汇上，从第$i$家零售店连出的边的容量为$B_i$，费用为$0$。 中间从仓库到零售店的边就按照题目里的说的那样连，容量为$+\infty$。 然后直接跑最小费用最大流就好了。 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;const int maxn=210,maxm=20205,inf=0x3F3F3F3F;int m,n,S,T,tot,lnk[maxn],son[maxm],nxt[maxm],w[maxm],cap[maxm],que[maxn],lst[maxn],pre[maxn],dist[maxn],flow[maxn],ans;bool vis[maxn];inline int read()&#123; int ret=0,f=1;char ch=getchar(); while(ch&lt;'0'||ch&gt;'9')&#123;if(ch=='-')f=-f;ch=getchar();&#125; while(ch&gt;='0'&amp;&amp;ch&lt;='9')&#123;ret=ret*10+ch-'0';ch=getchar();&#125; return ret*f;&#125;inline void add_e(int x,int y,int z,int c)&#123;tot++;son[tot]=y;w[tot]=z;cap[tot]=c;nxt[tot]=lnk[x];lnk[x]=tot;&#125;inline void MinCostMaxFlow(int flg)&#123; while(true) &#123; if(flg==1) memset(dist,63,sizeof(dist)); else memset(dist,192,sizeof(dist)); memset(flow,63,sizeof(flow)); int hed=0,til=1; que[1]=S;dist[S]=0;vis[S]=true;pre[T]=0; while(hed!=til) &#123; hed=(hed+1)%maxn;vis[que[hed]]=false; for(int i=lnk[que[hed]];i;i=nxt[i]) &#123; if(cap[i]&amp;&amp;((flg==1&amp;&amp;dist[que[hed]]+w[i]&lt;dist[son[i]])||(flg==-1&amp;&amp;dist[que[hed]]+w[i]&gt;dist[son[i]]))) &#123; dist[son[i]]=dist[que[hed]]+w[i]; pre[son[i]]=que[hed]; lst[son[i]]=i; flow[son[i]]=min(flow[que[hed]],cap[i]); if(!vis[son[i]]) &#123; vis[son[i]]=true; til=(til+1)%maxn; que[til]=son[i]; &#125; &#125; &#125; &#125; if(pre[T]==0) return; ans+=flow[T]*dist[T]; int p=T; while(p!=S) &#123; cap[lst[p]]-=flow[T]; cap[(lst[p]&amp;1)?lst[p]+1:lst[p]-1]+=flow[T]; p=pre[p]; &#125; &#125;&#125;int main()&#123; m=read();n=read();S=1;T=m+n+2; for(int i=1;i&lt;=m;i++) &#123; int ai=read(); add_e(S,i+1,0,ai); add_e(i+1,S,0,0); &#125; for(int i=1;i&lt;=n;i++) &#123; int bi=read(); add_e(i+m+1,T,0,bi); add_e(T,i+m+1,0,0); &#125; for(int i=1;i&lt;=m;i++) &#123; for(int j=1;j&lt;=n;j++) &#123; int cij=read(); add_e(i+1,j+m+1,cij,inf); add_e(j+m+1,i+1,-cij,0); &#125; &#125; MinCostMaxFlow(1); printf("%d\n",ans); for(int i=2;i&lt;=tot;i+=2)&#123;cap[i-1]+=cap[i];cap[i]=0;&#125; ans=0; MinCostMaxFlow(-1); printf("%d\n",ans); return 0;&#125;]]></content>
      <categories>
        <category>最小费用最大流</category>
      </categories>
      <tags>
        <tag>网络流</tag>
        <tag>最大流</tag>
        <tag>费用流</tag>
        <tag>最小费用最大流</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「网络流24题」飞行员配对方案问题]]></title>
    <url>%2F2019%2F03%2F18%2F%E3%80%8C%E7%BD%91%E7%BB%9C%E6%B5%8124%E9%A2%98%E3%80%8D%E9%A3%9E%E8%A1%8C%E5%91%98%E9%85%8D%E5%AF%B9%E6%96%B9%E6%A1%88%E9%97%AE%E9%A2%98-Solution%2F</url>
    <content type="text"><![CDATA[没啥好说的，就是二分图的最大匹配 传送门洛谷P2756 LOJ6000 输入输出格式有所不同。 题解就是一个二分图的最大匹配问题啊，裸的一批，直接上匈牙利搞就好了。 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include&lt;cstdio&gt;#include&lt;cstring&gt;using namespace std;const int maxn=105;int n,m,tot,lnk[maxn],son[maxn*maxn],nxt[maxn*maxn],cp[maxn],ans;bool vis[maxn];inline int read()&#123; int ret=0,f=1;char ch=getchar(); while(ch&lt;'0'||ch&gt;'9')&#123;if(ch=='-')f=-f;ch=getchar();&#125; while(ch&gt;='0'&amp;&amp;ch&lt;='9')&#123;ret=ret*10+ch-'0';ch=getchar();&#125; return ret*f;&#125;inline void add_e(int x,int y)&#123;tot++;son[tot]=y;nxt[tot]=lnk[x];lnk[x]=tot;&#125;bool Hungary(int now)&#123; for(int i=lnk[now];i;i=nxt[i]) &#123; if(!vis[son[i]]) &#123; vis[son[i]]=true; if(!cp[son[i]]||Hungary(cp[son[i]])) &#123; cp[son[i]]=now; return true; &#125; &#125; &#125; return false;&#125;int main()&#123; m=read();n=read(); while(true) &#123; int a=read(),b=read()-m; if(a&lt;0&amp;&amp;b&lt;0) break; add_e(b,a); &#125; for(int i=1;i&lt;=n;i++) &#123; memset(vis,false,sizeof(vis)); ans+=Hungary(i); &#125; if(ans==0)&#123;printf("No Solution!\n");return 0;&#125; printf("%d\n",ans); for(int i=1;i&lt;=m;i++) if(cp[i]) printf("%d %d\n",i,cp[i]+m); return 0;&#125;]]></content>
      <categories>
        <category>二分图最大匹配</category>
      </categories>
      <tags>
        <tag>网络流</tag>
        <tag>最大流</tag>
        <tag>二分图最大匹配</tag>
        <tag>匈牙利</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「JSOI2013」丢番图]]></title>
    <url>%2F2019%2F03%2F17%2F%E3%80%8CJSOI2013%E3%80%8D%E4%B8%A2%E7%95%AA%E5%9B%BE-Solution%2F</url>
    <content type="text"><![CDATA[挺好玩的一个数学题。 传送门洛谷P5253 BZOJ4459 题解首先来看看题目中给出的式子，看起来不是很好搞： \frac{1}{x}+\frac{1}{y}=\frac{1}{n}分式不好搞，所以先给它乘开： ny+nx=xy都移到一边： xy-nx-ny=0化为两式相乘的形式： (x-n)(y-n)=n^2不难发现，将$n^2$分解为任意两数相乘的形式时，都有唯一的$x,y$与之对应。 所以$n^2$的因子个数加一除以二就是答案。 但是$n^2$比较大，不好分解质因数。 但是$n$比较小，根据平方的性质，$n^2$的每一个质因子的个数等于$n$每一个质因子个数的两倍。 然后就好搞了。 代码12345678910111213141516171819202122232425262728293031#include&lt;cstdio&gt;using namespace std;typedef long long LL;int cnt,p[665000],tot[665000];LL n,ans;bool vis[10000005];inline void make_p() //欧拉筛素数&#123; vis[0]=vis[1]=true; for(int i=2;i&lt;=10000000;i++) &#123; if(!vis[i])&#123;cnt++;p[cnt]=i;&#125; for(int j=1;j&lt;=cnt&amp;&amp;p[j]*i&lt;=10000000;j++) vis[p[j]*i]=true; &#125;&#125;inline void Solve()&#123; for(int i=1;i&lt;=cnt;i++) while(n%p[i]==0) &#123;n/=p[i];tot[i]++;&#125; //分解质因数 if(n&gt;1)&#123;cnt++;tot[cnt]=1;p[cnt]=n;&#125; ans=1; for(int i=1;i&lt;=cnt;i++) ans*=2*tot[i]+1; //计算因子个数 ans=(ans+1)/2;&#125;int main()&#123; make_p(); scanf("%lld",&amp;n); Solve(); printf("%lld\n",ans); return 0;&#125;]]></content>
      <categories>
        <category>分解质因数</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>欧拉筛</tag>
        <tag>分解质因数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「VK Cup 2015-Round 2」A.Berland Miners /「ZJOI模拟赛」俄刻阿诺斯]]></title>
    <url>%2F2019%2F03%2F15%2F%E3%80%8CVK%20Cup%202015-Round%202%E3%80%8DA.Berland%20Miners%20%E3%80%8CZJOI%E6%A8%A1%E6%8B%9F%E8%B5%9B%E3%80%8D%E4%BF%84%E5%88%BB%E9%98%BF%E8%AF%BA%E6%96%AF-Solution%2F</url>
    <content type="text"><![CDATA[没想到蒟蒻我有生之年竟然也能A上一道VK CUP的题。 传送门原题链接： CF533A 洛谷 数据范围与时有所不同。 下文中的B数组就是棒子的长度。 题解首先考虑没有开凿操作时，如何判断当前的情况是否合法。 不难发现，能否将一根棒子放进一个洞穴里，取决于该洞穴到根中高度最小的节点，设每个节点到根节点路径上高度最小值为$Min[i]​$（可以$O(n)​$构造出来）。对$Min​$和$B​$两个数组分别从小到大排序。 当满足$B[i] \leq Min[j]$时，棒子$i$就可以放进洞穴$j$里。设第$i$根棒子可以放进$num[i]$个洞穴。当满足$\forall i,num[i]\geq i$时，就合法。也就是当且仅当$\min_{i=1}^{n}{(num[i]-i)}\geq 0$时合法。 然后考虑开凿操作。由于不知道开凿哪一个节点，那么$O(n)​$枚举过去。然后二分要开凿的高度。 比如要对图中这个节点进行开凿，那么它的子树中的以该节点为最小值的节点的$Min$值就会改变，所以$Min$数组中就可能需要删去几个原先的值然后加入几个新元素（可能加入二分后的高度或原先到根节点链上的次小值），由于$Min$数组中的每一个元素都对$num$数组中一个连续区间产生贡献，且删除一个元素后一整个区间的值被减1，加入一个元素后一整个区间的值被加1，所以就套个线段树维护全局最小值即可。并且由于每个节点到树根的链上只有一个最小值，所以对于每一个节点，只有一个节点在二分的时候会影响到它，所以时间复杂度为$O(n\log n \log B_i)$。 然后蒟蒻我傻呵呵地卡了半天常数，死活过不去，只好想$O(n\log n)$的做法。 经过ZZK大佬的点拨，我发现其实根本不需要二分。 找到最长的$num_i-B_i$的值小于零的棒子，那么如果有解，就一定要将某个洞穴的高度开凿到这根棒子的长度。 于是乎就可以$O(n)$枚举开凿哪一个洞穴，然后检查一下开凿完之后是否合法就好了。 代码下面是两个log的代码（贼慢）： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;const int maxn=200005,inf=0x3F3F3F3F;int n,m,tot,lnk[maxn],w[maxn],son[maxn*2],nxt[maxn*2],B[maxn],Min[maxn],Sec[maxn],tot2,lnk2[maxn],son2[maxn],nxt2[maxn],L,R=inf,mid;inline int read()&#123; int ret=0,f=1;char ch=getchar(); while(ch&lt;'0'||ch&gt;'9')&#123;if(ch=='-')f=-f;ch=getchar();&#125; while(ch&gt;='0'&amp;&amp;ch&lt;='9')&#123;ret=ret*10+ch-'0';ch=getchar();&#125; return ret*f;&#125;inline void add_e(int x,int y)&#123;tot++;son[tot]=y;nxt[tot]=lnk[x];lnk[x]=tot;&#125;inline void add_e2(int x,int y)&#123;tot2++;son2[tot2]=y;nxt2[tot2]=lnk2[x];lnk2[x]=tot2;&#125;struct SegmentTree&#123; struct Node&#123;int Min,Tag;&#125;Tree[maxn*4]; void PushUp(int rt)&#123;Tree[rt].Min=min(Tree[rt*2].Min,Tree[rt*2+1].Min);&#125; void PushDown(int rt) &#123; if(!Tree[rt].Tag) return; Tree[rt*2].Min+=Tree[rt].Tag;Tree[rt*2+1].Min+=Tree[rt].Tag; Tree[rt*2].Tag+=Tree[rt].Tag;Tree[rt*2+1].Tag+=Tree[rt].Tag; Tree[rt].Tag=0; &#125; void RangeUpdate(int LL,int RR,int delta,int L=1,int R=m,int rt=1) &#123; if(LL&lt;=L&amp;&amp;R&lt;=RR)&#123;Tree[rt].Min+=delta;Tree[rt].Tag+=delta;return;&#125; PushDown(rt); int M=(L+R)/2; if(LL&lt;=M) RangeUpdate(LL,RR,delta,L,M,rt*2); if(M&lt;RR) RangeUpdate(LL,RR,delta,M+1,R,rt*2+1); PushUp(rt); &#125; void Build(int L=1,int R=m,int rt=1) &#123; if(L==R)&#123;Tree[rt].Min=L-m-1;return;&#125; int M=(L+R)/2; Build(L,M,rt*2); Build(M+1,R,rt*2+1); PushUp(rt); &#125; int QueryAll()&#123;return Tree[1].Min;&#125;&#125;T;void Build(int now,int fa,int id,int mi,int se)&#123; if(w[now]&lt;=mi)&#123;se=mi;mi=w[now];id=now;&#125; else if(w[now]&lt;se) se=w[now]; Min[now]=mi;Sec[now]=se;add_e2(id,now); for(int i=lnk[now];i;i=nxt[i]) if(son[i]!=fa) Build(son[i],now,id,mi,se);&#125;inline void Modify(int num,int delta)&#123; static int L,R,mid; L=1;R=m; while(L&lt;=R) &#123; mid=(L+R)/2; B[mid]&lt;=num?L=mid+1:R=mid-1; &#125; if(R&gt;=1) T.RangeUpdate(1,R,delta);&#125;inline bool Check(int now,int fa)&#123; for(int i=lnk2[now];i;i=nxt2[i]) &#123; Modify(Min[now],-1); Modify(min(Sec[son2[i]],w[now]+mid),1); &#125; bool flg=false; if(T.QueryAll()&gt;=0) flg=true; for(int i=lnk2[now];i;i=nxt2[i]) &#123; Modify(Min[now],1); Modify(min(Sec[son2[i]],w[now]+mid),-1); &#125; if(flg) return true; for(int i=lnk[now];i;i=nxt[i]) if(son[i]!=fa&amp;&amp;Check(son[i],now)) return true; return false;&#125;int main()&#123; n=read(); for(int i=1;i&lt;=n;i++) w[i]=read(); for(int i=2;i&lt;=n;i++) &#123; int a=read(),b=read(); add_e(a,b);add_e(b,a); &#125; m=read(); for(int i=1;i&lt;=m;i++) B[i]=read(); sort(B+1,B+1+m); Build(1,0,0,inf,inf); T.Build(); for(int i=1;i&lt;=n;i++) Modify(Min[i],1); while(L&lt;=R) &#123; mid=(L+R)/2; Check(1,0)?R=mid-1:L=mid+1; &#125; printf("%d\n",L&lt;inf?L:-1); return 0;&#125; 一个log的代码（跑的飞快）： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;const int maxn=200005,inf=0x3F3F3F3F;int n,m,tot,lnk[maxn],w[maxn],son[maxn*2],nxt[maxn*2],B[maxn],Min[maxn],Sec[maxn],tot2,lnk2[maxn],son2[maxn],nxt2[maxn],BMax,ans=inf;inline char nc()&#123; static char buf[8388608],*L=buf,*R=buf; return L==R&amp;&amp;(R=(L=buf)+fread(buf,1,8388608,stdin),L==R)?EOF:*L++;&#125;inline int read()&#123; int ret=0,f=1;char ch=nc(); while(ch&lt;'0'||ch&gt;'9')&#123;if(ch=='-')f=-f;ch=nc();&#125; while(ch&gt;='0'&amp;&amp;ch&lt;='9')&#123;ret=ret*10+ch-'0';ch=nc();&#125; return ret*f;&#125;inline void add_e(int x,int y)&#123;tot++;son[tot]=y;nxt[tot]=lnk[x];lnk[x]=tot;&#125;inline void add_e2(int x,int y)&#123;tot2++;son2[tot2]=y;nxt2[tot2]=lnk2[x];lnk2[x]=tot2;&#125;struct SegmentTree&#123; struct Node&#123;int Min,Tag;&#125;Tree[maxn*4]; inline void PushUp(int rt)&#123;Tree[rt].Min=(Tree[rt&lt;&lt;1].Min&lt;Tree[rt&lt;&lt;1|1].Min?Tree[rt&lt;&lt;1].Min:Tree[rt&lt;&lt;1|1].Min);&#125; inline void PushDown(int rt) &#123; if(!Tree[rt].Tag) return; Tree[rt&lt;&lt;1].Min+=Tree[rt].Tag;Tree[rt&lt;&lt;1|1].Min+=Tree[rt].Tag; Tree[rt&lt;&lt;1].Tag+=Tree[rt].Tag;Tree[rt&lt;&lt;1|1].Tag+=Tree[rt].Tag; Tree[rt].Tag=0; &#125; inline void RangeUpdate(int RR,int delta,int L=1,int R=m,int rt=1) &#123; if(RR==m)&#123;Tree[rt].Min+=delta;Tree[rt].Tag+=delta;return;&#125; while(L&lt;=R&amp;&amp;L&lt;=RR) &#123; PushDown(rt); int M=(L+R)&gt;&gt;1; if(M&lt;=RR)&#123;Tree[rt&lt;&lt;1].Min+=delta;Tree[rt&lt;&lt;1].Tag+=delta;L=M+1;rt=rt&lt;&lt;1|1;&#125; else&#123;R=M;rt=rt&lt;&lt;1;&#125; &#125; while(rt&gt;1)&#123;rt&gt;&gt;=1;PushUp(rt);&#125; &#125; void Build(int L=1,int R=m,int rt=1) &#123; if(L==R)&#123;Tree[rt].Min=L-m-1;return;&#125; int M=(L+R)&gt;&gt;1; Build(L,M,rt&lt;&lt;1); Build(M+1,R,rt&lt;&lt;1|1); PushUp(rt); &#125; inline int Query(int pos,int L=1,int R=m,int rt=1) &#123; if(L==R) return Tree[rt].Min; int M=(L+R)&gt;&gt;1; PushDown(rt); if(pos&lt;=M) return Query(pos,L,M,rt&lt;&lt;1); else return Query(pos,M+1,R,rt&lt;&lt;1|1); &#125;&#125;T;void Build(int now,int fa,int id,int mi,int se)&#123; if(w[now]&lt;=mi)&#123;se=mi;mi=w[now];id=now;&#125; else if(w[now]&lt;se) se=w[now]; Min[now]=mi;Sec[now]=se;add_e2(id,now); for(int i=lnk[now];i;i=nxt[i]) if(son[i]!=fa) Build(son[i],now,id,mi,se);&#125;inline void Modify(int num,int delta)&#123; int L=1,R=m,mid; while(L&lt;=R) &#123; mid=(L+R)&gt;&gt;1; B[mid]&lt;=num?L=mid+1:R=mid-1; &#125; if(R&gt;=1) T.RangeUpdate(R,delta);&#125;inline void Solve(int now,int fa)&#123; if(w[now]&lt;BMax&amp;&amp;BMax-w[now]&lt;ans) &#123; for(int i=lnk2[now];i;i=nxt2[i]) &#123; Modify(Min[now],-1); Modify(min(Sec[son2[i]],BMax),1); &#125; if(T.Tree[1].Min&gt;=0) ans=BMax-w[now]; for(int i=lnk2[now];i;i=nxt2[i]) &#123; Modify(Min[now],1); Modify(min(Sec[son2[i]],BMax),-1); &#125; &#125; for(int i=lnk[now];i;i=nxt[i]) if(son[i]!=fa) Solve(son[i],now);&#125;int main()&#123; n=read(); for(int i=1;i&lt;=n;i++) w[i]=read(); for(int i=2;i&lt;=n;i++) &#123; int a=read(),b=read(); add_e(a,b);add_e(b,a); &#125; m=read(); for(int i=1;i&lt;=m;i++) B[i]=read(); sort(B+1,B+1+m); Build(1,0,0,inf,inf); T.Build(); for(int i=1;i&lt;=n;i++) Modify(Min[i],1); for(int i=m;i;i--) if(T.Query(i)&lt;0) &#123;BMax=B[i];break;&#125; if(BMax) Solve(1,0); else ans=0; printf("%d\n",ans==inf?-1:ans); return 0;&#125;]]></content>
      <categories>
        <category>线段树</category>
      </categories>
      <tags>
        <tag>二分</tag>
        <tag>线段树</tag>
        <tag>单调性</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「ZJOI模拟赛」Bug级的存在]]></title>
    <url>%2F2019%2F03%2F14%2F%E3%80%8CZJOI%E6%A8%A1%E6%8B%9F%E8%B5%9B%E3%80%8DBug%E7%BA%A7%E7%9A%84%E5%AD%98%E5%9C%A8-Solution%2F</url>
    <content type="text"><![CDATA[什么毒瘤题目QwQ。 传送门原题链接： CF407E 洛谷 题解首先一个区间满足条件，必须要有整个区间内的$A_i$模$d​$同余，并且没有相同元素，暂时先不考虑需要补上的数的个数。 考虑从左往右枚举右端点$head$，再用一个指针$tail$来控制合法的左端点所在区间，如果$[head,tail]$这个区间不合法，那么就让$tail++$，此时如果左端点$L$在$[head,tail]$区间内构成的所有区间$[L,head]$都合法。而且很显然当$head$变大时，$tail$单调不将。 然后对于左端点$L (L\in[tail,head])$，考虑需要补上的元素个数是否会超过$k$，推一下式子，移一下项，发现当满足以下式子时的左端点$L​$就是合法的： \frac{\max_{i=L}^{R}{a_i}-\min_{i=L}^{R}{a_i}}{d}+L\leq R+k此时当右端点确定时，式子的右边也是确定的。也就是说，我们要找一个满足上式的且最靠左的左端点$L$。可以通过一些办法维护每个左端点$L$到当前枚举到的右端点区间内的最大值和最小值。 当右端点向右移动的时候，考虑维护两个单调栈，一个单调增，一个单调降，就拿单调增的来举例。由单调栈的性质可以得出，区间$[stack[top-1]+1,stack[top]]$内的每一个元素的值都大于$stack[top]$的值，所以当栈顶要被弹出时，将区间$[stack[top-1]+1,stack[top]]$内的每一个左端点的最小值都减去当前值与栈顶的差值。最大值同理。可以用线段树来维护。 然后就可以在线段树上二分来找满足条件的最靠左的左端点，如果当前遍历到的节点的左节点所管辖的区间内中有满足条件的节点就往左走，否则就往右走。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120#include&lt;map&gt;#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;typedef long long LL;const int maxn=200005;const LL inf=0x3F3F3F3F3F3F3F3Fll;int n,k,d,A[maxn],Area[maxn],num,hed,til,top1,stk1[maxn],top2,stk2[maxn],ans,ansL,ansR;map&lt;int,int&gt; H;inline int read()&#123; int ret=0,f=1;char ch=getchar(); while(ch&lt;'0'||ch&gt;'9')&#123;if(ch=='-')f=-f;ch=getchar();&#125; while(ch&gt;='0'&amp;&amp;ch&lt;='9')&#123;ret=ret*10+ch-'0';ch=getchar();&#125; return ret*f;&#125;struct SegmentTree&#123; struct Node&#123;LL Mi,Ma,TagMi,TagMa,Val;&#125;Tree[maxn*4]; void PushUp(int rt) &#123; Tree[rt].Mi=min(Tree[rt*2].Mi,Tree[rt*2+1].Mi); Tree[rt].Ma=max(Tree[rt*2].Ma,Tree[rt*2+1].Ma); Tree[rt].Val=min(Tree[rt*2].Val,Tree[rt*2+1].Val); &#125; void PushDown(int rt) &#123; Tree[rt*2].Mi+=Tree[rt].TagMi;Tree[rt*2].TagMi+=Tree[rt].TagMi;Tree[rt*2].Val-=Tree[rt].TagMi; Tree[rt*2].Ma+=Tree[rt].TagMa;Tree[rt*2].TagMa+=Tree[rt].TagMa;Tree[rt*2].Val+=Tree[rt].TagMa; Tree[rt*2+1].Mi+=Tree[rt].TagMi;Tree[rt*2+1].TagMi+=Tree[rt].TagMi;Tree[rt*2+1].Val-=Tree[rt].TagMi; Tree[rt*2+1].Ma+=Tree[rt].TagMa;Tree[rt*2+1].TagMa+=Tree[rt].TagMa;Tree[rt*2+1].Val+=Tree[rt].TagMa; Tree[rt].TagMi=Tree[rt].TagMa=0; &#125; void RangeUpdateMin(int LL,int RR,int delta,int L=1,int R=n,int rt=1) &#123; if(LL&lt;=L&amp;&amp;R&lt;=RR)&#123;Tree[rt].Mi+=delta;Tree[rt].TagMi+=delta;Tree[rt].Val-=delta;return;&#125; PushDown(rt); int M=(L+R)/2; if(LL&lt;=M) RangeUpdateMin(LL,RR,delta,L,M,rt*2); if(M&lt;RR) RangeUpdateMin(LL,RR,delta,M+1,R,rt*2+1); PushUp(rt); &#125; void RangeUpdateMax(int LL,int RR,int delta,int L=1,int R=n,int rt=1) &#123; if(LL&lt;=L&amp;&amp;R&lt;=RR)&#123;Tree[rt].Ma+=delta;Tree[rt].TagMa+=delta;Tree[rt].Val+=delta;return;&#125; PushDown(rt); int M=(L+R)/2; if(LL&lt;=M) RangeUpdateMax(LL,RR,delta,L,M,rt*2); if(M&lt;RR) RangeUpdateMax(LL,RR,delta,M+1,R,rt*2+1); PushUp(rt); &#125; void Delete(int P,int L=1,int R=n,int rt=1) &#123; if(L==P&amp;&amp;R==P)&#123;Tree[rt].Val=inf;return;&#125; PushDown(rt); int M=(L+R)/2; if(P&lt;=M) Delete(P,L,M,rt*2); if(M&lt;P) Delete(P,M+1,R,rt*2+1); PushUp(rt); &#125; void Build(int L=1,int R=n,int rt=1) &#123; if(L==R)&#123;Tree[rt].Val=L;Tree[rt].Mi=Tree[rt].Ma=A[L];return;&#125; int M=(L+R)/2; Build(L,M,rt*2); Build(M+1,R,rt*2+1); PushUp(rt); &#125; LL Query(int num,int L=1,int R=n,int rt=1) &#123; if(L==R) return L; int M=(L+R)/2; PushDown(rt); if(Tree[rt*2].Val&lt;=num) return Query(num,L,M,rt*2); else return Query(num,M+1,R,rt*2+1); &#125;&#125;T;int main()&#123; n=read();k=read();d=read(); for(int i=1;i&lt;=n;i++) A[i]=read()+1000000000; if(!d) &#123; for(int i=1,j;i&lt;=n;) &#123; j=i; while(j&lt;n&amp;&amp;A[j+1]==A[i]) j++; if(j-i+1&gt;ans)&#123;ans=j-i+1;ansL=i;ansR=j;&#125; i=j+1; &#125; printf("%d %d\n",ansL,ansR); return 0; &#125; for(int i=1;i&lt;=n;) &#123; int j=i;Area[i]=i; while(j&lt;n&amp;&amp;A[j+1]%d==A[i]%d)&#123;j++;Area[j]=i;&#125; i=j+1; &#125; til=1;T.Build(); while(hed&lt;n) &#123; hed++;H[A[hed]]++; while(H[A[hed]]&gt;1||Area[hed]!=Area[til])&#123;T.Delete(til);H[A[til]]--;til++;&#125; while(top1&gt;0&amp;&amp;A[hed]&lt;=A[stk1[top1]]) &#123; T.RangeUpdateMin(stk1[top1-1]+1,stk1[top1],A[hed]/d-A[stk1[top1]]/d); top1--; &#125; stk1[++top1]=hed; while(top2&gt;0&amp;&amp;A[hed]&gt;=A[stk2[top2]]) &#123; T.RangeUpdateMax(stk2[top2-1]+1,stk2[top2],A[hed]/d-A[stk2[top2]]/d); top2--; &#125; stk2[++top2]=hed; LL L=T.Query(hed+k); if(L&gt;=til&amp;&amp;hed-L+1&gt;ans)&#123;ans=hed-L+1;ansL=L;ansR=hed;&#125; &#125; printf("%d %d\n",ansL,ansR); return 0;&#125;]]></content>
      <categories>
        <category>单调栈</category>
      </categories>
      <tags>
        <tag>线段树</tag>
        <tag>单调栈</tag>
        <tag>等差序列</tag>
        <tag>同余</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「HAOI2006」均分数据]]></title>
    <url>%2F2019%2F03%2F08%2F%E3%80%8CHAOI2006%E3%80%8D%E5%9D%87%E5%88%86%E6%95%B0%E6%8D%AE-Solution%2F</url>
    <content type="text"><![CDATA[今天是国际劳动妇女节，各位妇女们有没有去劳动啊QwQ？反正我没去 传送门洛谷P2503 BZOJ2428 题解数据范围好小啊，看起来像是状压DP或者搜索之类的。蒟蒻我选择了模拟退火+贪心。 先考虑贪心，我们从$1$到$n$遍历整个序列，每次就把当前的元素丢到加和最小的那一组里。 显然光光这样贪心是肯定不行的，但是这样得到的答案还是比较优的。考虑怎样改进。 不难发现，如果遍历序列的顺序会影响最后的答案，那么可以考虑直接random_shuffle，打乱个比如$10^5​$次的，很大概率上就能刷到最优解了。 但是总感觉直接random_shuffle不太靠谱啊（不过貌似也能AC），但是蒟蒻我选择了模拟退火，感觉起来会靠谱一些（其实到底是不是更靠谱我也不知道，但是我想练一下模拟退火，所以就这样写了）。 每次随机拎出来两个元素交换，然后再计算当前答案就可以了。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;const int maxn=25,maxm=10;const double delta=0.991;int n,m,A[maxn];double X[maxn],avg,ret,ans;inline double Calc() //计算当前答案&#123; ret=avg=0; memset(X,0,sizeof(X)); for(int i=1;i&lt;=n;i++) &#123; int mi=1; for(int j=1;j&lt;=m;j++) if(X[j]&lt;X[mi]) mi=j; X[mi]+=A[i]; &#125; for(int i=1;i&lt;=m;i++) avg+=X[i]; avg/=m; for(int i=1;i&lt;=m;i++) ret+=(X[i]-avg)*(X[i]-avg); return sqrt(ret/m);&#125;inline void SA(double T)&#123; while(T&gt;1e-12) &#123; int a=rand()%n+1,b=rand()%n+1; while(a==b)&#123;a=rand()%n+1;b=rand()%n+1;&#125;//rand出来两个是一样的概率挺大的，这样可以提升效率 swap(A[a],A[b]); double now=Calc(); if(now&lt;ans) ans=now; else if(exp((ans-now)/T)&lt;(double)rand()/RAND_MAX) swap(A[a],A[b]); T*=delta; &#125;&#125;int main()&#123; srand(20030909); //黄霖的生日，种子什么的选大佬的生日肯定不会错的 scanf("%d%d",&amp;n,&amp;m); for(int i=1;i&lt;=n;i++) scanf("%d",&amp;A[i]); sort(A+1,A+1+n); ans=Calc(); for(int i=1;i&lt;=100;i++) SA(19630217); //退火100次又不会WA并且还比较快，求稳的话可以多来几次 printf("%.2lf\n",ans); return 0;&#125;]]></content>
      <categories>
        <category>模拟退火</category>
      </categories>
      <tags>
        <tag>随机算法</tag>
        <tag>贪心</tag>
        <tag>模拟退火</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「TJOI2010」分金币]]></title>
    <url>%2F2019%2F03%2F08%2F%E3%80%8CTJOI2010%E3%80%8D%E5%88%86%E9%87%91%E5%B8%81-Solution%2F</url>
    <content type="text"><![CDATA[又是一道模拟退火的题QwQ。 传送门洛谷P3878 题解感觉这样的题目还是比较套路的QwQ。 还是先考虑一个看起来比较靠谱的贪心，比如考虑按顺序遍历这些金币，如果当前两堆个数相等的话谁小就先丢到谁哪儿，否则就丢到个数少的一堆里。 此时决策的方案还是与遍历的顺序有关，所以上模拟退火确定一个最优的顺序，然后就好了QwQ。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;algorithm&gt;using namespace std;const int maxn=35;const double delta=0.998;int T,n,v[maxn],ans;inline int read()&#123; int ret=0,f=1;char ch=getchar(); while(ch&lt;'0'||ch&gt;'9')&#123;if(ch=='-')f=-f;ch=getchar();&#125; while(ch&gt;='0'&amp;&amp;ch&lt;='9')&#123;ret=ret*10+ch-'0';ch=getchar();&#125; return ret*f;&#125;inline int ABS(int x)&#123;return x&lt;0?-x:x;&#125;inline int Calc()&#123; int sum1=0,sum2=0,cnt1=0,cnt2=0; for(int i=1;i&lt;=n;i++) &#123; if(cnt1==cnt2) &#123; if(sum1&lt;sum2)&#123;sum1+=v[i];cnt1++;&#125; else&#123;sum2+=v[i];cnt2++;&#125; &#125; else &#123; if(cnt1&lt;cnt2)&#123;sum1+=v[i];cnt1++;&#125; else&#123;sum2+=v[i];cnt2++;&#125; &#125; &#125; return ABS(sum1-sum2);&#125;inline void SA(double T)&#123; while(T&gt;1e-12) &#123; int a=rand()%n+1,b=rand()%n+1; while(a==b)&#123;a=rand()%n+1;b=rand()%n+1;&#125; swap(v[a],v[b]); int now=Calc(); if(now&lt;ans) ans=now; else if(exp((ans-now)/T)&lt;(double)rand()/RAND_MAX) swap(v[a],v[b]); T*=delta; &#125;&#125;int main()&#123; srand(20030909); T=read(); while(T--) &#123; n=read(); for(int i=1;i&lt;=n;i++) v[i]=read(); ans=Calc(); if(n&gt;1) for(int i=1;i&lt;=15;i++) SA(19630217); printf("%d\n",ans); &#125; return 0;&#125;]]></content>
      <categories>
        <category>模拟退火</category>
      </categories>
      <tags>
        <tag>随机算法</tag>
        <tag>贪心</tag>
        <tag>模拟退火</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「HNOI2008」遥远的行星]]></title>
    <url>%2F2019%2F03%2F07%2F%E3%80%8CHNOI2008%E3%80%8D%E9%81%A5%E8%BF%9C%E7%9A%84%E8%A1%8C%E6%98%9F-Solution%2F</url>
    <content type="text"><![CDATA[又是一道玄学的题目QwQ。 传送门洛谷P3198 BZOJ1011 题解首先要一眼看到这题的重点：结果的相对误差不超过$5\%$即可。 所以考虑非完美算法。 首先，对于第$i​$个行星，对它有贡献的星球区间是$[1,\lfloor A\cdot i\rfloor]​$。设$R=\lfloor A\cdot i\rfloor​$。 然后再设一个阈值$S$比如$S=n^{0.4}$。 接下来的操作类似于分块，把区间$[1,R]$分成若干个块，每个块的大小为$S$，剩下的零头暴力搞，对于每一个完整的块，设这个块为$[a,b]$，那么这个块的贡献约等于 \frac{M[i]\cdot\sum_{j=a}^{b}M[j]}{i-\frac{a+b}{2}}这个式子可以构造前缀和来求。 把所有块的贡献加起来，注意下细节，就能过了QwQ。 代码12345678910111213141516171819202122232425262728#include&lt;cmath&gt;#include&lt;cstdio&gt;using namespace std;typedef long long LL;const int maxn=100005;int n,S,M[maxn];double A,ans;LL sum[maxn];inline int read()&#123; int ret=0,f=1;char ch=getchar(); while(ch&lt;'0'||ch&gt;'9')&#123;if(ch=='-')f=-f;ch=getchar();&#125; while(ch&gt;='0'&amp;&amp;ch&lt;='9')&#123;ret=ret*10+ch-'0';ch=getchar();&#125; return ret*f;&#125;int main()&#123; n=read();scanf("%lf",&amp;A);S=pow(n,0.38)+1e-10; for(int i=1;i&lt;=n;i++)&#123;M[i]=read();sum[i]=sum[i-1]+M[i];&#125; //构造前缀和 for(int i=1;i&lt;=n;i++) &#123; int R=i*A+1e-10,j;ans=0; //加上1e-10是为了防止精度损失 for(j=1;j+S&lt;=R;j+=S) //处理整块 ans+=(double)M[i]*(sum[j+S-1]-sum[j-1])/(i-(double)(2*j+S-1)/2); for(;j&lt;=R;j++) //处理零头 ans+=(double)M[i]*M[j]/(i-j); printf("%lf\n",ans); &#125; return 0;&#125;]]></content>
      <categories>
        <category>分块</category>
      </categories>
      <tags>
        <tag>分块</tag>
        <tag>概率</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「USACO」Haywire]]></title>
    <url>%2F2019%2F03%2F07%2F%E3%80%8CUSACO%E3%80%8DHaywire-Solution%2F</url>
    <content type="text"><![CDATA[什么神仙题目。蒟蒻我前前后后一共交了13次，才终于把这个退火搞懂了QwQ。 传送门洛谷P2210 题解蒟蒻我之前一直对模拟退火保持一个懵逼状态，今天是差不多把大概原理终于理清楚了QwQ。 其实基本上就是个退火的板子，但是蒟蒻我一直搞不清楚计算接受较差答案的概率。 一般来说，计算改成的式子是这样的： exp((now-ans)/T)&gt;rand()/RAND_MAX 其中now表示当前的答案，ans表示已知最优答案，也有可能是ans-now，总之应该是个负数。满足上式，则接受较差的答案。 其中$exp(x)$表示$e^x$，函数图像大概是这样的： 所以与当前最优答案差距越大，温度越低，$exp()$的值就越小，接受这个较差的答案的概率就越小。 还有，调参的时候，降温系数，停止退火的温度下限，温度初始值，退火的次数要一起调，尤其是退火的次数，多退几次还是很有必要的。种子可以用神仙学长ZZK的生日20020222。 代码1234567891011121314151617181920212223242526272829303132333435363738394041#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;algorithm&gt;using namespace std;const double delta=0.99;int n,fri[20][5],Q[20],ans;inline int Calc()&#123; int ret=0; for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=3;j++) if(Q[i]&gt;Q[fri[i][j]]) ret+=Q[i]-Q[fri[i][j]]; return ret;&#125;inline void SA(double T)&#123; while(T&gt;1e-12) &#123; int a=rand()%n+1,b=rand()%n+1; while(a==b)&#123;a=rand()%n+1;b=rand()%n+1;&#125; swap(Q[a],Q[b]); int now=Calc(); if(now&lt;ans) ans=now; else if(exp((ans-now)/T)&lt;(double)rand()/RAND_MAX) swap(Q[a],Q[b]); T*=delta; &#125;&#125;int main()&#123; srand(19260817); scanf("%d",&amp;n); for(int i=1;i&lt;=n;i++) scanf("%d%d%d",&amp;fri[i][1],&amp;fri[i][2],&amp;fri[i][3]); for(int i=1;i&lt;=n;i++) Q[i]=i; ans=Calc(); for(int i=1;i&lt;=500;i++) SA(19260817); printf("%d\n",ans); return 0;&#125;]]></content>
      <categories>
        <category>模拟退火</category>
      </categories>
      <tags>
        <tag>随机算法</tag>
        <tag>模拟退火</tag>
        <tag>搜索</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「YNOI2016」这是我自己的发明]]></title>
    <url>%2F2019%2F03%2F06%2F%E3%80%8CYNOI2016%E3%80%8D%E8%BF%99%E6%98%AF%E6%88%91%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8F%91%E6%98%8E-Solution%2F</url>
    <content type="text"><![CDATA[震惊！我妻由乃当上了发明家！！！ 传送门洛谷P4689 BZOJ4940 题解又是一道由乃OI的毒瘤题QwQ。 前置技能，这题的简化版：SNOI2017 一个简单的询问。 做完上面一题，不难发现，只要爬到树上做这题就行了。 先一巴掌把树拍扁按照DFS序将树化成一个序列，这样每一颗子树对应着序列上的一段区间，然后就和之前那一题没什么区别了。 但是！！！竟然有换根这种操作。 不过不难发现，其实换根的操作就是假的。 先设当前的根为$rt$，询问子树的节点为$x$，不管怎样，我们就认为根始终是节点$1$。 然后又这么几种情况： $x=rt​$ 此时询问的就是整棵树。 $LCA(x,rt)\neq x$ 此时查询的就是当$1$为根时$x$的子树。 $LCA(x,rt)=x​$ 此时查询整棵树除去rt到x路径上离x最近的一个节点（就是图中好几个箭头指的那个点）的子树。可以拆成两个序列解决。那个节点可以通过倍增找到。 拆分成若干个序列之后，直接莫队即可。 还有记得要离散，权值是比较大的。我就因为没看数据范围，忘记离散，结果崩掉1个点QwQ 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798#include&lt;map&gt;#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;typedef long long LL;const int maxn=100005,maxm=500005;int n,m,q,rt,idx,tot,lnk[maxn],son[maxn*2],nxt[maxn*2],St[maxn],En[maxn],father[maxn][20],dep[maxn],A[maxn],B[maxn],S,Area[maxn],num,cnt1[maxn],cnt2[maxn],p1,p2;LL ans[maxm],now; //要开的东西实在太多，写的好丑QwQmap&lt;int,int&gt; hsh;inline int read()&#123; int ret=0,f=1;char ch=getchar(); while(ch&lt;'0'||ch&gt;'9')&#123;if(ch=='-')f=-f;ch=getchar();&#125; while(ch&gt;='0'&amp;&amp;ch&lt;='9')&#123;ret=ret*10+ch-'0';ch=getchar();&#125; return ret*f;&#125;inline void add_e(int x,int y)&#123;tot++;son[tot]=y;nxt[tot]=lnk[x];lnk[x]=tot;&#125;void Build(int now,int fa) //以节点1作为根节点初始化&#123; father[now][0]=fa;dep[now]=dep[fa]+1;idx++;A[idx]=B[now];St[now]=idx; for(int i=1;i&lt;=16;i++) father[now][i]=father[father[now][i-1]][i-1]; for(int i=lnk[now];i;i=nxt[i]) if(son[i]!=fa) Build(son[i],now); En[now]=idx;&#125;int LCA(int u,int v) //倍增LCA&#123; if(dep[u]&lt;dep[v]) swap(u,v); for(int i=16;i&gt;=0;i--) if(dep[father[u][i]]&gt;=dep[v]) u=father[u][i]; for(int i=16;i&gt;=0;i--) if(father[u][i]!=father[v][i])&#123;u=father[u][i];v=father[v][i];&#125; if(u!=v) return father[u][0]; return u;&#125;int GetSon(int u,int v)&#123; if(dep[u]&lt;dep[v]) swap(u,v); for(int i=16;i&gt;=0;i--) if(dep[father[u][i]]&gt;dep[v]) u=father[u][i]; return u;&#125;struct Interval&#123; int R1,R2,f,id; void Init()&#123;if(R1&gt;R2)swap(R1,R2);&#125; bool operator &lt; (const Interval&amp; b)const&#123;return Area[R1]&lt;Area[b.R1]||(Area[R1]==Area[b.R1]&amp;&amp;((Area[R1]&amp;1)?R2&lt;b.R2:R2&gt;b.R2));&#125;&#125;Q[maxm*16]; //注意一个询问最左可以拆成16个区间inline void Add(int L1,int R1,int L2,int R2,int id)&#123; num++;Q[num].R1=R1;Q[num].R2=R2;Q[num].f=1;Q[num].Init();Q[num].id=id; if(L1&gt;1)&#123;num++;Q[num].R1=L1-1;Q[num].R2=R2;Q[num].f=-1;Q[num].Init();Q[num].id=id;&#125; if(L2&gt;1)&#123;num++;Q[num].R1=R1;Q[num].R2=L2-1;Q[num].f=-1;Q[num].Init();Q[num].id=id;&#125; if(L1&gt;1&amp;&amp;L2&gt;1)&#123;num++;Q[num].R1=L1-1;Q[num].R2=L2-1;Q[num].f=1;Q[num].Init();Q[num].id=id;&#125;&#125;int main()&#123; n=read();m=read();S=sqrt(n)+1e-10;rt=1; for(int i=1;i&lt;=n;i++) A[i]=B[i]=read(); sort(B+1,B+1+n);int tep=0; for(int i=1;i&lt;=n;i++) if(!hsh[B[i]]) hsh[B[i]]=++tep; for(int i=1;i&lt;=n;i++) B[i]=hsh[A[i]]; //离散 for(int i=1;i&lt;=n;i++) Area[i]=(i-1)/S+1; for(int i=1;i&lt;n;i++) &#123; int a=read(),b=read(); add_e(a,b);add_e(b,a); &#125; Build(1,0); for(int i=1;i&lt;=m;i++) &#123; if(read()==1) rt=read(); else &#123; int x=read(),y=read();q++; int len1=0,L1[3],R1[3],len2=0,L2[3],R2[3]; if(x==rt)&#123;len1++;L1[len1]=1;R1[len1]=n;&#125; else if(LCA(x,rt)!=x)&#123;len1++;L1[len1]=St[x];R1[len1]=En[x];&#125; else&#123;int v=GetSon(rt,x);len1++;L1[len1]=1;R1[len1]=St[v]-1;if(En[v]&lt;n)&#123;len1++;L1[len1]=En[v]+1;R1[len1]=n;&#125;&#125; if(y==rt)&#123;len2++;L2[len2]=1;R2[len2]=n;&#125; else if(LCA(y,rt)!=y)&#123;len2++;L2[len2]=St[y];R2[len2]=En[y];&#125; else&#123;int v=GetSon(rt,y);len2++;L2[len2]=1;R2[len2]=St[v]-1;if(En[v]&lt;n)&#123;len2++;L2[len2]=En[v]+1;R2[len2]=n;&#125;&#125; for(int j=1;j&lt;=len1;j++) for(int k=1;k&lt;=len2;k++) Add(L1[j],R1[j],L2[k],R2[k],q); //拆成区间上莫队 &#125; &#125; sort(Q+1,Q+1+num); //莫队 for(int i=1;i&lt;=num;i++) &#123; while(p2&lt;Q[i].R2)&#123;p2++;cnt2[A[p2]]++;now+=cnt1[A[p2]];&#125; while(p1&gt;Q[i].R1)&#123;cnt1[A[p1]]--;now-=cnt2[A[p1]];p1--;&#125; while(p2&gt;Q[i].R2)&#123;cnt2[A[p2]]--;now-=cnt1[A[p2]];p2--;&#125; while(p1&lt;Q[i].R1)&#123;p1++;cnt1[A[p1]]++;now+=cnt2[A[p1]];&#125; ans[Q[i].id]+=now*Q[i].f; &#125; for(int i=1;i&lt;=q;i++) printf("%lld\n",ans[i]); return 0;&#125;]]></content>
      <categories>
        <category>莫队</category>
      </categories>
      <tags>
        <tag>LCA</tag>
        <tag>莫队</tag>
        <tag>DFS序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「IOI2011」Race]]></title>
    <url>%2F2019%2F03%2F05%2F%E3%80%8CIOI2011%E3%80%8DRace-Solution%2F</url>
    <content type="text"><![CDATA[又是一个赤裸裸的点分治QwQ。 传送门洛谷P4149 BZOJ2599 题解基本上就是点分治的裸题QwQ。 每次找重心，然后刷出当前处理的子树中每个点到重心的距离和经过的边的数量，直接搞就行了，记得要刷边数的最小值，还要判无解。没啥好说的QwQ。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include&lt;cstdio&gt;#include&lt;cstring&gt;using namespace std;const int maxn=200005,maxk=1000005,inf=0x3F3F3F3F;int n,K,tot,lnk[maxn],son[maxn*2],w[maxn*2],nxt[maxn*2],sum,siz[maxn],maxp[maxn],rt,dist[maxn],cnt[maxn],num,Q[maxn][2],ans=inf,jud[maxk],que[maxn];bool vis[maxn];inline int read()&#123; int ret=0,f=1;char ch=getchar(); while(ch&lt;'0'||ch&gt;'9')&#123;if(ch=='-')f=-f;ch=getchar();&#125; while(ch&gt;='0'&amp;&amp;ch&lt;='9')&#123;ret=ret*10+ch-'0';ch=getchar();&#125; return ret*f;&#125;inline void add_e(int x,int y,int z)&#123;tot++;son[tot]=y;w[tot]=z;nxt[tot]=lnk[x];lnk[x]=tot;&#125;void GetRoot(int now,int fa)&#123; siz[now]=1;maxp[now]=0; for(int i=lnk[now];i;i=nxt[i]) &#123; if(vis[son[i]]||son[i]==fa) continue; GetRoot(son[i],now);siz[now]+=siz[son[i]]; if(siz[son[i]]&gt;maxp[now]) maxp[now]=siz[son[i]]; &#125; if(sum-siz[now]&gt;maxp[now]) maxp[now]=sum-siz[now]; if(maxp[now]&lt;maxp[rt]) rt=now;&#125;void GetDist(int now,int fa)&#123; if(dist[now]&gt;K||cnt[now]&gt;ans) return; num++;Q[num][0]=dist[now];Q[num][1]=cnt[now]; for(int i=lnk[now];i;i=nxt[i]) if(!vis[son[i]]&amp;&amp;son[i]!=fa) &#123;dist[son[i]]=dist[now]+w[i];cnt[son[i]]=cnt[now]+1;GetDist(son[i],now);&#125;&#125;void Solve(int now)&#123; int len=1;que[1]=0;vis[now]=true;jud[0]=0; for(int i=lnk[now];i;i=nxt[i]) &#123; if(vis[son[i]]) continue; num=0;dist[son[i]]=w[i];cnt[son[i]]=1;GetDist(son[i],0); for(int j=1;j&lt;=num;j++) if(Q[j][1]+jud[K-Q[j][0]]&lt;ans) ans=Q[j][1]+jud[K-Q[j][0]]; for(int j=1;j&lt;=num;j++) &#123; if(Q[j][1]&lt;jud[Q[j][0]]) jud[Q[j][0]]=Q[j][1]; que[++len]=Q[j][0]; &#125; &#125; for(int i=1;i&lt;=len;i++) jud[que[i]]=inf; for(int i=lnk[now];i;i=nxt[i]) if(!vis[son[i]]) &#123;sum=siz[son[i]];rt=0;GetRoot(son[i],0);Solve(rt);&#125;&#125;int main()&#123; n=read();K=read(); for(int i=1;i&lt;n;i++) &#123; int a=read()+1,b=read()+1,c=read(); add_e(a,b,c);add_e(b,a,c); &#125; memset(jud,63,sizeof(jud)); maxp[0]=sum=n;GetRoot(1,0);Solve(rt); printf("%d\n",ans==inf?-1:ans); return 0;&#125;]]></content>
      <categories>
        <category>点分治</category>
      </categories>
      <tags>
        <tag>点分治</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「洛谷P4886」快递员]]></title>
    <url>%2F2019%2F03%2F05%2F%E3%80%8C%E6%B4%9B%E8%B0%B7P4886%E3%80%8D%E5%BF%AB%E9%80%92%E5%91%98-Solution%2F</url>
    <content type="text"><![CDATA[完了…没高中读了QwQ，我要去打工送快递！！！QwQ 传送门洛谷P4886 题解这题其实还是挺好玩的。 首先随便钦定一个点，临时作为快递中心 。 然后可以$O(n)$计算出每一组点对到快递中心的距离和。设点对到快递中心最大距离和为$Max$，可能有多个点对到快递中心的距离和都是$Max$那么就把它们都存下来。 如果当前的快递中心在任意一组距离最大的点对之间最短路径上，那么答案就是$Max$不可能再小了。 如果有任意两组点对，一组在当前快递中心的一棵子树里，另一组在另一棵子树里，那么答案同样也无法更小。 否则答案最优时的快递中心就有可能在当前唯一一棵有点对的子树中，那么就取这棵子树的重心作为临时快递中心，然后递归。由于每次取的都是重心，所以只会递归$\log n$层，总时间复杂度为$O(n\log n)​$。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include&lt;cstdio&gt;#include&lt;cstdlib&gt;using namespace std;const int maxn=100005;int n,m,u[maxn],v[maxn],tot,lnk[maxn],son[maxn*2],w[maxn*2],nxt[maxn*2],sum,siz[maxn],maxp[maxn],rt,sub[maxn],dist[maxn],que[maxn],ans=1000000000;bool vis[maxn];inline int read()&#123; int ret=0,f=1;char ch=getchar(); while(ch&lt;'0'||ch&gt;'9')&#123;if(ch=='-')f=-f;ch=getchar();&#125; while(ch&gt;='0'&amp;&amp;ch&lt;='9')&#123;ret=ret*10+ch-'0';ch=getchar();&#125; return ret*f;&#125;inline void add_e(int x,int y,int z)&#123;tot++;son[tot]=y;w[tot]=z;nxt[tot]=lnk[x];lnk[x]=tot;&#125;void GetRoot(int now,int fa) //找重心&#123; siz[now]=1;maxp[now]=0; for(int i=lnk[now];i;i=nxt[i]) &#123; if(vis[son[i]]||son[i]==fa) continue; GetRoot(son[i],now);siz[now]+=siz[son[i]]; if(siz[son[i]]&gt;maxp[now]) maxp[now]=siz[son[i]]; &#125; if(sum-siz[now]&gt;maxp[now]) maxp[now]=sum-siz[now]; if(maxp[now]&lt;maxp[rt]) rt=now;&#125;void GetDist(int now,int fa,int st)&#123; sub[now]=st; for(int i=lnk[now];i;i=nxt[i]) if(son[i]!=fa) &#123;dist[son[i]]=dist[now]+w[i];GetDist(son[i],now,st);&#125;&#125;inline void Print()&#123;printf("%d\n",ans);exit(0);&#125; //输出答案void Solve(int now)&#123; if(vis[now]) Print(); vis[now]=true;dist[now]=0; for(int i=lnk[now];i;i=nxt[i]) &#123;dist[son[i]]=w[i];GetDist(son[i],now,son[i]);&#125; //先暴力计算距离 int Max=0,len=0,las=0; for(int i=1;i&lt;=m;i++) &#123; if(dist[u[i]]+dist[v[i]]&gt;Max)&#123;len=1;que[len]=i;Max=dist[u[i]]+dist[v[i]];&#125; else if(dist[u[i]]+dist[v[i]]==Max) que[++len]=i; //刷最大距离和 &#125; if(Max&lt;ans) ans=Max; for(int i=1;i&lt;=len;i++) &#123; if(sub[u[que[i]]]!=sub[v[que[i]]]) Print(); //分情况考虑答案 if(!las) las=sub[u[que[i]]]; if(sub[u[que[i]]]!=las) Print(); &#125; rt=0;sum=siz[las];GetRoot(las,0);Solve(rt); //递归解决&#125;int main()&#123; n=read();m=read(); for(int i=1;i&lt;n;i++) &#123; int a=read(),b=read(),c=read(); add_e(a,b,c);add_e(b,a,c); &#125; for(int i=1;i&lt;=m;i++)&#123;u[i]=read();v[i]=read();&#125; sum=maxp[0]=n;GetRoot(1,0);Solve(rt); Print(); return 0;&#125;]]></content>
      <categories>
        <category>点分治</category>
      </categories>
      <tags>
        <tag>点分治</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「AHOI2001」多项式乘法]]></title>
    <url>%2F2019%2F03%2F04%2F%E3%80%8CAHOI2001%E3%80%8D%E5%A4%9A%E9%A1%B9%E5%BC%8F%E4%B9%98%E6%B3%95-Solution%2F</url>
    <content type="text"><![CDATA[来水一发大模拟QwQ。 传送门洛谷P2553 题解好久没写这种处理字符串的大模拟了QwQ。 这题每个多项式的长度都很短，系数也很小，所以直接$O(n^2)$的暴力搞过去就行了。 数据范围大一点的话FFT即可。 注意可能有空格。 注意可能在一行中可能包含一个不完整的表达式（可能没有”*”或者”()”），注意应该什么也不要输出，也要注意不要RE或者怎么样了。 总而言之还是挺好写的QwQ。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include&lt;cstdio&gt;#include&lt;cstring&gt;using namespace std;int len,a1[50],a2[50],ans[100];char exp[1000];int main()&#123; while(gets(exp),exp[0]) &#123; len=strlen(exp);memset(a1,0,sizeof(a1));memset(a2,0,sizeof(a2));memset(ans,0,sizeof(ans)); int i=1; while(exp[i]!=')'&amp;&amp;i&lt;len) &#123; int x=0,z=0; while(exp[i]&lt;'0'||exp[i]&gt;'9') i++; x=exp[i]-'0'; if('0'&lt;=exp[i+1]&amp;&amp;exp[i+1]&lt;='9')&#123;i++;x=x*10+exp[i]-'0';&#125; i++; if(exp[i]=='a') &#123; i++;i++;z=exp[i]-'0'; if('0'&lt;=exp[i+1]&amp;&amp;exp[i+1]&lt;='9')&#123;i++;z=z*10+exp[i]-'0';&#125; i++; &#125; a1[z]+=x; &#125; i++; while(exp[i]!=')'&amp;&amp;i&lt;len) &#123; int x=0,z=0; while(exp[i]&lt;'0'||exp[i]&gt;'9') i++; x=exp[i]-'0'; if('0'&lt;=exp[i+1]&amp;&amp;exp[i+1]&lt;='9')&#123;i++;x=x*10+exp[i]-'0';&#125; i++; if(exp[i]=='a') &#123; i++;i++;z=exp[i]-'0'; if('0'&lt;=exp[i+1]&amp;&amp;exp[i+1]&lt;='9')&#123;i++;z=z*10+exp[i]-'0';&#125; i++; &#125; a2[z]+=x; &#125; for(int i=0;i&lt;=30;i++) for(int j=0;j&lt;=30;j++) ans[i+j]+=a1[i]*a2[j]; bool first=false; for(int j=60;j&gt;=0;j--) &#123; if(!ans[j]) continue; if(first) putchar('+'); else first=true; if(j&gt;0) printf("%da^%d",ans[j],j); else printf("%d",ans[j]); &#125; putchar('\n'); memset(exp,0,sizeof(exp)); &#125; return 0;&#125;]]></content>
      <categories>
        <category>模拟</category>
      </categories>
      <tags>
        <tag>多项式乘法</tag>
        <tag>FFT</tag>
        <tag>模拟</tag>
        <tag>字符串处理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「SNOI2017」一个简单的询问]]></title>
    <url>%2F2019%2F03%2F04%2F%E3%80%8CSNOI2017%E3%80%8D%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E8%AF%A2%E9%97%AE-Solution%2F</url>
    <content type="text"><![CDATA[嗯哼？这不是赤裸裸的莫队吗QwQ？ 传送门BZOJ5016 题解首先拐一道弯，令$F(L1,R1,L2,R2)=\sum_{x=0}^{\infty}{get(L1,R1,x)\cdot get(L2,R2,x)}​$。 那么根据容斥的原理，可以得到$F(L1,R1,L2,R2)=F(1,R1,1,R2)-F(1,L1,1,R2)-F(1,R1,1,L2)+F(1,L1,1,L2)$。 那么就把一个询问先拆成四个询问。 然后只要想办法求出$F(1,x,1,y)$。裸的莫队啊啊啊！！！注意细节即可。 然后就没有然后了。 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;typedef long long LL;const int maxn=50005;int n,q,A[maxn],S,Area[maxn],tot,cnt1[maxn],cnt2[maxn],p1,p2;LL ans[maxn],now;inline int read()&#123; int ret=0,f=1;char ch=getchar(); while(ch&lt;'0'||ch&gt;'9')&#123;if(ch=='-')f=-f;ch=getchar();&#125; while(ch&gt;='0'&amp;&amp;ch&lt;='9')&#123;ret=ret*10+ch-'0';ch=getchar();&#125; return ret*f;&#125;struct Interval&#123; int R1,R2,f,id; void Init()&#123;if(R1&gt;R2)swap(R1,R2);&#125; bool operator &lt; (const Interval&amp; b)const&#123;return Area[R1]&lt;Area[b.R1]||(Area[R1]==Area[b.R1]&amp;&amp;((Area[R1]&amp;1)?R2&lt;b.R2:R2&gt;b.R2));&#125;&#125;Q[maxn*4];int main()&#123; n=read();S=sqrt(n)+1e-10; for(int i=1;i&lt;=n;i++) A[i]=read(); for(int i=1;i&lt;=n;i++) Area[i]=(i-1)/S+1; q=read(); for(int i=1;i&lt;=q;i++) &#123; int L1=read(),R1=read(),L2=read(),R2=read(); tot++;Q[tot].R1=R1;Q[tot].R2=R2;Q[tot].f=1;Q[tot].Init();Q[tot].id=i; tot++;Q[tot].R1=L1-1;Q[tot].R2=R2;Q[tot].f=-1;Q[tot].Init();Q[tot].id=i; tot++;Q[tot].R1=R1;Q[tot].R2=L2-1;Q[tot].f=-1;Q[tot].Init();Q[tot].id=i; tot++;Q[tot].R1=L1-1;Q[tot].R2=L2-1;Q[tot].f=1;Q[tot].Init();Q[tot].id=i; &#125; sort(Q+1,Q+1+tot); for(int i=1;i&lt;=tot;i++) &#123; while(p2&lt;Q[i].R2)&#123;p2++;cnt2[A[p2]]++;now+=cnt1[A[p2]];&#125; while(p1&gt;Q[i].R1)&#123;cnt1[A[p1]]--;now-=cnt2[A[p1]];p1--;&#125; while(p2&gt;Q[i].R2)&#123;cnt2[A[p2]]--;now-=cnt1[A[p2]];p2--;&#125; while(p1&lt;Q[i].R1)&#123;p1++;cnt1[A[p1]]++;now+=cnt2[A[p1]];&#125; ans[Q[i].id]+=now*Q[i].f; &#125; for(int i=1;i&lt;=q;i++) printf("%lld\n",ans[i]); return 0;&#125;]]></content>
      <categories>
        <category>莫队</category>
      </categories>
      <tags>
        <tag>莫队</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「ZJOI2019模拟赛 十二」紫苑]]></title>
    <url>%2F2019%2F03%2F04%2F%E3%80%8CZJOI2019%E6%A8%A1%E6%8B%9F%E8%B5%9B%20%E5%8D%81%E4%BA%8C%E3%80%8D%E7%B4%AB%E8%8B%91-Solution%2F</url>
    <content type="text"><![CDATA[震惊！XZY竟然在ZJOI模拟赛时公然写代码造数据卡掉各种排序算法… 传送门原题来自UOJ，但各个子任务的分值略有不同。 UOJ83 题解这题是真的毒瘤QwQ。 Subtask #1观察一下计数排序法的代码，发现它在排序开始之前先把数组从$0$到$max(A_i)$清了一遍，那么只要给一个数，并且足够大即可。简直就是送分。 Subtask #2从第二个子任务开始，题目渐渐地毒瘤了起来。 首先你需要知道对于冒泡排序法，交换元素的次数等于逆序对的个数。 然后仔细分析代码，计算出冒泡排序法和计数排序法的具体复杂度，然后发现，只要构造一个长度为$1990​$的升序排列，然后选出$521​$对元素两两交换即可。此时冒泡刚好不会T，选排刚好T掉。 Subtask #3继续分析代码。发现快排没有随机化，那么就让每次选的基准数都是整个序列的最大或者最小值，然后手动二分得到$n​$的值应该为$1984​$。 Subtask #4对于冒泡排序法来说，一个降序的排列逆序对数最多，最容易T，但是对计数排序法就很不友好了。 然后再随便写几个数列试试看，发现类似于这样的序列很不错：2 2 2 1 1 1 0 0 0，手动多试几次值域和每个值出现的次数，就把这个点搞掉了。 Subtask #5和子任务4一样是要卡冒泡，同样构造一个类似的序列，然后手动胡乱修改几个数的出现次数，然后就过了。（大雾 Subtask #6woc最恶心的一个点，一定要好好分析一下随机排序法的代码。 首先发现随机函数是手写的，想到这里应该有玄机，赶紧仔细看看。 发现seed、RNG_a、RNG_b的初值都是一个奇怪的数字，在10进制下看不出啥玩意，打开计算器，转到二进制下看看。 然后发现RNG_a在二进制下是$1100101101010000000000001$，RNG_b是$100110100100000000000001$，后面都有一长串$0$和一个$1$。并且打乱数组时都是取随机值然后模$n$，然后想到如果$n$是$2$的正整数次幂的话就会有一些奇妙的性质：上面两个数字在模$n$意义下都等于$1​$。 考虑到最好应该让该程序打乱一遍数组就排序好，并且题目中时间上限给的十分准确，枚举$n$，发现$n=4096$时计时器的值刚好是$43026$，由此根据出题人心理学套路断定$n$一定等于$4096$。 然后再仔细观察，发现如果seed是一个确定的值，原序列各元素之间的大小关系可以确定。于是乎再枚举seed，发现$seed=2048$（模$n$的意义下）时倒推得到的原序列使得快排T掉了。可得$seed=2048$。 但是由于seed是一个根据输入序列生成的值，所以在确定原序列各元素之间的大小关系的情况下，关键在于如何构造一个合法的序列使得$seed=2048$。 所以可以先构造一个各元素值都尽量小的排列$A$，然后将所有大于$A[n]$的元素的值都加上个比如$10^6$，然后就可枚举$A[n]$，一点点把它的值变大，直到$seed=2048$。这样最后一个点就构造好了。 然后恭喜你获得荣誉勋章：毒瘤出题人。 代码Subtask #11//没有QwQ，手造 Subtask #21234567891011121314#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;int n,A[2000];int main()&#123; n=1990; printf("%d\n",n); for(int i=1;i&lt;=n;i++) A[i]=i; for(int i=1;i&lt;=521;i++) swap(A[i*2],A[i*2-1]); for(int i=1;i&lt;=n;i++) printf("%d%c",A[i],i==n?'\n':' '); return 0;&#125; Subtask #3123456789101112131415161718#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;int n,A[5000],counter;int main()&#123; n=1984; printf("%d\n",n); for(int i=1;i&lt;=n;i++) A[i]=i; for(int i=1;i&lt;=n;i++) &#123; int j=(i+1)/2; swap(A[i],A[j]); &#125; for(int i=1;i&lt;=n;i++) printf("%d%c",A[i],i==n?'\n':' '); return 0;&#125; Subtask #4其实后面少了几个0，可以手动补上，不补也没关系。 12345678910#include&lt;cstdio&gt;using namespace std;int main()&#123; printf("%d\n",1012); for(int i=30;i&gt;=0;i--) for(int j=1;j&lt;=32;j++) printf("%d ",i); return 0;&#125; Subtask #5用这个代码生成数据后还有手动乱搞一下QwQ。 12345678910#include&lt;cstdio&gt;using namespace std;int main()&#123; printf("%d\n",1015); for(int i=27;i&gt;=0;i--) for(int j=1;j&lt;=40;j++) printf("%d ",i); return 0;&#125; Subtask #612345678910111213141516171819202122232425262728293031323334#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;int n,A[5000],counter;unsigned int seed,RNG_a,RNG_b;void RNG_init()&#123; counter++; seed = 2166136261u; counter++; RNG_a = 26648577u; counter++; RNG_b = 10108929u;&#125;int main()&#123; freopen("Shion.in","wb",stdout); n=4096;seed=2166136261u; printf("%d\n",n); for(int i=1;i&lt;=n;i++) A[i]=i; for(int i=n;i;i--) &#123; int j=(i+2048)%4096+1; swap(A[i],A[j]); &#125; for(int i=1;i&lt;=n;i++) if(A[i]&gt;A[n]) A[i]+=1000000; for(int i=1;i&lt;n;i++) seed=(seed*16777619u)^A[i]; while(((seed*16777619u)^A[n])%(unsigned int)4096!=(unsigned int)2048) A[n]++; for(int i=1;i&lt;=n;i++) printf("%d%c",A[i],i==n?'\n':' '); return 0;&#125; 答案戳我呀^w^ 终于写完了QwQ，出题人真是毒瘤QwQ。]]></content>
      <categories>
        <category>分析代码</category>
      </categories>
      <tags>
        <tag>非传统题</tag>
        <tag>提交答案题</tag>
        <tag>排序</tag>
        <tag>分析代码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「YNOI2016」掉进兔子洞]]></title>
    <url>%2F2019%2F02%2F25%2F%E3%80%8CYNOI2016%E3%80%8D%E6%8E%89%E8%BF%9B%E5%85%94%E5%AD%90%E6%B4%9E-Solution%2F</url>
    <content type="text"><![CDATA[震惊！我妻由乃掉进了兔子洞里… 传送门洛谷P4688 BZOJ4939 题解这题再YNOI里应该算简单的吧，毕竟代码挺短的。 根据题意，要求的答案就是三个区间的长度和减去三个区间的交集长度的三倍。 因为要求交集，自然而然想到用bitset。只要上莫队求出每个询问的三个区间的bitset，求交集即可。 但是这个交集还不是那么好求，要拐个弯QwQ。 先对原序列进行离散化，定义离散化之后的$A_i$表示原序列中有多少个数小于原$A_i$。 然后考虑一个区间，现在加入一个元素，怎么维护bitset。由于存在相同元素，所以bitset上可能有好多位都是留给与当前元素相同的元素的，那么就需要从第$A_i$个位置从左往右找到第一个空位把新元素按上去，这样进行&amp;运算的时候就没有问题了，找位置的时候事先记一下当前区间每个值已经出现多少次了，就能O(1)找到。 这样进行&amp;运算就没有什么问题了。 还有就是由于直接开$10^5$个长度为$10^5$的bitset会MLE，所以把所有询问分三次处理就好了。 感觉莫队+bitset的题常数都不小，蒟蒻我一般不吸氧过不了QwQ。 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include&lt;map&gt;#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;bitset&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;const int maxn=100005,maxm=34005;int n,tot,m,A[maxn],B[maxn],sum,S,Area[maxn],ans[maxn],cnt[maxn];map&lt;int,int&gt; C;bitset&lt;maxn&gt; col[maxm],tep;bool vis[maxm];inline int read()&#123; int ret=0,f=1;char ch=getchar(); while(ch&lt;'0'||ch&gt;'9')&#123;if(ch=='-')f=-f;ch=getchar();&#125; while(ch&gt;='0'&amp;&amp;ch&lt;='9')&#123;ret=ret*10+ch-'0';ch=getchar();&#125; return ret*f;&#125;struct Interval&#123; int L,R,id; bool operator &lt; (const Interval&amp; b)const&#123;return Area[L]&lt;Area[b.L]||(Area[L]==Area[b.L]&amp;&amp;((Area[L]&amp;1)?Area[R]&lt;Area[b.R]:Area[R]&gt;Area[b.R]));&#125;&#125;Q[maxm*3];inline void inc(int x)&#123;tep[x+cnt[x]]=1;cnt[x]++;&#125;inline void dec(int x)&#123;cnt[x]--;tep[x+cnt[x]]=0;&#125;inline void Solve()&#123; int num=0,L=1,R=1;tep[A[1]]=1;cnt[A[1]]++; for(int i=1;i&lt;=m&amp;&amp;i&lt;=34000;i++) &#123; num++;Q[num].L=read();Q[num].R=read();Q[num].id=i;ans[i]+=Q[num].R-Q[num].L+1; num++;Q[num].L=read();Q[num].R=read();Q[num].id=i;ans[i]+=Q[num].R-Q[num].L+1; num++;Q[num].L=read();Q[num].R=read();Q[num].id=i;ans[i]+=Q[num].R-Q[num].L+1; &#125; sort(Q+1,Q+1+num); for(int i=1;i&lt;=num;i++) &#123; while(L&gt;Q[i].L) inc(A[--L]); while(R&lt;Q[i].R) inc(A[++R]); while(L&lt;Q[i].L) dec(A[L++]); while(R&gt;Q[i].R) dec(A[R--]); if(vis[Q[i].id]) col[Q[i].id]&amp;=tep; else&#123;col[Q[i].id]=tep;vis[Q[i].id]=true;&#125; &#125; for(int i=1;i&lt;=m&amp;&amp;i&lt;=34000;i++) &#123; ans[i]-=col[i].count()*3; printf("%d\n",ans[i]); &#125; m-=34000;memset(ans,0,sizeof(ans));memset(cnt,0,sizeof(cnt));memset(vis,0,sizeof(vis));tep.reset();&#125;int main()&#123; n=read();m=read();S=sqrt(n)+1e-10; for(int i=1;i&lt;=n;i++) A[i]=B[i]=read(); for(int i=1;i&lt;=n;i++) Area[i]=(i-1)/S+1; sort(B+1,B+1+n); for(int i=1,j;i&lt;=n;i=j+1) &#123; j=i; while(j&lt;n&amp;&amp;B[j+1]==B[i]) j++; C[B[i]]=sum;sum+=j-i+1; &#125; for(int i=1;i&lt;=n;i++) A[i]=C[A[i]]; while(m&gt;0) Solve(); return 0;&#125;]]></content>
      <categories>
        <category>莫队</category>
      </categories>
      <tags>
        <tag>莫队</tag>
        <tag>bitset</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「ZJOI2019模拟赛 六」硬币]]></title>
    <url>%2F2019%2F02%2F18%2F%E3%80%8CZJOI2019%E6%A8%A1%E6%8B%9F%E8%B5%9B%20%E5%85%AD%E3%80%8D%E7%A1%AC%E5%B8%81-Solution%2F</url>
    <content type="text"><![CDATA[模拟赛爆炸祭QwQ… 题面硬币coin.cpp coin.in/.out 时间限制:1s 空间限制:512M 题目描述KK有一枚硬币，他想做如下实验： 他会不停抛掷这枚硬币，并且记录下每次硬币是哪面朝上，当出现连续两次都是正面朝上时，就停止实验。 设总共抛掷了 $M$ 次后停止实验（即第 $M$ 次和第 $M-1$ 次都是正面朝上，而之前没有出现过连续两次正面朝上），令 $P(n)$ 表示 $M$ 是 $n$ 的倍数的概率。 比如 $P(2)={3\over 5}，P(3)={9\over 31}$，可以发现 $P(n)$ 总是可以表示成一个分数。 现在KK想知道 $P(n)$ 对 $10^9+9$ 取模后的结果。 输入格式一行，一个数 $n$。 输出格式一行，表示 $P(n)$ 对 $10^9+9$ 取模后的结果。 样例数据input1 13 output1 1548387102 input2 1100 output2 1618264982 input3 1100000000000000000 output3 1346869049 数据规模与约定对于 $30\%$ 的数据 $n\le 100$ 对于 $50\%​$ 的数据 $n\le 1000000​$ 对于 $80\%​$ 的数据 $n\le 1000000000​$ 对于 $100\%​$ 的数据 $n\le 10^{18}​$ 小贴士对于 ${n\over m}​$ 及一个质数 $p​$，${n\over m}​$ 在模 $p​$ 意义下等于 $n\times m^{p-2}​$ $\sqrt{5}​$在模$10^9+9​$的意义下的值为$383008016​$。 题解这道题基本上就没有部分分，做出来了就100，否则就0分。然而蒟蒻我还是太菜了，所以我必定属于后者。然后这场模拟赛我就光荣地爆炸了QwQ 这题推起来其实挺烦的，但是在省选题里面好像应该算简单了的吧。看来我还是太菜了。 废话不多说，接下来马上进入愉快的推式子环节。woc哪里愉快了 设$C(i)$表示抛了$i$次硬币，没有连续两次正面朝上的方案数。 令$1$表示正面朝上，$0$表示反面朝上，那么$C(i)$也就是长度为$i$的不存在连续两个$1$的01串的个数。 假设我们已近求出了$C(i-1)​$和$C(i-2)​$，现在考虑如何来计算出$C(i)​$的值。比如$i=3​$。 长度为$2$的串一共有$4$个，分别是00、01、10、11，其中串11是不合法的，其余的都是合法的。把这些串复制两份，一份前面加0，一次前面加1，这样就能得到长度为3的8个01串。 如果再前面加0，那么原来合法的串依然合法，原来不合法的串依然不合法。所以可以先把$C(i-1)$先累加到$C(i)$上。 如果在前面加1，那么原来以1开头的串就都不合法了，原来以0开头的串合法性不变。原来一共有$C(i-2)$个0开头的合法串，这些串同样也要累加到$C(i)$上。 所以就有递推式：$C(i)=C(i-1)+C(i-2)​$，其中$C(1)=2,C(2)=3​$。所以这就是一个错了2位的斐波那契数列。 再设$F(i)$表示抛了$i$次硬币，恰好结束的概率。 那么就有$F(i)=\frac{C(i-3)}{2^{i-3}}*\frac{1}{8}​$。因为当且仅当前$i-3​$次都要合法，第$i-2​$反面朝上，最后两次都正面朝上才会停止。 所以 F(i)=\frac{C(i-3)}{2^{i-3}}*\frac{1}{8}=\frac{C(i-3)}{2^i}=\frac{Fib(i-1)}{2^i}再根据题意，可得 P(n)=F(n)+F(2n)+\cdots+F(\infty n)=\sum_{i=1}^{\infty}{\frac{Fib(in-1)}{2^{in}}}其中斐波那契数列有一个通项公式 Fib(n)=\frac{\sqrt{5}}{5}((\frac{1+\sqrt{5}}{2})^n-(\frac{1-\sqrt{5}}{2})^n)再设 \alpha=\frac{1+\sqrt{5}}{2},\beta=\frac{1-\sqrt{5}}{2}所以 P(n)=\sum_{i=1}^{\infty}{\frac{Fib(in-1)}{2^{in}}}= \sum_{i=1}^{\infty}{\frac{\sqrt{5}}{5}\cdot\frac{\alpha^{in-1}-\beta^{in-1}}{2^{in}}}然后发现上面那个式子并不好处理，再化简一下 \sum_{i=1}^{\infty}{\frac{\sqrt{5}}{5}\cdot\frac{\alpha^{in-1}-\beta^{in-1}}{2^{in}}}= \frac{\sqrt{5}}{5}\sum_{i=1}^{\infty}{\frac{\alpha^{in-1}}{2^{in}}}-\frac{\sqrt{5}}{5}\sum_{i=1}^{\infty}{\frac{\beta^{in-1}}{2^{in}}}= \frac{\sum_{i=1}^{\infty}{\frac{\alpha^{in-1}}{2^{in}}}- \sum_{i=1}^{\infty}{\frac{\beta^{in-1}}{2^{in}}}}{\sqrt{5}}回想一下，发现带有无穷的式子可以通过等比数列还搞，于是想办法把上式搞出等比数列 上式=\frac{\frac{1}{\alpha}\sum_{i=1}^{\infty}{\frac{\alpha^{in}}{2^{in}}}- \frac{1}{\beta}\sum_{i=1}^{\infty}{\frac{\beta^{in}}{2^{in}}}}{\sqrt{5}}然后$\sum{i=1}^{\infty}{\frac{\alpha^{in}}{2^{in}}}​$就是等比数列，想办法把它的值算出来，后面的$\sum{i=1}^{\infty}{\frac{\beta^{in}}{2^{in}}}​$也一样的。 \sum_{i=1}^{\infty}{\frac{\alpha^{in}}{2^{in}}}=\sum_{i=1}^{\infty}{(\frac{\alpha^{n}}{2^{n}})^{i}}\\ 设q=\frac{\alpha^{n}}{2^{n}}\\ 设S=\sum_{i=1}^{\infty}{(\frac{\alpha^{n}}{2^{n}})^{i}}=q^1+q^2+q^3+\cdots+q^{\infty}\\ 则qS=q^2+q^3+q^4+\cdots+q^{\infty}\\ 故(q-1)S=-q\\ S=\frac{q}{1-q}求出$S$之后再代回原始中就能求出$P(n)$的值了。 终于写完了QwQ… 代码推了一长串，代码是真的短QwQ 123456789101112131415161718192021222324252627282930#include&lt;cmath&gt;#include&lt;cstdio&gt;using namespace std;typedef long long LL;const LL TT=1000000009,sqrt5=383008016,inv2=500000005;LL n;LL QP(LL a,LL b)&#123; LL ret=1,w=a; while(b) &#123; if(b&amp;1) ret=ret*w%TT; w=w*w%TT;b&gt;&gt;=1; &#125; return ret;&#125;LL Sum(LL q)&#123; q=QP(q,n); return q*QP((1-q+TT)%TT,TT-2)%TT;&#125;int main()&#123; freopen("coin.in","r",stdin); freopen("coin.out","w",stdout); scanf("%lld",&amp;n); LL alpha=(1+sqrt5)*inv2%TT,beta=(1+TT-sqrt5)*inv2%TT; printf("%lld\n",(QP(sqrt5,TT-2)*(QP(alpha,TT-2)*Sum(alpha*inv2%TT)%TT-QP(beta,TT-2)*Sum(beta*inv2%TT)%TT)%TT+TT)%TT); return 0; &#125;]]></content>
      <categories>
        <category>概率数学</category>
      </categories>
      <tags>
        <tag>概率</tag>
        <tag>数学</tag>
        <tag>无限</tag>
        <tag>逆元</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「洛谷P1654/BZOJ4318」OSU！]]></title>
    <url>%2F2019%2F02%2F15%2F%E3%80%8C%E6%B4%9B%E8%B0%B7P1654%20BZOJ4318%E3%80%8DOSU!-Solution%2F</url>
    <content type="text"><![CDATA[这题代码是真的短，但我就是做不来QwQ… 传送门洛谷P1654 BZOJ4318 题解感觉这个期望DP真的挺有趣的。 设$X1_i$表示以$i$为结尾的连续$1$串的期望长度，$X2_i$表示 以$i$为结尾的连续$1$串长度的平方的期望，$F_i$表示$i$次操作后的期望得分。 首先来看看$X1$该怎么递推，第$i$次操作有$Pi$的概率成功，贡献为$X1{i-1}+1$；还有$1-P_i$的概率失败，贡献为$0$，所以 X1_i=(X1_{i-1}+1) \cdot Pi+0 \cdot(1-P_i)=(X1_{i-1}+1) \cdot Pi再来看$X2$，根据完全平方公式$(x+1)^2=x^2+2x+1$，同理可得 X2_i=(X2_{i-1}+2\cdot X1_{i-1}+1) \cdot P_i再根据完全立方公式$(x+1)^3=x^3+3x^2+3x+1$，同理可得 F_i=(F_{i-1}+3 \cdot X2_{i-1}+3 \cdot X1_{i-1}+1) \cdot P_i+F_{i-1}(1-P_i)\\ =F_{i-1}+(3 \cdot X2_{i-1}+3 \cdot X1_{i-1}+1) \cdot P_i然后$F_n$就是答案 。 然后，然后就…没了。 代码真的很短哎QwQ。 1234567891011121314151617#include&lt;cstdio&gt;using namespace std;const int maxn=100005;int n;double P[maxn],X1[maxn],X2[maxn],F[maxn];int main()&#123; scanf("%d",&amp;n); for(int i=1;i&lt;=n;i++) &#123; scanf("%lf",&amp;P[i]); X1[i]=(X1[i-1]+1)*P[i]; X2[i]=(X2[i-1]+2*X1[i-1]+1)*P[i]; F[i]=F[i-1]+(3*X2[i-1]+3*X1[i-1]+1)*P[i]; &#125; printf("%.1lf\n",F[n]); return 0;&#125;]]></content>
      <categories>
        <category>期望DP</category>
      </categories>
      <tags>
        <tag>概率</tag>
        <tag>期望DP</tag>
        <tag>期望</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「AHOI2017/HNOI2017」大佬]]></title>
    <url>%2F2019%2F02%2F13%2F%E3%80%8CAHOI2017%20HNOI2017%E3%80%8D%E5%A4%A7%E4%BD%AC-Solution%2F</url>
    <content type="text"><![CDATA[这题面，生动形象，饶有趣味，interesting！出题人呢？ 传送门洛谷P3724 BZOJ4828 题解先把又臭又长的题面读两遍，然后很显然，保证自己不死和把大佬怼死是两个不同的环节，两个问题，分别解决，互不干扰（这话咋这么耳熟呢）。 设$F[i][j]​$表示到了第$i​$天，自己的自信值为$j​$，最多可以多少天不刷水题。 那么就可以腾出$\max{i=1}^{n}{\max{j=0}^{mc}{F[i][j]}}​$天来专门怼大佬。 注意不是$\max_{j=0}^{mc}{F[n][j]}​$，可能还没到第$n​$天就可以把大佬怼死，但是到了第$n​$天不可能不被大佬怼死。 那么问题就转化为：给你$D​$天，每天可以执行操作1、3、4或5，问你能不能把大佬的自信值怼到$0​$？ 注意是怼到$0​$，不能单纯刷DP取最大值，那样可能把大佬的自信值怼到负，而且可以怼的自信值不一定连续。 设一种只用操作3、4、5的怼大佬方案为$(Hurt，Day)​$表示用了$Day​$天对大佬产生了$Hurt​$点伤害，发现数据范围并不大，所以就可以用BFS把所有方案都列出来。至于到底有多少种方案，玄学，反正数组开大点就好了。$Hash​$判重，直接调STL里的map的话时效会差一些。（但是我懒，所以调了map） 然后把所有怼大佬的方案按照伤害排序，用两个指针，一头一尾扫过去就好了，注意两个方案的伤害之和不能超过大佬的自信值，且剩下位怼完的自信值可以用剩余的天数通过操作1把大佬怼死就行了。 代码稍微有点长QwQ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091#include&lt;map&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;typedef long long LL;const int maxn=105,inf=0x3F3F3F3F;int n,m,mc,a[maxn],w[maxn],D,F[maxn][maxn],tot,T[2000005];inline int read()&#123; int ret=0,f=1;char ch=getchar(); while(ch&lt;'0'||ch&gt;'9')&#123;if(ch=='-')f=-f;ch=getchar();&#125; while(ch&gt;='0'&amp;&amp;ch&lt;='9')&#123;ret=ret*10+ch-'0';ch=getchar();&#125; return ret*f;&#125;inline void GetFightDays() //刷DP计算天数&#123; memset(F,-1,sizeof(F));F[0][mc]=0; for(int i=1;i&lt;=n;i++) &#123; for(int j=a[i];j&lt;=mc;j++) //注意不要越界 &#123; F[i][j-a[i]]=max(F[i][j-a[i]],F[i-1][j]+1); int x=min(mc,j-a[i]+w[i] ); F[i][x]=max(F[i][x],F[i-1][j]); &#125; &#125; for(int i=1;i&lt;=n;i++) for(int j=0;j&lt;=mc;j++) if(F[i][j]&gt;D) D=F[i][j];&#125;struct Node&#123;int F,L;&#125;Q[2000005];map&lt;int,map&lt;int,int&gt; &gt; Day;struct Plan&#123; int Hurt,Days; bool operator &lt; (const Plan&amp; b)const&#123;return Hurt&lt;b.Hurt;&#125;&#125;P[2000005];inline void BFS()&#123; int hed=0,til=1,ddd; Q[1]=(Node)&#123;1,0&#125;;Day[1][0]=T[1]=1;//刷BFS搞出所有可能的方案 while(hed!=til) &#123; hed++;ddd=Day[Q[hed].F][Q[hed].L]; if(ddd&gt;=D) continue; if(!Day[Q[hed].F][Q[hed].L+1]) &#123; til++;Q[til].F=Q[hed].F;Q[til].L=Q[hed].L+1; Day[Q[til].F][Q[til].L]=T[til]=ddd+1; &#125; if((LL)Q[hed].F*Q[hed].L&lt;=100000000&amp;&amp;!Day[Q[hed].F*Q[hed].L][Q[hed].L]) &#123; til++;Q[til].F=Q[hed].F*Q[hed].L;Q[til].L=Q[hed].L; Day[Q[til].F][Q[til].L]=T[til]=ddd+1; &#125; &#125; P[++tot]=(Plan)&#123;0,0&#125;; for(int i=1;i&lt;=til;i++) P[++tot]=(Plan)&#123;Q[i].F,Day[Q[i].F][Q[i].L]&#125;; sort(P+1,P+1+tot);&#125;int Check(int C)&#123; int j=1,mi=inf; for(int i=tot;i;i--) &#123; while(i&gt;j&amp;&amp;P[i].Hurt+P[j].Hurt&lt;=C) &#123; mi=min(mi,P[j].Days-P[j].Hurt); j++; &#125; if(D&gt;=C-P[i].Hurt+P[i].Days+mi) return 1; &#125; return 0;&#125;int main()&#123; n=read();m=read();mc=read(); for(int i=1;i&lt;=n;i++) a[i]=read(); for(int i=1;i&lt;=n;i++) w[i]=read(); GetFightDays(); BFS(); while(m--) &#123; int Ci=read(); printf("%d\n",Check(Ci)); &#125; return 0;&#125;]]></content>
      <categories>
        <category>BFS</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>BFS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「洛谷P5108」仰望半月的夜空]]></title>
    <url>%2F2019%2F02%2F11%2F%E3%80%8C%E6%B4%9B%E8%B0%B7P5108%E3%80%8D%E4%BB%B0%E6%9C%9B%E5%8D%8A%E6%9C%88%E7%9A%84%E5%A4%9C%E7%A9%BA-Solution%2F</url>
    <content type="text"><![CDATA[这是一个标算与瞎搞的故事… 传送门洛谷P5108 题解蒟蒻我人生的第一道1次过样例并AC的黑题。（然而写的并不是标算，这题貌似也没有达到黑题的难度） 这题的标算是后缀数组，然鹅蒟蒻我选择了瞎搞QwQ。 此题瞎搞的关键点在于找出题目中隐藏的单调性。（大雾） 首先，如果先考虑长度为$1$的子串，再考虑长度为$2$的，长度为$3$的…那么分别一共有$n$个、$n-1$个、$n-2$个。 并不好搞。 所以倒着来处理。（汗 长度为$n$的子串可以由$1$开头、长度为$n-2$的子串可以由2开头…每次可能的开头增加一个。 并且其中有一定的单调性：对于合法的开头$i,j$，如果当前$i$比$j$优，那么之后$j$永远不可能比$i$优。 所以构造一个单调栈$stk[]$，每次直接把新增的合法开头扔进栈顶，然后不断比较当前长度下$stk[top]$和$stk[top-1]$。如果此时$stk[top]$不比$stk[top-1]$优，直接弹掉它，维护栈的单调性。 维护操作结束后，栈顶就是当前最优解。 但是还有一个关键问题没有解决：如何快速比较两个较长字符串的大小？ 既然原字符串是静态的，那么可以通过Hash+二分找出两个字符串的最长相同前缀，然后比较下一位即可。 瞎搞完成 ，总时间复杂度为$\Theta(n\log n)$。 然后… ZS：嗯哼？后缀数组的题让你Hash+二分过了？看我拍一宿造数据卡掉你！！！ 蒟蒻我：老师我写了双Hash！！！ ZS：嗯哼！喂？是中国人民解放军国防科技大学吗？麻烦你们把天河二号借我用一宿… 然后就没有然后了QwQ… 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include&lt;cstdio&gt;using namespace std;typedef long long LL;const int maxn=300005;int sig,n,S[maxn],top,stk[maxn],ans[maxn];char tep[maxn];inline int read()&#123; int ret=0,f=1;char ch=getchar(); while(ch&lt;'0'||ch&gt;'9')&#123;if(ch=='-')f=-f;ch=getchar();&#125; while(ch&gt;='0'&amp;&amp;ch&lt;='9')&#123;ret=ret*10+ch-'0';ch=getchar();&#125; return ret*f;&#125;struct Hash&#123; int Base,TT,Pow[maxn],Val[maxn]; void init(int b,int m) &#123; Base=b;TT=m;Pow[0]=1; for(int i=1;i&lt;=n;i++) Pow[i]=(LL)Pow[i-1]*Base%TT; for(int i=1;i&lt;=n;i++) Val[i]=((LL)Val[i-1]*Base+S[i])%TT; &#125; inline int GetHashValue(int L,int R)&#123;return ((Val[R]-(LL)Val[L-1]*Pow[R-L+1])%TT+TT)%TT;&#125;&#125;H1,H2;inline bool IsStringSame(int L,int R,int S,int T)&#123;return H1.GetHashValue(L,R)==H1.GetHashValue(S,T)&amp;&amp;H2.GetHashValue(L,R)==H2.GetHashValue(S,T);&#125;inline bool StrCmp(int S1,int S2,int len)&#123; int L=0,R=len,mid; while(L&lt;=R) &#123; mid=L+R&gt;&gt;1; IsStringSame(S1,S1+mid-1,S2,S2+mid-1)?L=mid+1:R=mid-1; &#125; if(R==len) return true; return S[S1+R]&gt;=S[S2+R];&#125;int main()&#123; sig=read();n=read(); if(sig==26) &#123; scanf("%s",tep+1); for(int i=1;i&lt;=n;i++) S[i]=tep[i]-'a'; &#125; else for(int i=1;i&lt;=n;i++) S[i]=read(); H1.init(19630217,1000000007);H2.init(19260817,1000000009); for(int len=n;len;len--) &#123; top++;stk[top]=n-len+1; while(top&gt;1&amp;&amp;StrCmp(stk[top],stk[top-1],len)) top--; ans[len]=stk[top]; &#125; for(int i=1;i&lt;=n;i++) printf("%d%c",ans[i],i==n?'\n':' '); return 0;&#125;]]></content>
      <categories>
        <category>单调栈</category>
      </categories>
      <tags>
        <tag>二分</tag>
        <tag>单调栈</tag>
        <tag>后缀数组</tag>
        <tag>哈希</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[高斯消元法解线性方程组]]></title>
    <url>%2F2019%2F02%2F07%2F%E9%AB%98%E6%96%AF%E6%B6%88%E5%85%83%E6%B3%95%E8%A7%A3%E7%BA%BF%E6%80%A7%E6%96%B9%E7%A8%8B%E7%BB%84-Algorithm%2F</url>
    <content type="text"><![CDATA[骚年？高斯消元了解一下！！！ 引入问题昨天，蒟蒻我遇到了一道题（传送门）。需要解一个n元非齐次线性方程组，才发现蒟蒻我这些玩意儿都忘得差不多了，吓得我赶紧掏出线性代数小紫书补一补，然后马上写个博客压压惊。 什么？您不知道什么是n元非齐次线性方程组？就是n元一次方程组啊！ 什么？您还是不知道？那肯定是dalao您又在嘲讽蒟蒻我了。请dalao您自行Ctrl+W！！！ 写得可能有不周到或者有问题的地方，还请dalao们多多指教。 理论基础比如说，有这样一个由$n$个方程组成的$n$元线性方程组： \begin{cases} a_{11}x_1+a_{12}x_2+\cdots+a_{1n}x_n=b_1\\ a_{21}x_1+a_{22}x_2+\cdots+a_{2n}x_n=b_2\\ \vdots\\ a_{n1}x_1+a_{n2}x_2+\cdots+a_{nn}x_n=b_n\\ \end{cases}我们可以把它表示成矩阵乘法的形式： \begin{Bmatrix} {a_{11}}&{a_{12}}&{\cdots}&{a_{1n}}\\ {a_{21}}&{a_{22}}&{\cdots}&{a_{2n}}\\ {\vdots}&{\vdots}&{\ddots}&{\vdots}\\ {a_{n1}}&{a_{n2}}&{\cdots}&{a_{nn}}\\ \end{Bmatrix} * \begin{Bmatrix} {x_1}\\ {x_2}\\ {\vdots}\\ {x_n}\\ \end{Bmatrix} = \begin{Bmatrix} {b_1}\\ {b_2}\\ {\vdots}\\ {b_n}\\ \end{Bmatrix}有这样几个有用的矩阵： A=(a_{ij}), x= \begin{Bmatrix} {x_1}\\ {x_2}\\ {\vdots}\\ {x_n}\\ \end{Bmatrix}, b= \begin{Bmatrix} {b_1}\\ {b_2}\\ {\vdots}\\ {b_n}\\ \end{Bmatrix}, B= \begin{Bmatrix} {a_{11}}&{a_{12}}&{\cdots}&{a_{1n}}&{b_1}\\ {a_{21}}&{a_{22}}&{\cdots}&{a_{2n}}&{b_2}\\ {\vdots}&{\vdots}&{\ddots}&{\vdots}&{\vdots}\\ {a_{n1}}&{a_{n2}}&{\cdots}&{a_{nn}}&{b_n}\\ \end{Bmatrix}其中$A$称为系数矩阵，$x$称为未知数矩阵，$b$称为常数项矩阵，$B$称为增广矩阵。 如果系数矩阵是形如下面这个样子上三角矩阵（即对角线以下都为0），那么就很爽了： \begin{Bmatrix} {a_{11}}&{a_{12}}&{\cdots}&{a_{1n}}\\ {0}&{a_{22}}&{\cdots}&{a_{2n}}\\ {\vdots}&{\vdots}&{\ddots}&{\vdots}\\ {0}&{0}&{\cdots}&{a_{nn}}\\ \end{Bmatrix}其中$a{nn}$的值就是$x_n$的值，这样就解出了一个未知数的值，然后代入上一个方程中，就能解出$x{n-1}$的值然后一直往上代入并求解，这样方程组就解出来了耶！ 但是很显然这么好的事情并不是每次都有（特别是对于我这种脸黑的蒟蒻来说`）。 所以我们就要想办法把系数矩阵变成这个样子，高斯消元就是干这个的。 我们就先把增广矩阵拎出来，其他的扔到一边腌制半个小时待用不管了。 我们可以把增广矩阵的一行乘以任意一个系数然后加到另一行，方程组的解不变。 其实就是相当于把原方程组的一个方程乘以一个系数再加到另一个方程组上。 我们可以把第一行的元素乘以一个系数加到第二行，乘以另一个系数加到第三行……一直加到第$n$行。 然后就可以把矩阵变成这样： \begin{Bmatrix} {a_{11}}&{a_{12}}&{\cdots}&{a_{1n}}&{b_1}\\ {0}&{a_{22}'}&{\cdots}&{a_{2n}'}&{b_2'}\\ {\vdots}&{\vdots}&{\ddots}&{\vdots}&{\vdots}\\ {0}&{a_{n2}'}&{\cdots}&{a_{nn}'}&{b_n'}\\ \end{Bmatrix}然后再把操作后的矩阵的第二行乘以一个系数加到第三行、第四行重复上面的操作，然后矩阵就会变成这样： \begin{Bmatrix} {a_{11}}&{a_{12}}&{\cdots}&{a_{1n}}&{b_1}\\ {0}&{a_{22}'}&{\cdots}&{a_{2n}'}&{b_2'}\\ {\vdots}&{\vdots}&{\ddots}&{\vdots}&{\vdots}\\ {0}&{0}&{\cdots}&{a_{nn}''}&{b_n''}\\ \end{Bmatrix}再重复上面的操作，最终矩阵就会变成理想状态了。然后依次代入消元即可。 需要注意的是，如果系数矩阵的对角线上有$0$的话是会出事的，记得特殊处理一下。 然后就没有然后了，理论部分就是这样。 代码实现详见我的上一篇博客 其他参考资料 ： 工程数学——线性代数 第六版 同济大学数学系。 话说MathJax的数学公式用起来真是赏心悦目。]]></content>
      <categories>
        <category>高斯消元</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>高斯消元</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「JSOI2008」球形空间产生器]]></title>
    <url>%2F2019%2F02%2F06%2F%E3%80%8CJSOI2008%E3%80%8D%E7%90%83%E5%BD%A2%E7%A9%BA%E9%97%B4%E4%BA%A7%E7%94%9F%E5%99%A8-Solution%2F</url>
    <content type="text"><![CDATA[纳尼？n维空间？什么鬼？？？ 传送门洛谷P4035 BZOJ1013 题解根据题目的说明，设球心的坐标为$Oj(j \in [1,n])$，$n+1$个点的坐标为$X{ij}(i \in[1,n+1],j\in{1,n})$，$R$为半径，那么就有$n+1$个这样的式子： \sum_{j=1}^{n}{(O_j-X_{ij})^2}=R^2将$R$消去，平方展开，移项后，可以得到$n$个这样的方程： \sum_{j=1}^{n}{2\cdot (X_{i+1j}-X_{ij})}\cdot O_j=\sum_{j=1}^{n}{X_{i+1j}^2-X_{ij}^2}狠狠盯着方程几秒钟，然后你就会发现方程中只有$O_j$是未知数，其他都是常数，所以这$n​$个方程构成了一个n元非齐次线性方程组（说人话叫做n元一次方程组）。 怎么解呢？ 上高斯消元啊啊啊！！！ 才发现什么矩阵行列式之类的东西都忘得差不多了，吓得我赶紧掏出了线性代数小紫书 那么 ，怎么用高斯消元法 解线性方程组呢？且听下回分解请左拐至…！ 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;int n;double a[15][15],A[15][15];double ABS(double x)&#123;return x&lt;0?-x:x;&#125;inline void Gauss() //高斯消元解方程&#123; for(int i=1;i&lt;=n;i++) &#123; int now=i; for(int j=i+1;j&lt;=n;j++) if(ABS(A[j][i]&gt;A[now][i])) now=j; if(now!=i) for(int j=i;j&lt;=n+1;j++) swap(A[now][j],A[i][j]); for(int k=i+1;k&lt;=n;k++) &#123; double t=A[k][i]/A[i][i]; for(int j=i;j&lt;=n+1;j++) A[k][j]-=A[i][j]*t; &#125; &#125; for(int i=n;i;i--) &#123; for(int j=i+1;j&lt;=n;j++) A[i][n+1]-=A[j][n+1]*A[i][j]; A[i][n+1]/=A[i][i]; &#125;&#125;int main()&#123; scanf("%d",&amp;n); for(int i=1;i&lt;=n+1;i++) for(int j=1;j&lt;=n;j++) scanf("%lf",&amp;a[i][j]); for(int i=1;i&lt;=n;i++) &#123; for(int j=1;j&lt;=n;j++) &#123; A[i][j]=2*(a[i+1][j]-a[i][j]); A[i][n+1]+=a[i+1][j]*a[i+1][j]-a[i][j]*a[i][j]; &#125; &#125; //A数组是该n元非齐次线性方程组的增广矩阵 Gauss(); for(int i=1;i&lt;=n;i++) printf("%.3lf%c",A[i][n+1],i==n?'\n':' '); return 0;&#125;]]></content>
      <categories>
        <category>高斯消元</category>
      </categories>
      <tags>
        <tag>高斯消元</tag>
        <tag>解方程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「SCOI2008」奖励关]]></title>
    <url>%2F2019%2F02%2F05%2F%E3%80%8CSCOI2008%E3%80%8D%E5%A5%96%E5%8A%B1%E5%85%B3-Solution%2F</url>
    <content type="text"><![CDATA[又是状压又是期望的，本蒟蒻最不熟了QwQ。 传送门洛谷P2473 BZOJ1076 题解由于种种原因，这题的DP是倒着推的。 设$F[i][s]$表示现在是第$i$关，已经吃的宝物的状态为$s$，吃到最后的得分期望。 由于每一关中每个宝物的概率都相同，所以累加每个宝物的贡献然后除以$n$即可。 转移方程，若可以吃第$j (j \in [1,n])$个宝物，可以选择吃或者不吃 F[i][s]+=max(F[i+1][s],F[i+1][s|(1]]></content>
      <categories>
        <category>状压期望DP</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>概率与期望</tag>
        <tag>期望DP</tag>
        <tag>状态压缩</tag>
        <tag>状压DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「SCOI2009」粉刷匠]]></title>
    <url>%2F2019%2F02%2F04%2F%E3%80%8CSCOI2009%E3%80%8D%E7%B2%89%E5%88%B7%E5%8C%A0-Solution%2F</url>
    <content type="text"><![CDATA[周政是个粉刷匠，粉刷本领强！他把自己的小白脸，刷得黑又脏！ 传送门洛谷P4158 BZOJ1296 题解本蒟蒻难得1A的省选题，虽然很老。 瞅了一眼数据范围，挺小的，直接上DP瞎搞！！！（汗 设$F[i][j][k]​$表示对于第$i​$行的前$j​$列，涂了$k​$次颜料，最多能刷对几个格子。 那么初始值$F[i][j][k]=F[i][j-1][k]​$； 转移方程： F[i][j][k]=\max_{l=0}^{j-1}{F[i][l][k-1]+sum[i][j]-sum[i][l]} \tag{1} F[i][j][k]=\max_{l=0}^{j-1}{F[i][l][k-1]+j-l-sum[i][j]+sum[i][l]} \tag{2}第一个式子表示$[l+1,j]$涂蓝色，第二个表示涂红色。 上式中的$sum[i][j]$表示第$i$行前$j$个格子中有几个希望被染成蓝色，即颜色的前缀和。 所以$F[i][m][k]​$就表示第$i​$行涂$k​$次最多能涂对几个格子。 预处理出了上式之后，然后再DP一趟，就能得出答案了呢（雾 令$G[i][j]​$表示对于前$i​$行，涂了$j​$次颜料，最多能涂对多少个格子。 那么很显然又有转移方程： G[i][j]=\max_{k=0}^{min(m,j)}{G[i-1][j-k]+F[i][m][k]} \tag{3}这趟DP刷完之后，终于得到了答案，即$G[n​$][T]。 就没有然后了QwQ 代码123456789101112131415161718192021222324252627282930313233343536373839#include&lt;cstdio&gt;using namespace std;const int maxn=55,maxt=2505;int n,m,T,F[maxn][maxn][maxn],sum[maxn][maxn],G[maxn][maxt];char GetChar()&#123; char ch=getchar(); while(ch!='0'&amp;&amp;ch!='1') ch=getchar(); return ch;&#125;int main()&#123; scanf("%d%d%d",&amp;n,&amp;m,&amp;T); for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=m;j++) sum[i][j]=sum[i][j-1]+(int)(GetChar()=='1'); for(int i=1;i&lt;=n;i++) &#123; for(int j=1;j&lt;=m;j++) &#123; for(int k=1;k&lt;=m;k++) &#123; F[i][j][k]=F[i][j-1][k]; for(int l=0;l&lt;j;l++) &#123; if(F[i][l][k-1]+sum[i][j]-sum[i][l]&gt;F[i][j][k]) F[i][j][k]=F[i][l][k-1]+sum[i][j]-sum[i][l]; if(F[i][l][k-1]+j-l-sum[i][j]+sum[i][l]&gt;F[i][j][k]) F[i][j][k]=F[i][l][k-1]+j-l-sum[i][j]+sum[i][l]; &#125; &#125; &#125; &#125; for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=T;j++) for(int k=0;k&lt;=m&amp;&amp;k&lt;=j;k++) if(G[i-1][j-k]+F[i][m][k]&gt;G[i][j]) G[i][j]=G[i-1][j-k]+F[i][m][k]; printf("%d\n",G[n][T]); return 0;&#125;]]></content>
      <categories>
        <category>DP</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>三维DP</tag>
        <tag>动态规划</tag>
        <tag>双DP</tag>
        <tag>二维DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「HNOI2008」GT考试]]></title>
    <url>%2F2019%2F02%2F03%2F%E3%80%8CHNOI2008%E3%80%8DGT%E8%80%83%E8%AF%95-Solution%2F</url>
    <content type="text"><![CDATA[继续学数数喽QwQ… 传送门洛谷P3193 BZOJ1009 题解很显然这是一道优化DP数数题 ，可惜我又不会QwQ。 （此处省略0x3F3F3F3F字的思考过程） 令$f[i][j]​$表示长串匹配到第$i​$位，短串匹配到第$j​$位的合法方案数； $g[k][j]$表示短串匹配到第$j$位时，长串再加上一个字符使得最多能匹配$k$位的方案数。 那么就有 f[i][j]=\sum_{k=0}^{m-1}{f[i-1][k]*g[k][j]}最后的答案就是 \sum_{i=0}^{m-1}{f[n][i]}观察一下DP转移方程，发现$g$数组是固定的，可以通过看毛片KMP或者暴力预处理出来（抱歉我这里真的没有毛片看，但是据说隔壁巨佬知道哪里有）。 再狠狠瞅几眼转移方程，艾玛！这不是一个矩阵乘法的式子吗！ 令矩阵$F[i]$的第一行为$f[i][j]​$，那么就有 F[i]=F[i-1]*G所以 F[n]=F[0]*G^n且又知道$f[0][0]=1$、最后答案为$F[n]​$第一行元素之和。 所以这题就解完了。 代码本蒟蒻因为矩阵重载乘法运算符是忘了return调了半天QwQ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include&lt;cstdio&gt;#include&lt;cstring&gt;using namespace std;int n,m,K,nxt[25],ans;char S[25];struct Matrix //矩阵类&#123; int A[25][25]; Matrix()&#123;memset(A,0,sizeof(A));&#125; Matrix operator * (const Matrix&amp; b) //矩阵乘法 &#123; Matrix c; for(int i=0;i&lt;m;i++) &#123; for(int j=0;j&lt;m;j++) &#123; for(int k=0;k&lt;m;k++) &#123; c.A[i][j]+=A[i][k]*b.A[k][j]; c.A[i][j]%=K; //记得mod &#125; &#125; &#125; return c; &#125;&#125;G,F;inline void KMP() //KMP构造矩阵G&#123; for(int i=2;i&lt;=m;i++) &#123; int j=nxt[i-1]; while(j&amp;&amp;S[i]!=S[j+1]) j=nxt[j]; if(S[i]==S[j+1]) nxt[i]=j+1; &#125; for(int i=0;i&lt;m;i++) &#123; for(int j='0';j&lt;='9';j++) &#123; int k=i; while(k&amp;&amp;S[k+1]!=j) k=nxt[k]; if(S[k+1]==j) k++; if(k&lt;m) G.A[i][k]++; &#125; &#125;&#125;Matrix QP(const Matrix&amp; a,int b) //矩阵快速幂&#123; Matrix ret=a,w=a;b--; while(b) &#123; if(b&amp;1) ret=ret*w; w=w*w;b&gt;&gt;=1; &#125; return ret;&#125;int main()&#123; scanf("%d%d%d%s",&amp;n,&amp;m,&amp;K,S+1); KMP();F.A[0][0]=1;F=F*QP(G,n); for(int i=0;i&lt;m;i++) ans=(ans+F.A[0][i])%K; printf("%d\n",ans); return 0;&#125;]]></content>
      <categories>
        <category>矩阵加速DP</category>
      </categories>
      <tags>
        <tag>数数</tag>
        <tag>DP</tag>
        <tag>快速幂</tag>
        <tag>矩阵加速</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「AHOI2009」中国象棋]]></title>
    <url>%2F2019%2F01%2F31%2F%E3%80%8CAHOI2009%E3%80%8D%E4%B8%AD%E5%9B%BD%E8%B1%A1%E6%A3%8B-Solution%2F</url>
    <content type="text"><![CDATA[数数万岁… 前言早晨起床，打开电脑，上了洛谷，打了个卡，发现智能推荐里面有几道上古时代的省选题。随便戳开了一道，发现是个应该是个DP数数题，而我数数又很差，正想补补，于是就很愉快的做起了此题… 传送门洛谷P2051 BZOJ1801 题解感觉2010年之前的省选题都不怎么难、代码量都不大(对于个别题目当我没说)… 首先很显然，每一行每一列里，如果炮的个数都≤2，那么都是合法的啦！ 看了一眼，数据范围很亲切，然后就自然而然地想出了这样一个DP：（汗 F[i][j][k] 表示放了前i行，有j列放了2个炮，k列放了1个炮，那么就有m-i-j列没有放炮首先是初始值$F[0][0][0]=1​$。 然后考虑怎么从第$i-1$行转移过来。 如果第$i$行一个炮也不放，那么就有$F[i][j][k]=F[i-1][j][k]$。 如果放一个，那么有两种情况： 放在空的列上： $F[i][j][k]+=F[i-1][j][k-1]*(m-j-k+1)​$； 放在只放了1个炮的列上： $F[i][j][k]+=F[i-1][j-1][k+1]*(k+1)​$。 如果放两个炮，那么有三种情况： 两个都放在空的列上：$F[i][j][k]+=F[i-1][j][k-2]\cdot(m-j-k+2)\cdot(m-j-k+1)/2$； 一个放在空列，一个放在只有一个的列上：$F[i][j][k]+=F[i-1][j-1][k]\cdot k\cdot(m-j-k+1)$； 两个都放在只有一个的列上：$F[i][j][k]+=F[i-1][j-2][k+2]\cdot(k+2)\cdot(k+1)/2$。 最后的答案： \sum_{1=0}^{m}{\sum_{j=0}^{m-i}{F[n][i][j]}}然后这题就做完了QwQ。 代码123456789101112131415161718192021222324252627282930#include&lt;cstdio&gt;using namespace std;typedef long long LL;const int maxn=105,TT=9999973;int n,m,F[maxn][maxn][maxn],ans;int main()&#123; scanf("%d%d",&amp;n,&amp;m);F[0][0][0]=1; for(int i=1;i&lt;=n;i++) &#123; for(int j=0;j&lt;=m;j++) &#123; for(int k=0;j+k&lt;=m;k++) &#123; F[i][j][k]=F[i-1][j][k];//这题的模数比较小，有些地方不需要马上模，可以写好看一点 if(k&gt;=1) F[i][j][k]+=F[i-1][j][k-1]*(m-j-k+1); if(j&gt;=1) F[i][j][k]+=F[i-1][j-1][k+1]*(k+1); if(k&gt;=2) F[i][j][k]+=F[i-1][j][k-2]*(LL)(m-j-k+2)*(m-j-k+1)/2%TT; if(j&gt;=1) F[i][j][k]+=F[i-1][j-1][k]*(LL)k*(m-j-k+1)%TT; if(j&gt;=2) F[i][j][k]+=F[i-1][j-2][k+2]*(LL)(k+2)*(k+1)/2%TT; F[i][j][k]%=TT; &#125; &#125; &#125; for(int j=0;j&lt;=m;j++) for(int k=0;j+k&lt;=m;k++) ans=(ans+F[n][j][k])%TT; printf("%d\n",ans); return 0;&#125;]]></content>
      <categories>
        <category>DP</category>
      </categories>
      <tags>
        <tag>数数</tag>
        <tag>DP</tag>
        <tag>递推</tag>
        <tag>三维DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「FJOI2007」轮状病毒]]></title>
    <url>%2F2019%2F01%2F30%2F%E3%80%8CFJOI2007%E3%80%8D%E8%BD%AE%E7%8A%B6%E7%97%85%E6%AF%92-Solution%2F</url>
    <content type="text"><![CDATA[数数题怎么这么讨厌呀QwQ… 传送门洛谷P2144 BZOJ1002 题解这种数数题当然要先找规律呀poi！ 通过手玩或者暴力，可以得到以下表格： n ans 1 1 2 5 3 16 4 45 5 121 6 320 咦？当$n$为奇数时，$ans$都是完全平方数哇！！！ 那么当$n$为偶数时呢？ 哟，$ans$加上4之后也都是完全平方数呢！！！ 把这些完全平方数开个方试试看！！！ 就得到了这样的一个序列：1 3 4 7 11 18… 呀呀呀！这不就是一个变形的斐波那契数列么？ 并且$n​$很小，直接上高精度就好了呢poi。 然后这题就做完了QwQ… 别问我为什么有这样的规律，我也不知道QwQ… 码完代码测样例，才发现高精度都写挂了，我好菜啊QwQ 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;const int maxn=105;int n;struct BigInt //封装好的高精度&#123; int a[50],len; BigInt()&#123;len=0;memset(a,0,sizeof(a));&#125; BigInt(int x) &#123; len=0;memset(a,0,sizeof(a)); while(x)&#123;len++;a[len]=x%10;x/=10;&#125; &#125; BigInt operator + (const BigInt&amp; b) &#123; BigInt c; c.len=max(len,b.len); for(int i=1;i&lt;=c.len;i++) &#123; c.a[i]+=a[i]+b.a[i]; c.a[i+1]+=c.a[i]/10; c.a[i]%=10; &#125; if(c.a[c.len+1]) c.len++; return c; &#125; BigInt operator * (const BigInt&amp; b) &#123; BigInt c; c.len=len+b.len-1; for(int i=1;i&lt;=len;i++) &#123; for(int j=1;j&lt;=b.len;j++) &#123; c.a[i+j-1]+=a[i]*b.a[j]; c.a[i+j]+=c.a[i+j-1]/10; c.a[i+j-1]%=10; &#125; &#125; if(c.a[c.len+1]) c.len++; return c; &#125; BigInt operator - (const int&amp; b) //这个减法只能减去10以内的数 &#123; BigInt c=*this; c.a[1]-=b; for(int i=1;i&lt;=c.len&amp;&amp;c.a[i]&lt;0;i++) &#123; c.a[i]+=10; c.a[i+1]--; &#125; while(!c.a[c.len]) c.len--; return c; &#125; inline void Print() &#123; for(int i=len;i;i--) printf("%d",a[i]); printf("\n"); &#125;&#125;F[maxn],ans;int main()&#123; scanf("%d",&amp;n);F[1]=1;F[2]=3; for(int i=3;i&lt;=n;i++) F[i]=F[i-1]+F[i-2]; ans=F[n]*F[n]; if(n%2==0) ans=ans-4; //n为偶数时记得减去4哟 ans.Print(); return 0;&#125;]]></content>
      <categories>
        <category>递推</category>
      </categories>
      <tags>
        <tag>数数</tag>
        <tag>DP</tag>
        <tag>递推</tag>
        <tag>高精度</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「SCOI2009」windy数]]></title>
    <url>%2F2019%2F01%2F30%2F%E3%80%8CSCOI2009%E3%80%8Dwindy%E6%95%B0-Solution%2F</url>
    <content type="text"><![CDATA[分块打表大法好！打表万岁！dalao保佑我打表进省队！（逃 传送门洛谷P2657 BZOJ1026 题解很显然，这题正解是数位DP，但是我觉得上分块打表会更好玩一些！ 设块大为$S$，我们可以先写一个暴力，计算出S、2S、3S、4S……内一共有多少个windy数，把这个表事先打出来。由于$A、B$都比较小，打这个表不会用很长时间。蒟蒻我的机子还不错，八框框的i5 CPU，最高可以睿频到3.4GHz，用了四十多秒就跑完了。然后根据容斥原理，最后的答案是$Solve(B)-Solve(A-1)$，其中$Solve(x)$用于求解共有多少个windy数$\in[1,x]$。且必有$x \in [kS,(k+1)S]$。$Solve(kS)$已经事先打过表了，暴力枚举并检验$[kS+1,x]$中有多少个windy数即可。为了减少最终代码长度，令$S=10^6$或$10^7​$即可。 代码还好，不是很长呢poi。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include&lt;cstdio&gt;using namespace std;const int table[2005]=&#123;0,202174,338305,476808,615022,753274,891526,1029740,1168243,1304374,1459689,1459689,1459689,1459689,1597903,1736155,1874407,2012621,2151124,2287255,2442570,2597885,2597885,2597885,2597885,2736137,2874389,3012603,3151106,3287237,3442552,3597867,3733998,3733998,3733998,3733998,3872250,4010464,4148967,4285098,4440413,4595728,4731859,4870362,4870362,4870362,4870362,5008576,5147079,5283210,5438525,5593840,5729971,5868474,6006688,6006688,6006688,6006688,6145191,6281322,6436637,6591952,6728083,6866586,7004800,7143052,7143052,7143052,7143052,7279183,7434498,7589813,7725944,7864447,8002661,8140913,8279165,8279165,8279165,8279165,8434480,8589795,8725926,8864429,9002643,9140895,9279147,9417361,9417361,9417361,9417361,9572676,9708807,9847310,9985524,10123776,10262028,10400242,10538745,10538745,10538745,10538745,10538745,10538745,10538745,10538745,10538745,10538745,10538745,10538745,10538745,10538745,10538745,10538745,10538745,10538745,10538745,10538745,10538745,10538745,10538745,10538745,10538745,10538745,10538745,10538745,10538745,10538745,10538745,10538745,10538745,10694060,10830191,10830191,10830191,10830191,10968443,11106657,11245160,11381291,11536606,11691921,11828052,11966555,11966555,11966555,11966555,12104769,12243272,12379403,12534718,12690033,12826164,12964667,13102881,13102881,13102881,13102881,13241384,13377515,13532830,13688145,13824276,13962779,14100993,14239245,14239245,14239245,14239245,14375376,14530691,14686006,14822137,14960640,15098854,15237106,15375358,15375358,15375358,15375358,15530673,15685988,15822119,15960622,16098836,16237088,16375340,16513554,16513554,16513554,16513554,16668869,16805000,16943503,17081717,17219969,17358221,17496435,17634938,17634938,17634938,17634938,17634938,17773441,17911655,18049907,18188159,18326373,18464876,18601007,18756322,18756322,18756322,18756322,18756322,18756322,18756322,18756322,18756322,18756322,18756322,18756322,18756322,18756322,18756322,18756322,18756322,18756322,18756322,18756322,18756322,18756322,18756322,18756322,18756322,18756322,18756322,18756322,18756322,18756322,18756322,18911637,19047768,19186271,19186271,19186271,19186271,19324485,19462988,19599119,19754434,19909749,20045880,20184383,20322597,20322597,20322597,20322597,20461100,20597231,20752546,20907861,21043992,21182495,21320709,21458961,21458961,21458961,21458961,21595092,21750407,21905722,22041853,22180356,22318570,22456822,22595074,22595074,22595074,22595074,22750389,22905704,23041835,23180338,23318552,23456804,23595056,23733270,23733270,23733270,23733270,23888585,24024716,24163219,24301433,24439685,24577937,24716151,24854654,24854654,24854654,24854654,24854654,24993157,25131371,25269623,25407875,25546089,25684592,25820723,25976038,25976038,25976038,25976038,26114252,26252504,26390756,26528970,26667473,26803604,26958919,26958919,26958919,26958919,26958919,26958919,26958919,26958919,26958919,26958919,26958919,26958919,26958919,26958919,26958919,26958919,26958919,26958919,26958919,26958919,26958919,26958919,26958919,26958919,26958919,26958919,26958919,26958919,26958919,26958919,26958919,27114234,27250365,27388868,27527082,27527082,27527082,27527082,27665585,27801716,27957031,28112346,28248477,28386980,28525194,28663446,28663446,28663446,28663446,28799577,28954892,29110207,29246338,29384841,29523055,29661307,29799559,29799559,29799559,29799559,29954874,30110189,30246320,30384823,30523037,30661289,30799541,30937755,30937755,30937755,30937755,31093070,31229201,31367704,31505918,31644170,31782422,31920636,32059139,32059139,32059139,32059139,32059139,32197642,32335856,32474108,32612360,32750574,32889077,33025208,33180523,33180523,33180523,33180523,33318737,33456989,33595241,33733455,33871958,34008089,34163404,34318719,34318719,34318719,34318719,34456971,34595223,34733437,34871940,35008071,35163386,35163386,35163386,35163386,35163386,35163386,35163386,35163386,35163386,35163386,35163386,35163386,35163386,35163386,35163386,35163386,35163386,35163386,35163386,35163386,35163386,35163386,35163386,35163386,35163386,35163386,35163386,35163386,35163386,35163386,35163386,35318701,35454832,35593335,35731549,35869801,35869801,35869801,35869801,36005932,36161247,36316562,36452693,36591196,36729410,36867662,37005914,37005914,37005914,37005914,37161229,37316544,37452675,37591178,37729392,37867644,38005896,38144110,38144110,38144110,38144110,38299425,38435556,38574059,38712273,38850525,38988777,39126991,39265494,39265494,39265494,39265494,39265494,39403997,39542211,39680463,39818715,39956929,40095432,40231563,40386878,40386878,40386878,40386878,40525092,40663344,40801596,40939810,41078313,41214444,41369759,41525074,41525074,41525074,41525074,41663326,41801578,41939792,42078295,42214426,42369741,42525056,42661187,42661187,42661187,42661187,42799439,42937653,43076156,43212287,43367602,43367602,43367602,43367602,43367602,43367602,43367602,43367602,43367602,43367602,43367602,43367602,43367602,43367602,43367602,43367602,43367602,43367602,43367602,43367602,43367602,43367602,43367602,43367602,43367602,43367602,43367602,43367602,43367602,43367602,43367602,43522917,43659048,43797551,43935765,44074017,44212269,44212269,44212269,44212269,44367584,44522899,44659030,44797533,44935747,45073999,45212251,45350465,45350465,45350465,45350465,45505780,45641911,45780414,45918628,46056880,46195132,46333346,46471849,46471849,46471849,46471849,46471849,46610352,46748566,46886818,47025070,47163284,47301787,47437918,47593233,47593233,47593233,47593233,47731447,47869699,48007951,48146165,48284668,48420799,48576114,48731429,48731429,48731429,48731429,48869681,49007933,49146147,49284650,49420781,49576096,49731411,49867542,49867542,49867542,49867542,50005794,50144008,50282511,50418642,50573957,50729272,50865403,51003906,51003906,51003906,51003906,51142120,51280623,51416754,51572069,51572069,51572069,51572069,51572069,51572069,51572069,51572069,51572069,51572069,51572069,51572069,51572069,51572069,51572069,51572069,51572069,51572069,51572069,51572069,51572069,51572069,51572069,51572069,51572069,51572069,51572069,51572069,51572069,51572069,51572069,51727384,51863515,52002018,52140232,52278484,52416736,52554950,52554950,52554950,52554950,52710265,52846396,52984899,53123113,53261365,53399617,53537831,53676334,53676334,53676334,53676334,53676334,53814837,53953051,54091303,54229555,54367769,54506272,54642403,54797718,54797718,54797718,54797718,54935932,55074184,55212436,55350650,55489153,55625284,55780599,55935914,55935914,55935914,55935914,56074166,56212418,56350632,56489135,56625266,56780581,56935896,57072027,57072027,57072027,57072027,57210279,57348493,57486996,57623127,57778442,57933757,58069888,58208391,58208391,58208391,58208391,58346605,58485108,58621239,58776554,58931869,59068000,59206503,59344717,59344717,59344717,59344717,59483220,59619351,59774666,59774666,59774666,59774666,59774666,59774666,59774666,59774666,59774666,59774666,59774666,59774666,59774666,59774666,59774666,59774666,59774666,59774666,59774666,59774666,59774666,59774666,59774666,59774666,59774666,59774666,59774666,59774666,59774666,59774666,59774666,59929981,60066112,60204615,60342829,60481081,60619333,60757547,60896050,60896050,60896050,60896050,60896050,61034553,61172767,61311019,61449271,61587485,61725988,61862119,62017434,62017434,62017434,62017434,62155648,62293900,62432152,62570366,62708869,62845000,63000315,63155630,63155630,63155630,63155630,63293882,63432134,63570348,63708851,63844982,64000297,64155612,64291743,64291743,64291743,64291743,64429995,64568209,64706712,64842843,64998158,65153473,65289604,65428107,65428107,65428107,65428107,65566321,65704824,65840955,65996270,66151585,66287716,66426219,66564433,66564433,66564433,66564433,66702936,66839067,66994382,67149697,67285828,67424331,67562545,67700797,67700797,67700797,67700797,67836928,67992243,67992243,67992243,67992243,67992243,67992243,67992243,67992243,67992243,67992243,67992243,67992243,67992243,67992243,67992243,67992243,67992243,67992243,67992243,67992243,67992243,67992243,67992243,67992243,67992243,67992243,67992243,67992243,67992243,67992243,67992243,67992243,67992243,68130746,68268960,68407212,68545464,68683678,68822181,68958312,69113627,69113627,69113627,69113627,69251841,69390093,69528345,69666559,69805062,69941193,70096508,70251823,70251823,70251823,70251823,70390075,70528327,70666541,70805044,70941175,71096490,71251805,71387936,71387936,71387936,71387936,71526188,71664402,71802905,71939036,72094351,72249666,72385797,72524300,72524300,72524300,72524300,72662514,72801017,72937148,73092463,73247778,73383909,73522412,73660626,73660626,73660626,73660626,73799129,73935260,74090575,74245890,74382021,74520524,74658738,74796990,74796990,74796990,74796990,74933121,75088436,75243751,75379882,75518385,75656599,75794851,75933103,75933103,75933103,75933103,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76226921,76365135,76503387,76641639,76779853,76918356,77054487,77209802,77209802,77209802,77209802,77348016,77486268,77624520,77762734,77901237,78037368,78192683,78192683,78192683,78192683,78192683,78192683,78192683,78192683,78192683,78192683,78192683,78192683,78192683,78192683,78192683,78192683,78192683,78192683,78192683,78192683,78192683,78192683,78192683,78192683,78192683,78192683,78192683,78192683,78192683,78192683,78192683,78347998,78484129,78622632,78760846,78760846,78760846,78760846,78899349,79035480,79190795,79346110,79482241,79620744,79758958,79897210,79897210,79897210,79897210,80033341,80188656,80343971,80480102,80618605,80756819,80895071,81033323,81033323,81033323,81033323,81188638,81343953,81480084,81618587,81756801,81895053,82033305,82171519,82171519,82171519,82171519,82326834,82462965,82601468,82739682,82877934,83016186,83154400,83292903,83292903,83292903,83292903,83292903,83431406,83569620,83707872,83846124,83984338,84122841,84258972,84414287,84414287,84414287,84414287,84552501,84690753,84829005,84967219,85105722,85241853,85397168,85552483,85552483,85552483,85552483,85690735,85828987,85967201,86105704,86241835,86397150,86397150,86397150,86397150,86397150,86397150,86397150,86397150,86397150,86397150,86397150,86397150,86397150,86397150,86397150,86397150,86397150,86397150,86397150,86397150,86397150,86397150,86397150,86397150,86397150,86397150,86397150,86397150,86397150,86397150,86397150,86552465,86688596,86827099,86965313,87103565,87103565,87103565,87103565,87239696,87395011,87550326,87686457,87824960,87963174,88101426,88239678,88239678,88239678,88239678,88394993,88550308,88686439,88824942,88963156,89101408,89239660,89377874,89377874,89377874,89377874,89533189,89669320,89807823,89946037,90084289,90222541,90360755,90499258,90499258,90499258,90499258,90499258,90637761,90775975,90914227,91052479,91190693,91329196,91465327,91620642,91620642,91620642,91620642,91758856,91897108,92035360,92173574,92312077,92448208,92603523,92758838,92758838,92758838,92758838,92897090,93035342,93173556,93312059,93448190,93603505,93758820,93894951,93894951,93894951,93894951,94033203,94171417,94309920,94446051,94601366,94601366,94601366,94601366,94601366,94601366,94601366,94601366,94601366,94601366,94601366,94601366,94601366,94601366,94601366,94601366,94601366,94601366,94601366,94601366,94601366,94601366,94601366,94601366,94601366,94601366,94601366,94601366,94601366,94601366,94601366,94756681,94892812,95031315,95169529,95307781,95446033,95446033,95446033,95446033,95601348,95756663,95892794,96031297,96169511,96307763,96446015,96584229,96584229,96584229,96584229,96739544,96875675,97014178,97152392,97290644,97428896,97567110,97705613,97705613,97705613,97705613,97705613,97844116,97982330,98120582,98258834,98397048,98535551,98671682,98826997,98826997,98826997,98826997,98965211,99103463,99241715,99379929,99518432,99654563,99809878,99965193,99965193,99965193,99965193,100103445,100241697,100379911,100518414,100654545,100809860,100965175,101101306,101101306,101101306,101101306,101239558,101377772,101516275,101652406,101807721,101963036,102099167,102237670,102237670,102237670,102237670,102375884,102514387,102650518,102805833,102805833,102805833,102805833,102805833,102805833,102805833,102805833,102805833,102805833,102805833,102805833,102805833,102805833,102805833,102805833,102805833,102805833,102805833,102805833,102805833,102805833,102805833,102805833,102805833,102805833,102805833,102805833,102805833,102805833,102805833,102961148,103097279,103235782,103373996,103512248,103650500,103788714,103788714,103788714,103788714,103944029,104080160,104218663,104356877,104495129,104633381,104771595,104910098,104910098,104910098,104910098,104910098,105048601,105186815,105325067,105463319,105601533,105740036,105876167,106031482,106031482,106031482,106031482,106169696,106307948,106446200,106584414,106722917,106859048,107014363,107169678,107169678,107169678,107169678,107307930,107446182,107584396,107722899,107859030,108014345,108169660,108305791,108305791,108305791,108305791,108444043,108582257,108720760,108856891,109012206,109167521,109303652,109442155,109442155,109442155,109442155,109580369,109718872,109855003,110010318,110165633,110301764,110440267,110578481,110578481,110578481,110578481,110716984,110853115,111008430,111008430,111008430,111008430,111008430,111008430,111008430,111008430,111008430,111008430,111008430,111008430,111008430,111008430,111008430,111008430,111008430,111008430,111008430,111008430,111008430,111008430,111008430,111008430,111008430,111008430,111008430,111008430,111008430,111008430,111008430,111163745,111299876,111438379,111576593,111714845,111853097,111991311,112129814,112129814,112129814,112129814,112129814,112268317,112406531,112544783,112683035,112821249,112959752,113095883,113251198,113251198,113251198,113251198,113389412,113527664,113665916,113804130,113942633,114078764,114234079,114389394,114389394,114389394,114389394,114527646,114665898,114804112,114942615,115078746,115234061,115389376,115525507,115525507,115525507,115525507,115663759,115801973,115940476,116076607,116231922,116387237,116523368,116661871,116661871,116661871,116661871,116800085,116938588,117074719,117230034,117385349,117521480,117659983,117798197,117798197,117798197,117798197,117936700,118072831,118228146,118383461,118519592,118658095,118796309,118934561,118934561,118934561,118934561,119070692,119226007,119226007,119226007,119226007,119226007,119226007,119226007,119226007,119226007,119226007,119226007,119226007,119226007,119226007,119226007,119226007,119226007,119226007,119226007,119226007,119226007,119226007,119226007,119226007,119226007,119226007,119226007,119226007,119226007,119226007,119226007,119226007,119226007,119364510,119502724,119640976,119779228,119917442,120055945,120192076,120347391,120347391,120347391,120347391,120485605,120623857,120762109,120900323,121038826,121174957,121330272,121485587,121485587,121485587,121485587,121623839,121762091,121900305,122038808,122174939,122330254,122485569,122621700,122621700,122621700,122621700,122759952,122898166,123036669,123172800,123328115,123483430,123619561,123758064,123758064,123758064,123758064,123896278,124034781,124170912,124326227,124481542,124617673,124756176,124894390,124894390,124894390,124894390,125032893,125169024,125324339,125479654,125615785,125754288,125892502,126030754,126030754,126030754,126030754,126166885,126322200,126477515,126613646,126752149,126890363,127028615,127166867,127166867,127166867,127166867,127322182,127322182,127322182,127322182,127322182,127322182,127322182,127322182,127322182,127322182,127322182,127322182,127322182,127322182,127322182,127322182,127322182,127322182,127322182,127322182,127322182&#125;;int A,B;inline int read()&#123; int ret=0,f=1;char ch=getchar(); while(ch&lt;'0'||ch&gt;'9')&#123;if(ch=='-')f=-f;ch=getchar();&#125; while(ch&gt;='0'&amp;&amp;ch&lt;='9')&#123;ret=ret*10+ch-'0';ch=getchar();&#125; return ret*f;&#125;int ABS(int x)&#123;return x&lt;0?-x:x;&#125;inline bool check(int x)&#123; static int A[15],len; len=0; while(x)&#123;A[++len]=x%10;x/=10;&#125; for(int i=1;i&lt;len;i++) if(ABS(A[i+1]-A[i])&lt;2) return false; return true;&#125;inline void MakeTable()&#123; freopen("Table.txt","w",stdout); register int i,ans=0; for(i=1;i&lt;=2000000000;i++) &#123; if(check(i)) ans++; if(i%1000000==0) printf("%d,",ans); &#125;&#125;inline int Solve(int n)&#123; int ret=table[n/1000000]; for(int i=n/1000000*1000000+1;i&lt;=n;i++) if(check(i)) ret++; return ret;&#125;int main()&#123;// MakeTable(); scanf("%d%d",&amp;A,&amp;B); printf("%d\n",Solve(B)-Solve(A-1)); return 0;&#125;]]></content>
      <categories>
        <category>分块打表</category>
      </categories>
      <tags>
        <tag>分块</tag>
        <tag>打表</tag>
        <tag>分块打表</tag>
        <tag>数位DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「HNOI2005」狡猾的商人]]></title>
    <url>%2F2019%2F01%2F29%2F%E3%80%8CHNOI2005%E3%80%8D%E7%8B%A1%E7%8C%BE%E7%9A%84%E5%95%86%E4%BA%BA-Solution%2F</url>
    <content type="text"><![CDATA[贪心大法好QwQ！ 传送门洛谷P2294 BZOJ1202 题解这题有好多种解法，可以上差分约束、并查集之类的。 但是贪心大法好啊！！！ 把所有偷看到的信息按左端点排序，然后从前到后两两比较。 如果左端点相同 比较右端点 如果右端点相同 比较权值，如果不相同直接输出false 如果右端点不相同 将重叠部分抵消掉，权值相减得到一个新的信息，扔回去，用堆维护 如果左端点不同 把前面一个信息扔掉即可，不用管 直到最后，堆空了，没有出现问题，那么输出true就好了。 代码其实这题挺水的 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include&lt;queue&gt;#include&lt;vector&gt;#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;int T,n,m;bool fal;inline int read()&#123; int ret=0,f=1;char ch=getchar(); while(ch&lt;'0'||ch&gt;'9')&#123;if(ch=='-')f=-f;ch=getchar();&#125; while(ch&gt;='0'&amp;&amp;ch&lt;='9')&#123;ret=ret*10+ch-'0';ch=getchar();&#125; return ret*f;&#125;struct Node&#123; int L,R,w; bool operator &lt; (const Node&amp; b)const&#123;return L&lt;b.L||(L==b.L&amp;&amp;R&lt;b.R);&#125; bool operator &gt; (const Node&amp; b)const&#123;return L&gt;b.L||(L==b.L&amp;&amp;R&gt;b.R);&#125;&#125;tep1,tep2;priority_queue&lt;Node,vector&lt;Node&gt;,greater&lt;Node&gt; &gt; H;int main()&#123; T=read(); while(T--) &#123; while(H.size()) H.pop(); n=read();m=read();fal=false; for(int i=1;i&lt;=m;i++) &#123; tep1.L=read();tep1.R=read();tep1.w=read(); H.push(tep1); &#125; tep1=H.top();H.pop(); while(H.size()) &#123; tep2=H.top();H.pop(); if(tep1.L==tep2.L) &#123; if(tep1.R==tep2.R) &#123; if(tep1.w!=tep2.w) &#123;printf("false\n");fal=true;break;&#125; &#125; else if(tep1.R!=tep2.R) H.push((Node)&#123;tep1.R+1,tep2.R,tep2.w-tep1.w&#125;); &#125; tep1=tep2; &#125; if(!fal) printf("true\n"); &#125; return 0;&#125;]]></content>
      <categories>
        <category>贪心</category>
      </categories>
      <tags>
        <tag>贪心</tag>
        <tag>并查集</tag>
        <tag>查分约束</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「HNOI2006」马步距离]]></title>
    <url>%2F2019%2F01%2F28%2F%E3%80%8CHNOI2006%E3%80%8D%E9%A9%AC%E6%AD%A5%E8%B7%9D%E7%A6%BB-Solution%2F</url>
    <content type="text"><![CDATA[这题有点水QwQ… 传送门洛谷P2060 BZOJ1193 题解首先很显然不能直接贪心，直接贪心有可能WA，所以要写个DFS之类的东西来搜。 但是数据稍微有点大QwQ，搜不出来。 不难发现，当距离比较远时直接贪心地奔着目标走是肯定没问题的。 所以距离远时贪心，距离近时爆搜就行了QwQ。 其实手玩就能把表打出来。 代码打表万岁 123456789101112131415161718192021222324252627#include&lt;cstdio&gt;using namespace std;const int f[7][7]=&#123; &#123;0,3,2,3,2&#125;, &#123;3,2,1,2,3&#125;, &#123;2,1,4,3,2&#125;, &#123;3,2,3,2,3&#125;, &#123;2,3,2,3,4&#125;&#125;;int xp,yp,xs,ys,x,y,ans;int ABS(int x)&#123;return x&lt;0?-x:x;&#125;int main()&#123; scanf("%d%d%d%d",&amp;xp,&amp;yp,&amp;xs,&amp;ys); x=ABS(xp-xs);y=ABS(yp-ys); while(x&gt;4||y&gt;4) &#123; if(x&lt;y)&#123;x--;y-=2;&#125; else&#123;x-=2;y--;&#125; if(x&lt;0) x=-x;if(y&lt;0) y=-y; ans++; &#125; ans+=f[x][y]; printf("%d\n",ans); return 0;&#125;]]></content>
      <categories>
        <category>贪心</category>
      </categories>
      <tags>
        <tag>贪心</tag>
        <tag>DFS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「BJOI2014」想法]]></title>
    <url>%2F2019%2F01%2F24%2F%E3%80%8CBJOI2014%E3%80%8D%E6%83%B3%E6%B3%95-Solution%2F</url>
    <content type="text"><![CDATA[什么鬼？省选也出这种玄学随机算法题？ 传送门洛谷P4581 题解首先这题一看就很不可解。 所以上随机算法（人家题面都告诉你了QwQ）。 写之前先膜拜一下dalao，保佑AC。 sto 黄霖 orz 对于一个节点，将所用能走到它的叶子节点都存下来是不现实的，所以我们只存$k$个。并且我们要先为每个叶子节点i随机一个权值$W_i$，满足$W_i \in [1,RANDMAX]$。对于每个非叶子节点，我们需要存下所有能走到个节点的叶子节点的权值的前$k$小。设这个节点的答案为$ans$，第$k$小权值为$F_k​$根据期望可得 \frac{F_k}{RANDMAX}=\frac{k}{ans}故有 ans=\frac{k*RANDMAX}{F_k}令$k=50$，多为叶子节点随机几套权值求平均值，吸个氧，放个大悲咒，选个好种子，你就能AC了。 代码这是真的玄学QwQ 1234567891011121314151617181920212223242526272829303132333435363738394041424344#include&lt;cstdio&gt;#include&lt;cstdlib&gt;using namespace std;typedef long long LL;const int maxn=1000005,k=50;int n,m,son[maxn][2],w[maxn],num[maxn],f[maxn][55];LL ans[maxn];inline int read()&#123; int ret=0,f=1;char ch=getchar(); while(ch&lt;'0'||ch&gt;'9')&#123;if(ch=='-')f=-f;ch=getchar();&#125; while(ch&gt;='0'&amp;&amp;ch&lt;='9')&#123;ret=ret*10+ch-'0';ch=getchar();&#125; return ret*f;&#125;inline void Merge(int s1,int s2,int now) //从两个儿子节点合并过来&#123; register int i=1,j=1;num[now]=k; for(register int p=1;p&lt;=k;p++) &#123; while(f[s1][i]==f[now][p-1]&amp;&amp;i&lt;=num[s1]) i++; //注意去重 while(f[s2][j]==f[now][p-1]&amp;&amp;j&lt;=num[s2]) j++; if(i&gt;num[s1]&amp;&amp;j&gt;num[s2])&#123;num[now]=p-1;break;&#125; if(i&lt;=num[s1]&amp;&amp;(f[s1][i]&lt;f[s2][j]||j&gt;num[s2]))&#123;f[now][p]=f[s1][i];i++;&#125; else if(j&lt;=num[s2])&#123;f[now][p]=f[s2][j];j++;&#125; &#125;&#125;int main()&#123; srand(20050429); n=read();m=read(); for(register int i=m+1;i&lt;=n;i++)&#123;son[i][0]=read();son[i][1]=read();&#125; for(int r=1;r&lt;=4;r++) &#123; for(register int i=1;i&lt;=n;i++)&#123;w[i]=rand();while(!w[i])w[i]=rand();&#125; for(register int i=1;i&lt;=m;i++)&#123;f[i][1]=w[i];num[i]=1;&#125; for(register int i=m+1;i&lt;=n;i++) &#123; Merge(son[i][0],son[i][1],i); if(num[i]&lt;k) ans[i]=num[i]*4; //如果还没到k个就不用根据期望计算了 else ans[i]+=(LL)k*RAND_MAX/f[i][k]; &#125; &#125; for(int i=m+1;i&lt;=n;i++) printf("%lld\n",ans[i]/4); return 0;&#125;]]></content>
      <categories>
        <category>随机算法</category>
      </categories>
      <tags>
        <tag>随机算法</tag>
        <tag>DAG</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「洛谷P2617」Dynamic Rankings]]></title>
    <url>%2F2019%2F01%2F23%2F%E3%80%8C%E6%B4%9B%E8%B0%B7P2617%E3%80%8DDynamic-Rankings%2F</url>
    <content type="text"><![CDATA[标算又是树套树？写不来QwQ… 传送门BZOJ(是个权限题QwQ) 洛谷P2617 题解据说这题可以用带修主席树、树套树、整体二分解。由于蒟蒻我实在太菜了QwQ，只好选择了整体二分。 把刚原始序列理解为n个添加操作，将修改操作理解为一个删除操作和一个添加操作。然后直接上整体二分，解法类似于「ZJOI2013」K大数查询。并且由于每次只需要修改一个位置的信息，所以用普通树状数组就行了呢poi，快得飞起（尽管我自带大常数QwQ）。 代码整体二分又好写又好理解呢poi 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283#include&lt;cstdio&gt;using namespace std;const int maxn=100005;int n,m,tot,cnt,ans[maxn],A[maxn];inline int read()&#123; int ret=0,f=1;char ch=getchar(); while(ch&lt;'0'||ch&gt;'9')&#123;if(ch=='-')f=-f;ch=getchar();&#125; while(ch&gt;='0'&amp;&amp;ch&lt;='9')&#123;ret=ret*10+ch-'0';ch=getchar();&#125; return ret*f;&#125;struct BIT //封装好的树状数组&#123; int Tree[maxn]; void Update(int pos,int delta)&#123;while(pos&lt;=n)&#123;Tree[pos]+=delta;pos+=pos&amp;-pos;&#125;&#125; int Query(int pos)&#123;int ret=0;while(pos&gt;0)&#123;ret+=Tree[pos];pos-=pos&amp;-pos;&#125;return ret;&#125;&#125;Tr;struct Command&#123;int typ,idx,num,delta,L,R,k,id;&#125;Q[maxn*4],Q1[maxn*4],Q2[maxn*4];char GetChar() //读取操作类型，排除无用字符&#123; char ch=getchar(); while(ch!='C'&amp;&amp;ch!='Q') ch=getchar(); return ch;&#125;void BinarySearch(int L,int R,int S,int T) //整体二分&#123; if(L&gt;R||S&gt;T) return; int mid=L+R&gt;&gt;1,til1=0,til2=0; if(L==R) &#123; for(int i=S;i&lt;=T;i++) if(Q[i].typ) ans[Q[i].id]=mid; return; &#125; for(int i=S;i&lt;=T;i++) &#123; if(!Q[i].typ) &#123; if(Q[i].num&lt;=mid) &#123; Tr.Update(Q[i].idx,Q[i].delta); Q1[++til1]=Q[i]; &#125; else Q2[++til2]=Q[i]; &#125; else &#123; int cnt=Tr.Query(Q[i].R)-Tr.Query(Q[i].L-1); if(cnt&lt;Q[i].k) &#123; Q[i].k-=cnt; Q2[++til2]=Q[i]; &#125; else Q1[++til1]=Q[i]; &#125; &#125; for(int i=S;i&lt;=T;i++) //别忘了还原树状数组哟poi if(!Q[i].typ) if(Q[i].num&lt;=mid) Tr.Update(Q[i].idx,-Q[i].delta); for(int i=1;i&lt;=til1;i++) Q[S+i-1]=Q1[i]; for(int i=1;i&lt;=til2;i++) Q[S+til1+i-1]=Q2[i]; BinarySearch(L,mid,S,S+til1-1); BinarySearch(mid+1,R,S+til1,T);&#125;int main()&#123; n=read();m=read(); for(int i=1;i&lt;=n;i++)&#123;tot++;Q[tot].idx=i;Q[tot].num=A[i]=read();Q[tot].delta=1;&#125; for(int i=1;i&lt;=m;i++) &#123; if(GetChar()=='Q')&#123;tot++;cnt++;Q[tot].typ=1;Q[tot].L=read();Q[tot].R=read();Q[tot].k=read();Q[tot].id=cnt;&#125; else &#123; tot++;Q[tot].idx=read();Q[tot].num=read();Q[tot].delta=1; tot++;Q[tot].idx=Q[tot-1].idx;Q[tot].num=A[Q[tot-1].idx];A[Q[tot-1].idx]=Q[tot-1].num;Q[tot].delta=-1; &#125; &#125; BinarySearch(0,1000000000,1,tot); for(int i=1;i&lt;=cnt;i++) printf("%d\n",ans[i]); return 0;&#125;]]></content>
      <categories>
        <category>整体二分</category>
      </categories>
      <tags>
        <tag>主席树</tag>
        <tag>整体二分</tag>
        <tag>树套树</tag>
        <tag>树状数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「洛谷P5059」中国象棋]]></title>
    <url>%2F2019%2F01%2F16%2F%E3%80%8C%E6%B4%9B%E8%B0%B7P5059%E3%80%8D%E4%B8%AD%E5%9B%BD%E8%B1%A1%E6%A3%8B%2F</url>
    <content type="text"><![CDATA[又是数数题QwQ… 传送门洛谷P5059 题解首先注意题目中说的是有$n^2$个格子，也就是$(n+1)^2$个格点。 以下是出题人的推导： 首先我们可以发现每一行是独立的，所以只需要处理一行的答案即可 设$F[i][0]$表示一行中摆了$i$个位置且第$i$个位置不摆放棋子的方案数 设$F[i][1]$表示一行中摆了$i$个位置且第$i$个位置摆放棋子的方案数 设$Ans[i]$表示$F[i][0]+F[i][1]$ 那么忽略第二个限制可以发现有: $F[i][0]=F[i-1][0]+F[i-1][1]$ $F[i][1]=F[i-1][0]$ 所以有 $Ans[i]$ $=F[i][0]+F[i][1]$ $=2F[i-1][0]+F[i-1][1]$ $=(F[i-1][0]+F[i-1][1])+(F[i-2][0]+F[i-2][1])$ $=Ans[i-1]+Ans[i-2]$ 好了很显然这是一个斐波那契数列。自己再推一下，注意一下细节，不难发现最后的答案就是 (Fib_{n+3}-n-2)^{n+1}矩阵加快速幂就可以在$\Theta(\log n)$的复杂内求解。 还有一个问题，由于n和P都非常大，直接乘long long也会boom。所以这里用了一个类似于快速幂的方法来求$(a*b)\mod P$的值。虽然复杂度多了一只log，但是很好写，并且避免了高精度又臭又长的代码和大常数复杂度。 代码还挺好写的呢poi。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include&lt;cstdio&gt;using namespace std;typedef long long LL;LL n,P;LL Multiply(LL x,LL y) //两个10^18级别的数在模P意义下的乘法&#123; LL ret=0,w=x; while(y) &#123; if(y&amp;1) ret=(ret+w)%P; w=(w+w)%P;y&gt;&gt;=1; &#125; return ret;&#125;struct Matrix&#123; LL a[2][2]; Matrix()&#123;a[0][0]=a[0][1]=a[1][0]=a[1][1]=0;&#125; Matrix operator * (Matrix b) //矩阵乘法 &#123; Matrix c; for(int i=0;i&lt;2;i++) for(int j=0;j&lt;2;j++) for(int k=0;k&lt;2;k++) c.a[i][j]=(c.a[i][j]+Multiply(a[k][j],b.a[i][k]))%P; return c; &#125;&#125;ans,mat,tep;LL QP(LL a,LL b) //普通快速幂&#123; LL ret=1,w=a; while(b) &#123; if(b&amp;1) ret=Multiply(ret,w); w=Multiply(w,w);b&gt;&gt;=1; &#125; return ret;&#125;int main()&#123; scanf("%lld%lld",&amp;n,&amp;P); ans.a[0][0]=ans.a[0][1]=mat.a[0][0]=mat.a[0][1]=mat.a[1][0]=1; LL b=n+1;tep=mat; while(b) //矩阵加速斐波那契数列 &#123; if(b&amp;1) mat=mat*tep; tep=tep*tep;b&gt;&gt;=1; &#125; ans=ans*mat; printf("%lld\n",QP(((ans.a[0][0]-n-2)%P+P)%P,n+1)); return 0;&#125;]]></content>
      <categories>
        <category>矩阵加速DP</category>
      </categories>
      <tags>
        <tag>数数</tag>
        <tag>DP</tag>
        <tag>快速幂</tag>
        <tag>矩阵加速</tag>
        <tag>斐波那契数列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「国家集训队」聪聪可可]]></title>
    <url>%2F2019%2F01%2F16%2F%E3%80%8C%E5%9B%BD%E5%AE%B6%E9%9B%86%E8%AE%AD%E9%98%9F%E3%80%8D%E8%81%AA%E8%81%AA%E5%8F%AF%E5%8F%AF%2F</url>
    <content type="text"><![CDATA[我数数最差了QwQ… 传送门洛谷P2634 BZOJ2152 题解很显然这是一道假的概率题。而是一道数数题，只要数出路径长度为3的倍数的点对的数量就行了呢poi。 隔壁dalao说这是一道点分治裸题，但是我还是觉得树形DP更好写一些QwQ。 定义$F_{ij}(j \in \lbrace 0,1,2 \rbrace)$表示节点$i$的子树中，到i的距离$\mod 3=j$的节点个数。如果当前遍历到的节点为i，我们需要计算出$i$及其子树中满足最短路径经过节点$i$且满足路径长是3的倍数的节点个数，累计到答案里最后除以$n^2$并约分就好了呢poi。 注意起点和终点可以相同，计算时小心点，不要算重复也不要漏算了哟poi。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243#include&lt;cstdio&gt;using namespace std;const int maxn=20005;int n,tot,lnk[maxn],son[maxn*2],w[maxn*2],nxt[maxn*2],F[maxn][3],ans1,ans2;inline int read()&#123; int ret=0,f=1;char ch=getchar(); while(ch&lt;'0'||ch&gt;'9')&#123;if(ch=='-')f=-f;ch=getchar();&#125; while(ch&gt;='0'&amp;&amp;ch&lt;='9')&#123;ret=ret*10+ch-'0';ch=getchar();&#125; return ret*f;&#125;inline void add_e(int x,int y,int z)&#123;tot++;son[tot]=y;w[tot]=z;nxt[tot]=lnk[x];lnk[x]=tot;&#125;int gcd(int x,int y)&#123;return !y?x:gcd(y,x%y);&#125;void DFS(int now,int fa)&#123; F[now][0]=1; for(int i=lnk[now];i;i=nxt[i]) &#123; if(son[i]!=fa) &#123; DFS(son[i],now); for(int j=0;j&lt;3;j++) ans1+=F[son[i]][j]*F[now][((3-j-w[i])%3+3)%3]*2; for(int j=0;j&lt;3;j++) F[now][(j+w[i])%3]+=F[son[i]][j]; &#125; &#125;&#125;int main()&#123; n=read(); for(int i=1;i&lt;n;i++) &#123; int a=read(),b=read(),c=read(); add_e(a,b,c);add_e(b,a,c); &#125; DFS(1,0); ans1+=n;ans2=n*n; int gys=gcd(ans1,ans2); ans1/=gys;ans2/=gys; printf("%d/%d\n",ans1,ans2); return 0;&#125;]]></content>
      <categories>
        <category>树形DP</category>
      </categories>
      <tags>
        <tag>数数</tag>
        <tag>DP</tag>
        <tag>概率</tag>
        <tag>DFS</tag>
        <tag>点分治</tag>
        <tag>树形DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「JSOI2004」平衡点/吊打XXX]]></title>
    <url>%2F2019%2F01%2F15%2F%E3%80%8CJSOI2004%E3%80%8D%E5%B9%B3%E8%A1%A1%E7%82%B9%20%E5%90%8A%E6%89%93XXX-Solution%2F</url>
    <content type="text"><![CDATA[这是一个欧皇与非酋的故事…… 引言很久很久以前，有一位欧皇叫做黄霖，他热衷于各种随机算法，而且每次都能AC，直到有一天，他看到了张老师（ZS，我的启蒙老师，他水平很高，造数据能力特强）出的一份卷子： 黄霖：嗯！T1模拟退火能AC！T2模拟退火也能AC！T3模拟退火照样AC！ 张老师（冷笑）：嗯哼？三题都写模拟退火？有分吗？ 然后就没有然后了呢poi… 传送门洛谷P1337 题解这是一道物理题。 首先根据最小势能原理，当整个系统的势能最小时，系统平衡。不要问我为什么QwQ，我物理不好呢poi 虽然这题的正解不是模拟退火，但是用这题来当模拟退火的经典题还是很不错的呢poi。 首先我们钦定一个点作为绳结所在的位置作为初始答案，然后计算势能。 每次都在当前答案点附近的一个区域内rand一个点，区域大小由当前温度决定，如果这个点更优（势能更小），那么久接收这个点作为答案。否则有一定的概率接收新答案（概率计算方法很玄学，但是温度越小接收的概率越大）。 然后将温度乘以一个降温系数（降温系数是一个小于1的正数，这一步即退火），然后进行下一次答案搜索。 当温度降到几乎为0时停止就行了呢poi。 退火技巧首先可以多退几次。 降温系数要根据题目细调，太大了会导致时效差，太小可能搜不到最优解QwQ。 初始温度也要根据情况给定，可以用一些历史上特殊的日子，比如某dalao的生日来做初始温度呢poi。 种子也建议用某dalao的生日，或脸滚键盘，最好不要用初始值。 没事时多放放大悲咒，往生咒，般若波罗蜜多心经之类的音乐，你将得到佛祖的保佑。 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;cstdlib&gt;using namespace std;const int maxn=1005;const double delta=0.995; //降温系数int n,X[maxn],Y[maxn],W[maxn];double ansx,ansy,anse;inline int read()&#123; int ret=0,f=1;char ch=getchar(); while(ch&lt;'0'||ch&gt;'9')&#123;if(ch=='-')f=-f;ch=getchar();&#125; while(ch&gt;='0'&amp;&amp;ch&lt;='9')&#123;ret=ret*10+ch-'0';ch=getchar();&#125; return ret*f;&#125;inline double PotentialEnergy(double nowx,double nowy) //计算势能&#123; double ret=0; for(int i=1;i&lt;=n;i++) ret+=sqrt((X[i]-nowx)*(X[i]-nowx)+(Y[i]-nowy)*(Y[i]-nowy))*W[i]; return ret;&#125;inline void SimulateAnneal(double T)&#123; double nowx=ansx,nowy=ansy; while(T&gt;1e-14) &#123; double tempx=nowx+(rand()*2-RAND_MAX)*T; double tempy=nowy+(rand()*2-RAND_MAX)*T; double PE=PotentialEnergy(tempx,tempy); if(PE&lt;anse) //如果更优就马上接受 &#123; ansx=tempx;ansy=tempy; nowx=tempx;nowy=tempy; anse=PE; &#125; else if(exp((anse-PE)/T)*RAND_MAX&gt;rand())&#123;nowx=tempx;nowy=tempy;&#125; //否则有一定概率接收 T*=delta; //降温 &#125;&#125;inline void Solve()&#123; anse=PotentialEnergy(ansx,ansy); SimulateAnneal(2005); //多刷几次，记得洗把脸 SimulateAnneal(1926); SimulateAnneal(1949); SimulateAnneal(1978);&#125;int main()&#123; srand(20050429);//2005年4月29日dalao LTL出生，dalao会为你带来好运 n=read(); for(int i=1;i&lt;=n;i++)&#123;X[i]=read();Y[i]=read();W[i]=read();&#125; Solve(); printf("%.3lf %.3lf\n",ansx,ansy); return 0;&#125;]]></content>
      <categories>
        <category>模拟退火</category>
      </categories>
      <tags>
        <tag>随机算法</tag>
        <tag>模拟退火</tag>
        <tag>物理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「USACO2015JAN」草鉴定Grass Cownoisseur]]></title>
    <url>%2F2019%2F01%2F14%2F%E3%80%8CUSACO2015JAN%E3%80%8D%E8%8D%89%E9%89%B4%E5%AE%9AGrass-Cownoisseur%20-Solution%2F</url>
    <content type="text"><![CDATA[骚年，快来看！奶牛Bessie又在吃草了QwQ。 传送门洛谷P3119 题解单向道路？求一次能遍历到的最大点的数量？二话不说先上个Tarjan缩个点压压惊poi。 如果没有逆行这种操作，那么很显然起点所在强联通分量点的个数就是答案。 可是Bessie就是Bessie，总要搞点事情出来才符合她的性格。 于是乎我们缩点之后正反建图，刷两趟SPFA求每个点到起点的最长路。 然后枚举缩完点的图上的一条边，用来搞事情逆行。设当前枚举到的边为$(u,v)$，那么$u$在正建的图上到起点的最长路加上$v$在反建图上到起点的最长路就是逆行这条边时的最优解。在所有边里刷个最大值就行了呢poi。 有几个坑： 在最后计算答案时起点的权值会被算两次，记得减去一个。 枚举用于逆行的边时需要确保可以走到这条边并且走到这条边后可以走回起点。 由于需要建三套图(没缩过点的一套正建图一套反建图一套)，不要把数组名搞混了。此时封装可能是个好办法（但是会长一些，所以我没封装）。 其实总体上讲这题的想法并不难，但是代码有点难码QwQ。 于是乎这题就解完了。时间复杂度为$\Theta(n)$。 代码我觉得我写的挺简洁的poi。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687#include&lt;cstdio&gt;#include&lt;cstring&gt;using namespace std;const int maxn=100005;int n,m,tot[3],lnk[3][maxn],son[3][maxn],nxt[3][maxn],w[maxn],idx,dfn[maxn],low[maxn],top,stack[maxn],cnt,id[maxn],dist[3][maxn],que[maxn],ans;bool vis[maxn];inline int read()&#123; int ret=0,f=1;char ch=getchar(); while(ch&lt;'0'||ch&gt;'9')&#123;if(ch=='-')f=-f;ch=getchar();&#125; while(ch&gt;='0'&amp;&amp;ch&lt;='9')&#123;ret=ret*10+ch-'0';ch=getchar();&#125; return ret*f;&#125;inline void add_e(int x,int y,int id)&#123;tot[id]++;son[id][tot[id]]=y;nxt[id][tot[id]]=lnk[id][x];lnk[id][x]=tot[id];&#125;void Tarjan(int now)&#123; idx++;top++;vis[now]=true; dfn[now]=low[now]=idx;stack[top]=now; for(int i=lnk[0][now];i;i=nxt[0][i]) &#123; if(!dfn[son[0][i]]) &#123; Tarjan(son[0][i]); if(low[son[0][i]]&lt;low[now]) low[now]=low[son[0][i]]; &#125; else if(vis[son[0][i]]&amp;&amp;dfn[son[0][i]]&lt;low[now]) low[now]=dfn[son[0][i]]; &#125; if(dfn[now]==low[now]) &#123; cnt++; do &#123; id[stack[top]]=cnt;w[cnt]++; vis[stack[top]]=false;top--; &#125;while(stack[top+1]!=now); &#125;&#125;inline void SPFA(int id)&#123; memset(vis,false,sizeof(vis)); int hed=0,til=1; que[1]=::id[1];vis[que[1]]=true;dist[id][que[1]]=w[que[1]]; while(hed!=til) &#123; hed=(hed+1)%maxn;vis[que[hed]]=false; for(int j=lnk[id][que[hed]];j;j=nxt[id][j]) &#123; if(dist[id][que[hed]]+w[son[id][j]]&gt;dist[id][son[id][j]]) &#123; dist[id][son[id][j]]=dist[id][que[hed]]+w[son[id][j]]; if(!vis[son[id][j]]) &#123; vis[son[id][j]]=true; til=(til+1)%maxn; que[til]=son[id][j]; &#125; &#125; &#125; &#125;&#125;int main()&#123; n=read();m=read(); for(int i=1;i&lt;=m;i++) &#123; int a=read(),b=read(); add_e(a,b,0); &#125; for(int i=1;i&lt;=n;i++) if(!dfn[i]) Tarjan(i); for(int i=1;i&lt;=n;i++) &#123; for(int j=lnk[0][i];j;j=nxt[0][j]) &#123; if(id[i]!=id[son[0][j]]) &#123; add_e(id[i],id[son[0][j]],1); add_e(id[son[0][j]],id[i],2); &#125; &#125; &#125; SPFA(1);SPFA(2); for(int i=1;i&lt;=cnt;i++) for(int j=lnk[2][i];j;j=nxt[2][j]) if(dist[1][i]&amp;&amp;dist[2][son[2][j]]&amp;&amp;dist[1][i]+dist[2][son[2][j]]-w[id[1]]&gt;ans) ans=dist[1][i]+dist[2][son[2][j]]-w[id[1]]; printf("%d\n",ans); return 0;&#125;]]></content>
      <categories>
        <category>强联通分量</category>
      </categories>
      <tags>
        <tag>DAG</tag>
        <tag>Tarjan</tag>
        <tag>强联通分量</tag>
        <tag>最短路</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「HNOI2016」树]]></title>
    <url>%2F2019%2F01%2F05%2F%E3%80%8CHNOI2016%E3%80%8D%E6%A0%91-Solution%2F</url>
    <content type="text"><![CDATA[骚年，来看看这棵 真•树套树 吧！ 传送门洛谷 BZOJ 题解蒟蒻我定睛一看，一共有$10^{10}$个点，立马把蒟蒻我给吓到了QwQ。显然这是一道毒瘤题。我深深地感受到了出题人的恶意(然而我还是太菜了，像XHW这种dalao就可以想着要把出题人阿掉，我却不行)。 既然有这么多点，肯定是存不下的。因为每次操作都是copy一整颗子树，所以我们可以用一种叫做 真•树套树 的方法来解决呢poi。 我们构造大树时，令每一个大节点都对应模板树中的一整棵子树，并对新树重新编号，就像这样（样例）： 然后我们定义两个大节点之间的边的变权为两个大节点所包含的树的树根之间的距离。如上图中大节点1和2之间的边权为2,1与3之间的边权为3。 每一个大节点还需要存储以下信息： S[],T[]：该大节点包含的小节点的编号区间的起点和终点，如上图节点1的编号区间是[1,5]，节点2是[6,8]，节点3是[9,9]。 pre[]：该大节点对应的是模板树中哪一个节点的子树，如pre[1]=1，pre[2]=4，pre[3]=3。 lnk[]：该大节点挂在大树中的哪一个节点底下，如lnk[2]=3，lnk[3]=2。 以及常见的倍增LCA所需的信息。 还需要写几个函数： int GetRoot(long long u);用于查找小节点u所在的大节点。构造好S[],T[0]后，二分即可实现。 int GetPre(long long u);用于查找小节点u在模板树中对应的是哪个节点。假设小节点u在大节点rt里，那么根据题意，我们要找的就是rt对应的模板树的子树中该子树编号第$u-S[rt]+1$小的节点。这个我们可以把模板树一巴掌拍扁求个DFS序，然后用主席树解决（不会主席树的童鞋戳这里）。 int GetDist(int u,int v);用于求模板树上的节点u,v之间的距离。LCA解决。 然后就可以开始考虑如何计算答案了。 计算答案的主要思想就是在大树上通过倍增LCA求解，但是与普通LCA不同的是，不能纯粹地就在大树上LCA，需要注意很多细节。比如当再跳一步就跳到最近的大节点公共祖先时，不能马上往上跳，而需要往上跳一小步后转到模板树上去LCA。因为计算答案的细节，劳资%@#@￥%(文明靠大家)地交了4次才AC(不过好像也不算多)。 这样这题就解完了。时空复杂度都是大约$\Theta(超大常数*n\log n)$呢poi。 总结&amp;反思这是一道十分毒瘤的代码题(但是在某些dalao眼里就是送分题)，思维难度一般，但蒟蒻我前前后后一共花了3个多小时才AC(听说隔壁XCW一看题就秒掉了)QwQ。这道题很好地反映出蒟蒻我的代码实现能力还是太差，可能是由于做题太少的缘故。我虽然很菜，但是如果ZJOI2019真的出了像这样的一道题(或者类似于猪国杀什么的)，空有想法却没时间写代码和调试，那可就亏大发了QwQ。 代码蒟蒻我为了避免变量重名，于是开了两个namespace（不知代码是更好看了还是更丑了）。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;typedef long long LL;const int maxn=100005,LOG=20;int Q;inline LL read()&#123; LL ret=0,f=1;char ch=getchar(); while(ch&lt;'0'||ch&gt;'9')&#123;if(ch=='-')f=-f;ch=getchar();&#125; while(ch&gt;='0'&amp;&amp;ch&lt;='9')&#123;ret=ret*10+ch-'0';ch=getchar();&#125; return ret*f;&#125;struct ChairmanTree //封装好的主席树&#123; int tot,T[maxn]; struct Node&#123;int L,R,Sum;&#125;Tree[maxn*LOG]; int Build(int L,int R) &#123; int rt=++tot,mid=L+R&gt;&gt;1; if(L&gt;=R) return rt; Tree[rt].L=Build(L,mid); Tree[rt].R=Build(mid+1,R); if(rt==1) T[0]=rt; return rt; &#125; int Update(int num,int pre,int L,int R) &#123; int rt=++tot,mid=L+R&gt;&gt;1; Tree[rt].L=Tree[pre].L;Tree[rt].R=Tree[pre].R;Tree[rt].Sum=Tree[pre].Sum+1; if(L&gt;=R) return rt; if(num&lt;=mid) Tree[rt].L=Update(num,Tree[pre].L,L,mid); else Tree[rt].R=Update(num,Tree[pre].R,mid+1,R); return rt; &#125; int Query(int u,int v,int k,int L,int R) &#123; int mid=L+R&gt;&gt;1,x=Tree[Tree[v].L].Sum-Tree[Tree[u].L].Sum; if(L==R) return mid; if(x&gt;=k) return Query(Tree[u].L,Tree[v].L,k,L,mid); else return Query(Tree[u].R,Tree[v].R,k-x,mid+1,R); &#125;&#125;CT;namespace TemplateTree //模板树&#123; int n,father[maxn][LOG],dep[maxn],idx,que[maxn],S[maxn],T[maxn],tot,lnk[maxn],son[maxn*2],nxt[maxn*2]; inline void add_e(int x,int y)&#123;tot++;son[tot]=y;nxt[tot]=lnk[x];lnk[x]=tot;&#125; void Build(int now,int fa) //把树上的一些信息构造好 &#123; S[now]=++idx;que[idx]=now;father[now][0]=fa;dep[now]=dep[fa]+1; for(int i=1;i&lt;=16;i++) father[now][i]=father[father[now][i-1]][i-1]; for(int i=lnk[now];i;i=nxt[i]) if(son[i]!=fa) Build(son[i],now); T[now]=idx; &#125; inline void BuildCT() //初始化主席树 &#123; CT.Build(1,n); for(int i=1;i&lt;=n;i++) CT.T[i]=CT.Update(que[i],CT.T[i-1],1,n); &#125; inline void Input() //读入数据 &#123; for(int i=1;i&lt;n;i++) &#123; int a=read(),b=read(); add_e(a,b);add_e(b,a); &#125; Build(1,0);BuildCT(); &#125; int GetDist(int u,int v) //LCA求亮点间距离 &#123; int ret=0; if(dep[u]&lt;dep[v]) swap(u,v); for(int i=16;i&gt;=0;i--) if(dep[father[u][i]]&gt;=dep[v])&#123;ret+=(1&lt;&lt;i);u=father[u][i];&#125; for(int i=16;i&gt;=0;i--) if(father[u][i]!=father[v][i])&#123;ret+=(1&lt;&lt;i+1);u=father[u][i];v=father[v][i];&#125; if(u==v) return ret; return ret+2; &#125;&#125;namespace BigTree //大树&#123; int n,m,father[maxn][LOG],dep[maxn],pre[maxn];LL dist[maxn][LOG],S[maxn],T[maxn],lnk[maxn],cnt; inline int GetRoot(LL u) &#123; int L=1,R=n,mid; while(L&lt;=R) &#123; mid=L+R&gt;&gt;1; S[mid]&lt;=u?L=mid+1:R=mid-1; &#125; return R; &#125; inline int GetPre(LL u) &#123; int rt=GetRoot(u); return CT.Query(CT.T[TemplateTree::S[pre[rt]]-1],CT.T[TemplateTree::T[pre[rt]]],u-S[rt]+1,1,TemplateTree::n); &#125; inline void Build() //初始化大树 &#123; n=1;dep[1]=1;pre[1]=1;S[1]=1;T[1]=TemplateTree::n;cnt=T[1]; for(int i=1;i&lt;=m;i++) &#123; int fr=read();LL to=read();int rt=GetRoot(to); n++;dep[n]=dep[rt]+1;lnk[n]=to;pre[n]=fr;S[n]=cnt+1;T[n]=cnt+TemplateTree::T[fr]-TemplateTree::S[fr]+1;cnt=T[n]; father[n][0]=rt;dist[n][0]=TemplateTree::dep[GetPre(to)]-TemplateTree::dep[pre[rt]]+1; for(int j=1;j&lt;=16;j++)&#123;father[n][j]=father[father[n][j-1]][j-1];dist[n][j]=dist[n][j-1]+dist[father[n][j-1]][j-1];&#125; &#125; &#125; inline LL Solve(LL u,LL v) //计算答案(写的真丑QwQ) &#123; LL ret=0;int rtu=GetRoot(u),rtv=GetRoot(v); if(rtu==rtv) return TemplateTree::GetDist(GetPre(u),GetPre(v)); if(dep[rtu]&lt;dep[rtv])&#123;swap(u,v);swap(rtu,rtv);&#125; ret+=TemplateTree::dep[GetPre(u)]-TemplateTree::dep[pre[rtu]];u=rtu; for(int i=16;i&gt;=0;i--) if(dep[father[u][i]]&gt;dep[rtv])&#123;ret+=dist[u][i];u=father[u][i];&#125; if(GetRoot(lnk[u])==rtv) return ret+1+TemplateTree::GetDist(GetPre(lnk[u]),GetPre(v)); ret+=TemplateTree::dep[GetPre(v)]-TemplateTree::dep[pre[rtv]];v=rtv; if(dep[u]&gt;dep[v])&#123;ret+=dist[u][0];u=father[u][0];&#125; for(int i=16;i&gt;=0;i--) if(father[u][i]!=father[v][i])&#123;ret+=dist[u][i]+dist[v][i];u=father[u][i];v=father[v][i];&#125; u=lnk[u];v=lnk[v];ret+=2; return ret+TemplateTree::GetDist(GetPre(u),GetPre(v)); &#125;&#125;int main() //好简洁的主函数&#123; TemplateTree::n=read();BigTree::m=read();Q=read(); TemplateTree::Input();BigTree::Build(); while(Q--) printf("%lld\n",BigTree::Solve(read(),read())); return 0;&#125;]]></content>
      <categories>
        <category>树上问题</category>
      </categories>
      <tags>
        <tag>树上问题</tag>
        <tag>LCA</tag>
        <tag>主席树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[主席树（可持久化线段树）]]></title>
    <url>%2F2019%2F01%2F04%2F%E4%B8%BB%E5%B8%AD%E6%A0%91%EF%BC%88%E5%8F%AF%E6%8C%81%E4%B9%85%E5%8C%96%E7%BA%BF%E6%AE%B5%E6%A0%91%EF%BC%89%2F</url>
    <content type="text"><![CDATA[骚年，你需要一棵主席树！它会赐予你力量！ 传送门洛谷的主席树模板题 正文引入问题我们可能时常会遇到这样的一类问题：给定一个序列$A$和若干组询问，每次给定一个区间$[L,R]$和一个参数$k$，问序列上该区间中第$k$大的元素是多少。 对于这类问题，暴力算法显而易见(但是会T飞)。一个很好的解决办法就是用主席树(其实洛谷上的这道模板题不强制在线，分块+莫队可以AC，还跑得贼快)。 说一句题外话，主席树这种数据结构据说是一位名字缩写是HJT的神仙在考场上现场yy出来的，而HJT正是新中国历史上一位著名主席的名字缩写，因此得名。 考虑初始版本首先请确保你已经掌握普通线段树的写法，不会的童鞋请自行Ctrl+W。 我们建$n$权值棵线段树，第$i$棵线段树需要维护序列$A_1$~$A_i$中，每个权值出现的次数。比如说第$i$棵线段树上的一个节点管辖的权值区间是$[S,T]$，该节点需要储存满足$A_j\inS,T$的元素$A_j$的个数。可以将这些线段树一开始就构造好。 当进行询问的时候，如果当前的询问区间是$[L,R]$那么我们就把第$L-1$棵线段树和第$R$棵线段树拎出来，根据容斥的原理，将两棵线段树每个节点的权值相减就能得到一颗有我们想要用的包含$A_L$~$A_R$的信息的权值线段树。 然后我们就在这棵线段树上计算答案。 首先先遍历树根，假设当前节点管辖的权值区间是$[L,R]$，权值在该区间内的元素的个数和是$sum$。 如果$sum\leq k$，那么遍历当前节点的左儿子。 否则将$k$的值减去$sum$，然后遍历右儿子。 循环以上步骤，直到$L=R$，此时的$L$就是答案。 完善初始版本说真的，初始版本又难码又慢，比暴力算法还垃圾QwQ 现在考虑完善一下初始版本，让它成为一棵真正的主席树！ 首先在询问的时候，不需要每次都重构一棵线段树，用两个指针同时在两棵线段树上遍历，查个数的时候再相减就行了。 其次，如果真的开$n$棵完整的权值线段树，内存不炸才怪QwQ。 我们发现，第$i$棵权值线段树是在继承第$i-1$棵的信息的基础上，再添加第$i$个元素的信息。而根据线段树的性质，每进行一次修改，最多只会改变$\log n$个节点的信息。所以我们动态开点，在开第$i$棵线段树时，只新开修改过的节点，并把新开的节点直接接到没有修改过的已有节点上就可以了QwQ。骚年，你感受到了可持久化的力量了吗？ 还有，由于元素的权值可能很大，我们需要将原序列先离散化。 这样，我们就成功地把时间复杂度和空间复杂度都下压至$\Theta(n\log n)$的水平。主席树万岁！ 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include&lt;map&gt;#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;const int maxn=200005,LOG=20;int n,m,cnt,A[maxn],B[maxn];map&lt;int,int&gt; H;inline int read()&#123; int ret=0,f=1;char ch=getchar(); while(ch&lt;'0'||ch&gt;'9')&#123;if(ch=='-')f=-f;ch=getchar();&#125; while(ch&gt;='0'&amp;&amp;ch&lt;='9')&#123;ret=ret*10+ch-'0';ch=getchar();&#125; return ret*f;&#125;struct ChairmanTree //封装大法好&#123; int tot,T[maxn]; struct Node&#123;int L,R,Sum;&#125;Tree[maxn*LOG]; int Build(int L,int R) //在开始添加信息之前，先初始化 &#123; int rt=++tot,mid=L+R&gt;&gt;1; if(L&gt;=R) return rt; Tree[rt].L=Build(L,mid); Tree[rt].R=Build(mid+1,R); if(rt==1) T[0]=rt; return rt; &#125; int Update(int num,int pre,int L,int R) //添加信息 &#123; int rt=++tot,mid=L+R&gt;&gt;1; Tree[rt].L=Tree[pre].L;Tree[rt].R=Tree[pre].R;Tree[rt].Sum=Tree[pre].Sum+1; if(L&gt;=R) return rt; if(num&lt;=mid) Tree[rt].L=Update(num,Tree[pre].L,L,mid); else Tree[rt].R=Update(num,Tree[pre].R,mid+1,R); return rt; &#125; int Query(int u,int v,int k,int L,int R) //询问 &#123; int mid=L+R&gt;&gt;1,x=Tree[Tree[v].L].Sum-Tree[Tree[u].L].Sum; if(L==R) return mid; //找到了 if(x&gt;=k) return Query(Tree[u].L,Tree[v].L,k,L,mid); //分类讨论 else return Query(Tree[u].R,Tree[v].R,k-x,mid+1,R); &#125;&#125;CT;int main()&#123; n=read();m=read(); for(int i=1;i&lt;=n;i++) A[i]=B[i]=read(); sort(B+1,B+1+n);cnt=unique(B+1,B+1+n)-B-1; //离散化 for(int i=1;i&lt;=cnt;i++) H[B[i]]=i; CT.Build(1,cnt); for(int i=1;i&lt;=n;i++) CT.T[i]=CT.Update(H[A[i]],CT.T[i-1],1,cnt); while(m--) &#123; int L=read(),R=read(),k=read(); printf("%d\n",B[CT.Query(CT.T[L-1],CT.T[R],k,1,cnt)]); &#125; return 0;&#125; 其他其实主席树也可以维护带修改操作的序列，但是蒟蒻我现在还不会QwQ。]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>主席树</tag>
        <tag>线段树</tag>
        <tag>可持久化</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[XZY的女装flag(捂脸]]></title>
    <url>%2F2018%2F12%2F31%2FXZY%E7%9A%84%E5%A5%B3%E8%A3%85flag%2F</url>
    <content type="text"><![CDATA[由于一些原因，本文禁止访问，除非你能猜到密码 Incorrect Password! No content to display! U2FsdGVkX19uGoeeSQRX2/1YsIj4G7zBL4MOTGJgOW+8lktISolfdzQkf5GT94/GsoWkHhK2x84H54E98YvUlw7DzlXahiSPGMt4+xy+irFheMxog/Jp9pVBH4BOmWuKG/dqvodprP4VG8Mg+4R0PLnozZcXm0mfjVc1WRr7NypgWy0UX6gzmEKeWJyEhyeLROph6JDMSuFF4qZVt35hno3SH7Usw9PfbQxIsBV0GWPS4FrzcAbDxuuniBCBYSuKR7iV9SvdDXUu2gsaiLEC4BcQP1J6Gq48fjrc7CbNxpdpTtRaExJJ3Ciw4rZuBOl/Q1cjDrJHReaq9LmlVB8HcZ61GFIC+xNdxrS0QoQs0nQuSgkRIvNYC4bJE1OEsZCTJdswuxaLQ9KDZtGsOQ3wQXghKQmjg9My3MKvZiW/yRDp3awKzzRIKNTICCluZl4QcIkz+C5kIYRbFZ2qxw8Tf8EGiDaE4+krlFoPWlheNl4w/w4z8tmJ5U+5BrNCUFcDTEMg87VtOuMqRlc6o/s+uEK5MVBQ3E60zGPgoeEaAlaIltFBXEAgOCKS/Fm2oJkwwlySnoRpfcKqQbdlnuwho3+wFonh/inPwIUaJ71V/Ol3g56CGeoWKKmtx768gsmY23dhYmqNBlazNepwQjyrb+cVbfdeBTyK4L5tpI5RdCE0yyoudkateXGxJtg0/X8qi35D/mE56ldX3ciJOdBF312dDLtEbiH4KlHEKqmgSukXXO71uSvBgbegmap6Cyt/IAEurSEJkObviRhf8NTSlYthblXG33tW5Q9GvjiJaZrW71cjKdIt8TGzx48EWbNrIsEU4sGwdgNbeVRe8xUGc0GcDKDpR70TSzyfBjU57jsR5my0UorpMAzYxQhBLujs89NgBJ8qSKdEShgP0Pt+3E8C2BxrpHNjMtrfDYBVZkPxS3V36cBRoaUn26FF+0Wdt6lp4oiUom64JWnk2z0xF4QYd8vHhAT7gMDx9Qn0Iw5hFQ9B292dqT6nAB4TZUQGxoYEoz/t691a0jXAMlkvaRotohXNZbqL7XICxaFpik5T+6lVg6+hOmG8/eYerPG282tPTyurhLmP8FSQaTJgoYAHTW57gObT3iQw96RcXB8yapReYzOhHRlE+MZUnC21A1D2eUKZX91w4WMqUie0p/NhCT3nCz37FX6vysHzAHrCnpZFbg3AnkJqWGUH0bqfK5WkJO9/kt7JHyLC/1BFUI85pLKt9hbmtFqhzagmTXbUkBBqEJe2+3GCs2cZC/UF+eSDMeP7uxBMJBsPe2JZ3B0wTBwgmiIdvfgfdvq+T80oJzezOcv2WHc/t+BknrRy6l1KMjiIBH8WLf5i7nyx7GzZ3dV5YFhkK9KVZvL1xv6+KxM36OEHM5wyYNPNpzTtx0EQK/RtRgwWa5yJ9s0U/6JpnzYXng2cWbR9oiXb+KE9uCrT7amNBL3oX3XBqls3qhW83qN8YfOY4ff3CAugD2APSiGvOsptMM0YQ+zzipnsUWX4OZURUQcPhHnLmNPF64CwoNaeV+VYt0N+CeKr009/tJz7usDDkryul0r3JUKbJ3mzb2D5BhhGr5YQx9JC5QYcEkhuqAprJz041jv0aTioCuvfCpKahsE07b11bph6wBZRoj+6OHZYHhcQLeYTc7AHrYUFpqbbfLfGy/vU3sFmF13+FMPR4jHxpdisecmtWBREdtQQnMnEhOYB7r4aYdM5kiV9CSEqLVFCEvKFbZ6Y556RTqbgnLP/M07TLCKsaA/mgl6S9OdVkBasDxDjRFb0o52oM/ibeSC8oZhgrjJVvkrgS0SORWxIFBEdc5Arzhq592Chk9IHJDeVEaWCK5sfrq6/UJGHqh7xvBIzU3q+6e050lyLJZReR3uR77LNOQ3Zsu04oWSDA8fnxeXYEfy38PLUxCTDrENi9+5eBHsoUD6dFI5ZMM+8O3ZlaSdV/zGfE0t6NVhumR219K8NHwmDoB9PVHJIonun4BtxbaPpEy1NQPjr6Omi5UVwwqOGYM5YFeDYruN782eV+iRzoYvaIG3ZU87fQr4Rbo94QcUkzlgV2gH0Zyd2D0wu//WEWxMZHA7zfFNi/z2kLKm6nWanKj+NsYrfkAAnbBftvVvHR/QN6r5wU1xGixwPFj3erc3ck9D3wBbKqDdY7S4jc8xTlEpy+j2gWLoGgJW1gynBesRYvearC1wxueUDWa4Ub81umheEAaMtpoHCvSTjSZbqdW51Dqybrykjmo/g7c+HkVnKibalVI3dqQu9CbSb1PZIHL0PPDkvXvJA/YSysOhPlfzjQffMCSP3GeGY8MzURKVDVu2Uq8lITJr6bT65EDRRzhbaPhaNxyuYylOd702mwq6oCzzBnJE84b5Ai91YhpxRqnVYS/Cl+1JvtSWcNNxoIIAY4n4M+qsb3V8NgC6K2JsvhPTPoY9DPL2Z7pecsQuLuGWnZYzltNF64YWKXjt6Y8/WmS8NTTfKScba7bdnf3taPqvGkrnfESzc4c72Vt6zIj3uCoPUxPjrqZGgsOZ6NAU8MCIqIvx9NhD2HqneGTtLDO7N7KdG49ytICje1A2LMrDXvVHLH1qsgCMFWI/GW+naaAFpdr+C9M/cZ6V9Sq0Ub4peevl4S5aMwnuQQeBPjEXCNgEINJl5izluUTeYsBsqfyHEU0Ae4/OvUdhMTFXKDOltSDNGG9NAlJpVHBzSBpSaEm9kAg7qMl6DrHqc4vC+cinUl6+LaDq/W3koPZbIczwN9SxkFgQGXENqjXsPZmcNT1f4oBd+Domx8upG5Ik0MlWCcd78UtNAfcM3q/g+zEomouumtZ9ptf4YAv0MY+2uZXb1whn+4G4Vo9Nyksp9b5Ujf/4a2wXBf/yfZ7F5nE34wob/VKpjTjhd9Gw1ZGR/hUSQPNcbUhJQnXFacdvDi1+UvZI/m1XhYoQgjLaNP5+M8rlRYHfI8vucLacVKKF6UvKySBzUjrPxvuADQt0D335uOyqXfcgTKUNxQWm1NxLnEyGOfOa5A7YEL9IB/EQ0yGyquA6yYjtBEHaHkeNm/kTGkPTg/2lyP9tTah2PC/K3EOQSDcf7RtTtMPnaIydlIo7imRaa/TNxC8OD11i49+LzRoxwib+FRccwVgLOebrIyPAX+njsKAFQds8wsXlQ0hq49Lj2VIeY18IyTxSsBxK7/neb0HIMuTInj+Sd1oEeYiy6Snvdn5L0+zXux+Suld8XBIajqDSGmY0leNyzeq9uwOw/bGctU6VrgkyvVpYH4AQbf0SILJAhreUN0cDxLK9Z1FKywnQdzmJNIEX+Ko1zo/Do1xQ63tlOqITKiOI9Pqzeprnds8woG2hTfHiSqLxz/3Ze2eQmqJ6t6pJs4M4zd+8IRPqbRkVSDVVbRbPmjMiQKf7VIhI74cv/74gN5O32ZGWSLSnKGDvjeURrblrY2x/KNT/ONCfoRcVloMaqzn3AXfqeCq7iX5XV8BiHsVWEtF1PBU+4my50kmw41PYzBFe7UMIHilHjf8nWyZTCpATrrxlFDgF3CMFtr/xlEAz/KEC1lfMbZSznAYYHnoDM1jppTRO0G1frf5ttPfjY+6iuLkYzbqyxokYT1L5j8K7I2AaAWMVO9UaOqkOah9LOAWFNwKeZuC8+PWNrdcJM1aUW/IuzCdrgXCZ/FoD585jVyiBFXxAVoXo+tq5+bKLE+I9+xhoS2IRT1usZtpUabCu4hqvTKaSrDzzhCLGQLzLEDnJkXga7F2oKZ1eh+yAsWffTc87LCJUNP/5bNzNboN0o8uZiakPMUXr45nbR2VbSA8ycR72xWeK1o2aIHzeWkdq7v0p1eqnR/jOUl66mYIPri/JbQ9PnOuvRgQUH+gkvC/YVdDOt4ariv9lWBYjMrGNwLsSBYZwKTXWZsF4YSmHekkVpSuXx1CWZTEw2/CL8q/RpHzy97V/caTT4GErYJZH514eNCthETLcpHM/sgzf8zGH8T5iDCGcOVYewIPHWSJ1Im8rCRpwcZvZpxaMcMagNAaI8+cxS1mtwXN2nFk8YMUEZz4VZn3q3td8CTou5qpq3R756e3Gwl/nz2SgqVIbFv0DECygIHo8mg9yR2mJ4lorzBm0lsbvAr1CEaUX6WunCwIlG8NkGjmd1KJTgTL0auADGiEekCzaeztqXBi8o7X2majQ95fpUWEWG8fni0piZbiZulsSecHPeKD+HoFt4rnpTRznuA4+qTRDpGKbpSJqqFbKhpxyoWKjfKkuQdxxzjWN1UWro/eJhv1RXVhWDfCZQlTt5bJJfe/tuDQfPHywrOcSUQ54Jobf3ZQudc+eFHw0++DCNfzkEDQMAdR8hf6w8R2A7HEWfC+/ew1tHesRKwHnoOSSHruj5EDnijdZdsQNYWAwcnSAGqoqZxUWnuIzaFMQHiuE7ok9Egf/nGvrlXwU5bkpZccJMz75ywFdNuILeQRRcGz24mY9eJXqbEOpxjIe9ZmyuMmYBL6jyszdKAdftTr3qqXx26TBvUK6m0GqLId8/bq9ZnIPWy9z53RkYGedFpt6NHoo/pjmFtbr00ppj+lRUsYziinRUJDj+jKLP9xRDw0uD27SBT2JC1J6UhSoJDdCGsM4cJooE6lSHw3Sgo0LKeprWtJikBh9s7EbIWwNg9myhxtafhf/6fQFKyL75ZbMS6zF/tSibJ6fzr7a/niPtEH2nEsURjWU+1Hgl7SbnwdccdzLgQ4ARPqvAGuFd2j9C3cfksbGC9Zmi5SqvrurbRlfKvx1NTvVl+PFSaS9nMnejySv40JErJBOfn31m5PHJg1O33rXeahyZ0t/VZBzsAOBThgG0EGZT4wtkudBp1dfGl1tibEbOoV/kWeRZYCAyV2StLi+fZarrEOU4lm4CREXDeqjMIW/SUyASfwcGePilPKlk2aY9fFsHsNB51dCFjX9FGGkk6BG73bKkpVrHuUsz2vdgrFwyFP1XFGCIkAwo+oZsTTduLIjBpgCi3yLvokUoheleed1uv4DuKESjjL7HnjO/XC6xPdgqfDLSpyTtg8RnBBg+Fq4gGGk3sGDQDYfqZ2jw13TMsdvyMrlfAh8b/h2fz+N9qiWj4Mif6SWSxnCtMlgRHi8Df3ggQcCW6LJdQ69tEZoBDlTlK9zETow4MD7kpubovoRxEPLU057tJhGcVpPPDIjElCs5XkFmgkwbilU3mtcrndPqwtG+k5xSoKRL51wwZat5OVNYgWZrNn1wgcoy2DUZzJvLs2MBKIPgw28d6mb3aij3ea6CiOZ7ozMPv1EuqvbXL72p1GfY1ImBd+bUE9aTUYrZ/fDVeU+BbSlutD4FzWyueClYehN6+9Q97fYYwrzOGBx2CoM+8dKSYN+r9nFoPzkIW7jYxK4Y7JMHPOljgR0sv5SwV6wV0Im9V3uYXH5hTyFIuqek3mDaM3GNk+mOQSE8foYoMMEDmS4gWDhj5irVwLVYFvRmRhY2zUv0AdH5Qah1elx6a0C4PtS1gbWL4TbpCvhLnsfTha/6VdFXGUuZC8PI0hE4lXmSTSgoIYmdzxj7PZ5ZCGaUx8jlxRabb/XMl8oP5t1dCCV5zcEdlTK+M2nmPxjV5JlasanPAAn32eaXRyTZEonkAnc83lsi1AZ+ezIqhpHioFf98Dj7+NhKeOeKnbQA4dRAa6nFXk6VnO6fyEcJ8cuCJd7Y0E16W+5J+58ctY1tuykgJNFmulw3BQifcsxlZN+ZQ+bd46zUQVjjbmiGlYeZzLmp04OWUFBR6FpeTf4Vh7KOdyx8H4UwjtrEoDAWhDFYTwp0B/N5hqzuP7HZUvvxY35iCy4rV53KumorUUQYjYH0gG121OoTWimgdTIYhu7XltR4EfQ0ndrkjG1X3XHGZdQ3YC8nOw4wTwsOnFlOno8yRCp1cIS+1weVA/58us6OBiu7HC6NVv7jwu0PDSaqOziUhIQcnCq/BwWbKsVx7h6AsCaIiCSX2L95l2cCUP2hdKdXXDFTjJVd2v8DNKDhdmqEPVMwlo9PzTCGL6l2GjrXf7s1bP8vSF1DjrJdZSDDmfIIZ/IAYQ16As99JlwvZ16Hdbu8iYW+iVnK5DNmujK2+98rLpaYLD5Xf0dh3omu2gPkFC3rYczBvsBucd4heQmZQlTwzBFj52/pBUM8+VVVdWuUidgzqcg/fYn/HmBaVUWxWSkDiv4gN5b43IPFoC9iyC3rLLAvRxcKWFk+GroXFJyXKV7bpExqBK16nb5XrpXNsrzsCvvP6me2SOdaJBC9bFodw/lm5ayH43wHOZekGWtAVzyT5EJOGYRwlrIWYtOnvR0bZrpmyVIqPY6/ycdnfrpeMfKGGXU9rwdw8WeCV955KDzdCb3xZtwysod4/ZDKS2pkFIwwbKlbEAL48P39ze9PJJ8cOCFBCgJz/P2tGefsMaY0iRA+UuOypvH7vlngWsnP7MvkvDNOe/sNT7vu+Fvbgx7wHMuLI/d/thYtHoVVW2pa9FlL2ZqjF4V9jn82vS7GG0Se0kBCNQAEkuFtWx+JZED/aMjPH197bYc4Oa3U9tmV34fvQ0nOHnmqQ01SSeX3mbzHFAh/suDhOb/epylR1bObzP2X4A2xGCNI0gdm9Z/TiVbjnicpjJb6KeZSGLUGnsEAfejJDI8h66Vf03tKVgTU5GSGmgddrZ8yk8oi12uQFAx592KNKL6q9nOPUN80UfKNMi9Hq/f+m3w3ShVzF/R61Il0+OS7RCCUrpFphCpiRZWnKdqp1WBIzW9z7Ghvagiexoo33SJ+pg3m3dbU0ibDohW+reDdjLOLbMQdHZtYZNnMAVUSfNcN6UAQ/nnz6a2n6MR6Tytizn7CKyVZljfNJyBDiHnDFH1Fiqj/P+A+aTANEKJ0JHIVNftFyM4DZC6tJVHhYteiYiWp+t+F1UdH/J0FuZoCWXMaCl9J77MBHg81dN50t2DqaJGYS8Nu/0eFE5+I5VnQk1HKb7q5kDO14k13S+xIi+BMp1g2oJBGA59e4Sx/Dpgat075iCXUCb0aFiInzJEOHYmlApixS3z1JGlpkMhPpFTx1u1MR5odxYkI9cm0no9rp86yrwrTU8qC1DO98ipWqz3F96XiEW8WCOKn2xt1H+XFhcQkcRQ9IyLGYS7IOP3bBy/T0+rkjuGriuXKhIUb/TCFEWHGUoGdHHB0sU3vAfuexWkdqUlI8SUo1aae+FoIy3o6OuUSNdsv+/gZzueZOFu0BbGiz2z/hcdPKsjeGaILYd9lACd7r1N9oJqM6tvOtCpm1sH+cvOG77W/+5o0ZboVK/8jhjXtxI50gw3eYYbt+t3GHFpPoWEzX74e0O7SZdXluZBeRubQKwOwwBSf2/LUy+QGP2Nt/5ua6WXDqoGA3XKIZ8ei/lLcKfPdBIDW2Naqj0ujP9JksMx7IHXbX9/M/WAwA5c66x9syvRJjbZ/gRojBzZNW2ZmgEtbQaxaQ/22GhoaSlwltR6Qb3inmcx1PaN0lKgv09yX4jhhSsFqwqwJx2N8n4Rg9xXvHF9AQhMaocvAyFvv42+XH1jk3b9mBjDu9BwBda5LXzxxYmTGbxwg6wtWKyvtEjdx3hKVTYsqSldlH9d3QRj1DfbZLeDm9k8SVhhcCy7x0T+wqEmFbVGWy7DwUUTYlL2hHzFnvttrzBK5NR/D6rn9NDZVvPFMilqw2k5suwvaiG5MFLCR9kbJ0ZbE9oQUKg/F6zLB30q9CB4tYxQkwXby0ogFYFU0c5B716wZLQ4LzOSKVHTEuk0cwY4nzr8qU7J3clGEigm47pWXufS7riQO8ott3LiEiRSi/FjFknHdXOFTAUNR6ZNckGTqG7PSqH0ZPJjmnbaI52TSPde9/SBjB0kXBKi8g3jD0cglRvzhnm0OFAoWp6TCPVYnV2j1vWMjjE7aH5NNpsekdI5y99JwmM2YUivTaTHNPhe43N8L0v0pVTVrZfMp/1RghzG3DUWGBKMRwqqhAxL1H4K19zf75KYlubkUDfdpttc5uA4gV06XWcPxqyKQayl40EtNIZDwdeV5fb4yz24Yp/+o9aA86aIEm98Yvk7LTufnMcYU+oOrziZVE38Pc0bN/vtAA+RCfCTHX39qlAttLVri0C6WUg/E7DpQPlNZ7MAyO29u0aCSymlCSoe5Fg+8cftDgWUernQw9ke0xw5pQJkQ12GbEvWIJHp+8yHn]]></content>
      <categories>
        <category>公告</category>
      </categories>
      <tags>
        <tag>flag</tag>
        <tag>女装</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「国家集训队」数颜色/维护队列]]></title>
    <url>%2F2018%2F12%2F27%2F%E3%80%8C%E5%9B%BD%E5%AE%B6%E9%9B%86%E8%AE%AD%E9%98%9F%E3%80%8D%E6%95%B0%E9%A2%9C%E8%89%B2%20%E7%BB%B4%E6%8A%A4%E9%98%9F%E5%88%97%2F</url>
    <content type="text"><![CDATA[什么？维护序列的题？当然是上莫队啦poi！ 传送门洛谷传送门 BZOJ传送门 题解很显然这是一道莫队的题呢poi！ 但是有修改操作QwQ。 怎么办呢poi？ 当然是写一个资瓷修改的莫队啦！(好像都是废话) 首先我们要把所有操作分成两坨，一坨修改操作，一坨询问操作。 并且我们需要预处理出进行每一个修改操作之前这个要修改的位置上的颜色。 还要预处理出进行每一个询问操作时已近完成了几个修改操作。 然后在莫队的时候，如果当前已经进行了的修改操作的个数与当前询问操作所记录的已经进行了的修改操作数不一致，暴力更新一下就行了呢poi！ 据说这样带修改的莫队只要把块的大小设置为$n^\frac{2}{3}$就能将时间内复杂度控制在可接受的范围内呢poi。 其他的按照普通莫队写就行啦poi！ 还有洛谷上这题数据比较强，如果不按玄学方法排序要吸个氧才能AC(也有可能是蒟蒻我的常数太大了QwQ)。 代码其实还挺好写的呢poi 还有不要问我为什么那么喜欢poi呢poi 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;const int maxn=50005;int n,m,m1,m2,S,A[maxn],B[maxn],Area[maxn],ans[maxn],L,R,now,ncnt,hsh[1000005];inline int read()&#123; int ret=0,f=1;char ch=getchar(); while(ch&lt;'0'||ch&gt;'9')&#123;if(ch=='-')f=-f;ch=getchar();&#125; while(ch&gt;='0'&amp;&amp;ch&lt;='9')&#123;ret=ret*10+ch-'0';ch=getchar();&#125; return ret*f;&#125;char GetChar()&#123; char ch=getchar(); while(ch!='Q'&amp;&amp;ch!='R') ch=getchar(); return ch;&#125;struct Query&#123; int L,R,id,cnt; bool operator &lt; (const Query&amp; b)const&#123;return Area[L]&lt;Area[b.L]||(Area[L]==Area[b.L]&amp;&amp;((Area[L]&amp;1)?R&gt;b.R:R&lt;b.R));&#125;&#125;Q[maxn];struct Update&#123;int P,C,lst;&#125;U[maxn];inline void inc(int num)&#123;if(!hsh[num]++) now++;&#125;inline void dec(int num)&#123;if(!--hsh[num]) now--;&#125;int main()&#123; n=read();m=read();S=pow(n,0.666666)+1e-10; for(int i=1;i&lt;=n;i++) Area[i]=(i-1)/S+1; for(int i=1;i&lt;=n;i++) A[i]=B[i]=read(); for(int i=1;i&lt;=m;i++) &#123; if(GetChar()=='Q')&#123;Q[++m1].L=read();Q[m1].R=read();Q[m1].id=m1;Q[m1].cnt=m2;&#125; else&#123;U[++m2].P=read();U[m2].C=read();U[m2].lst=B[U[m2].P];B[U[m2].P]=U[m2].C;&#125; &#125; sort(Q+1,Q+1+m1); L=1;R=1;hsh[A[1]]++;now=1; for(int i=1;i&lt;=m1;i++) &#123; while(R&lt;Q[i].R) inc(A[++R]); while(L&gt;Q[i].L) inc(A[--L]); while(R&gt;Q[i].R) dec(A[R--]); while(L&lt;Q[i].L) dec(A[L++]); while(ncnt&gt;Q[i].cnt) &#123; A[U[ncnt].P]=U[ncnt].lst; if(L&lt;=U[ncnt].P&amp;&amp;U[ncnt].P&lt;=R)&#123;dec(U[ncnt].C);inc(U[ncnt].lst);&#125; ncnt--; &#125; while(ncnt&lt;Q[i].cnt) &#123; ncnt++; A[U[ncnt].P]=U[ncnt].C; if(L&lt;=U[ncnt].P&amp;&amp;U[ncnt].P&lt;=R)&#123;inc(U[ncnt].C);dec(U[ncnt].lst);&#125; &#125; ans[Q[i].id]=now; &#125; for(int i=1;i&lt;=m1;i++) printf("%d\n",ans[i]); return 0;&#125;]]></content>
      <categories>
        <category>莫队</category>
      </categories>
      <tags>
        <tag>分块</tag>
        <tag>莫队</tag>
        <tag>带修改莫队</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「ZJOI2013」K大数查询|整体二分]]></title>
    <url>%2F2018%2F12%2F26%2F%E3%80%8CZJOI2013%E3%80%8DK%E5%A4%A7%E6%95%B0%E6%9F%A5%E8%AF%A2%20%E6%95%B4%E4%BD%93%E4%BA%8C%E5%88%86%2F</url>
    <content type="text"><![CDATA[什么？树套树？不存在的。 传送门洛谷传送门 BZOJ传送门 在您开始阅读本题解之前，蒟蒻我建议您先把题面多看几遍，并仔细阅读样例和样例说明。 我才不会告诉你蒟蒻我就是因为看错题面然后白忙活了一个小时。 题解据说本题可以用树套树解，但是树套树这种东西常数稍微一大就TLE，这位dalao的树套树就咕掉了。而且树套树对于蒟蒻我来说太*难了，所以我们需要整体二分这种东西。 首先确保您已经掌握普通二分的写法，不会普通二分的请自行Ctrl+w。 整体二分的主要思想就是把这一大坨询问一起处理。 首先让我们来考虑只有一个询问操作的情况： 二分权值(即答案)，每次分到一个$mid$，我们就把这个询问之前所有的有贡献的添加操作(即$c$值大于$mid$的添加操作)用一个支持区间修改的树状数组或者线段树预处理，然后我们就可以很快地得到区间$[a,b]$中权值大于$mid$的数的个数$tot$。如果$tot$小于这个询问操作的$c$值，那么我们就把$c$值减去$tot$，然后把之前产生过贡献的添加操作扔掉删除，并修改二分的边界值继续二分；否则直接修改二分的边界值继续二分即可。 好了现在再来考虑有一坨询问的情况。 方便起见，我们把询问操作和添加操作一起处理。设当前二分的值是$mid$，二分的权值区间是$[L,R]$要处理的操作区间是$[s,t]$。那我们先遍历一遍操作区间，如果当前遍历到的是有贡献的添加操作，就更新一下线段树；若果是询问操作，就在线段树上查询一下该询问区间内权值大于$mid$的个数$tot$，根据$tot$是否大于$c$并把操作分成两堆，然后递归分别处理两堆，直到$L=R$时$mid$就是当前所有询问操作的答案。(添加操作也要根据$c$值是否大于$mid$也一起分成两堆) 注意将操作分堆时每一堆内不要打乱操作的顺序。 时间复杂度$\Theta(n\log^2{n})$，常数是真的小QwQ。 代码貌似真的比树套树好懂 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697#include&lt;cstdio&gt;using namespace std;typedef long long LL;const int maxn=50005;int n,m,cnt,ans[maxn];inline LL read()&#123; LL ret=0,f=1;char ch=getchar(); while(ch&lt;'0'||ch&gt;'9')&#123;if(ch=='-')f=-f;ch=getchar();&#125; while(ch&gt;='0'&amp;&amp;ch&lt;='9')&#123;ret=ret*10+ch-'0';ch=getchar();&#125; return ret*f;&#125;struct Command&#123; int typ,L,R,id;LL C;&#125;Q[maxn],Q1[maxn],Q2[maxn];struct SegmentTree //一个普普通通的线段树&#123;private: struct Node&#123;LL Sum,Tag;&#125;Tree[maxn*4]; void PushUp(int rt)&#123;Tree[rt].Sum=Tree[rt*2].Sum+Tree[rt*2+1].Sum;&#125; void PushDown(int rt,int LC,int RC) &#123; Tree[rt*2].Tag+=Tree[rt].Tag;Tree[rt*2+1].Tag+=Tree[rt].Tag; Tree[rt*2].Sum+=LC*Tree[rt].Tag;Tree[rt*2+1].Sum+=RC*Tree[rt].Tag; Tree[rt].Tag=0; &#125;public: void RangeUpdate(int LL,int RR,int delta,int L=1,int R=n,int rt=1) &#123; if(LL&lt;=L&amp;&amp;R&lt;=RR)&#123;Tree[rt].Sum+=(R-L+1)*delta;Tree[rt].Tag+=delta;return;&#125; int M=L+R&gt;&gt;1; PushDown(rt,M-L+1,R-M); if(LL&lt;=M) RangeUpdate(LL,RR,delta,L,M,rt*2); if(M&lt;RR) RangeUpdate(LL,RR,delta,M+1,R,rt*2+1); PushUp(rt); &#125; LL RangeQuery(int LL,int RR,int L=1,int R=n,int rt=1) &#123; if(LL&lt;=L&amp;&amp;R&lt;=RR) return Tree[rt].Sum; int M=L+R&gt;&gt;1;::LL ret=0; PushDown(rt,M-L+1,R-M); if(LL&lt;=M) ret+=RangeQuery(LL,RR,L,M,rt*2); if(M&lt;RR) ret+=RangeQuery(LL,RR,M+1,R,rt*2+1); return ret; &#125;&#125;S;void BinarySearch(int L,int R,int s,int t) //整体二分&#123; if(L&gt;R||s&gt;t) return; int mid=L+R&gt;&gt;1,len1=0,len2=0; if(L==R) &#123; for(int i=s;i&lt;=t;i++) if(Q[i].typ==2) //只有询问操作才需要回答 ans[Q[i].id]=mid; return; &#125; for(int i=s;i&lt;=t;i++) &#123; if(Q[i].typ==1) &#123; if(Q[i].C&gt;mid) &#123; S.RangeUpdate(Q[i].L,Q[i].R,1); Q1[++len1]=Q[i]; //操作分堆 &#125; else Q2[++len2]=Q[i]; &#125; else &#123; LL tot=S.RangeQuery(Q[i].L,Q[i].R); if(Q[i].C&lt;=tot) Q1[++len1]=Q[i]; //操作分堆 else&#123;Q2[++len2]=Q[i];Q2[len2].C-=tot;&#125; &#125; &#125; for(int i=s;i&lt;=t;i++) //撤销操作，清空线段树 if(Q[i].typ==1&amp;&amp;Q[i].C&gt;mid) S.RangeUpdate(Q[i].L,Q[i].R,-1); int j=s; for(int i=1;i&lt;=len1;i++,j++) Q[j]=Q1[i]; for(int i=1;i&lt;=len2;i++,j++) Q[j]=Q2[i]; BinarySearch(L,mid,s+len1,t);BinarySearch(mid+1,R,s,s+len1-1);&#125;int main()&#123; n=read();m=read(); for(int i=1;i&lt;=m;i++) &#123; Q[i].typ=read(); if(Q[i].typ==2) Q[i].id=++cnt; Q[i].L=read();Q[i].R=read();Q[i].C=read(); &#125; BinarySearch(-n,n,1,m); for(int i=1;i&lt;=cnt;i++) printf("%d\n",ans[i]); return 0;&#125;]]></content>
      <categories>
        <category>整体二分</category>
      </categories>
      <tags>
        <tag>整体二分</tag>
        <tag>树套树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「HNOI2010」弹飞绵羊]]></title>
    <url>%2F2018%2F12%2F24%2F%E3%80%8CHNOI2010%E3%80%8D%E5%BC%B9%E9%A3%9E%E7%BB%B5%E7%BE%8A-Solution%2F</url>
    <content type="text"><![CDATA[什么？LCT？不存在的。蒟蒻我怎么可能会LCT。 传送门洛谷传送门(咕咕咕) 爆炸BZOJ传送门 题解听说这题的标算是LCT？我这么菜！怎么可能会LCT！！！看了一眼数据范围，很亲切啊！二话不说直接上分块！ 首先，按照分块的套路，把$n$个弹力装置分成若干个块(块的大小取$\sqrt{n}$即可)。然后需要提前构造好两个数组： 1：$step[]$。$step[i]$表示落到第i个弹力装置上的绵羊还需几次才能跳到下一个块里（或者被弹飞）。 2：$pos[]$。$pos[i]$表示落到第i个弹力装置上的绵羊在被弹出当前块后会被弹到哪一个位置上。 这两个数组可以一开始从后往前在$\Theta(n*\sqrt{n})$的时间复杂度内构造出来。(我才不会告诉你我写这个是为了测试markdown的数学公式)询问的时候借助这两个数组就可以在$\Theta(\sqrt{n})$的时间复杂度内通过模拟计算出答案。 然后让我们再来考虑修改的问题。 自己思考一下，不难发现，修改了一个弹力系数之后，只有该块内的两个数组的值可能发生改变，然后从后往前暴力更新一下即可。 代码比LCT短了不少 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include&lt;cmath&gt;#include&lt;cstdio&gt;using namespace std;const int maxn=200005;int n,m,S,Area[maxn],K[maxn],step[maxn],pos[maxn];inline int read()&#123; int ret=0,f=1;char ch=getchar(); while(ch&lt;'0'||ch&gt;'9')&#123;if(ch=='-')f=-f;ch=getchar();&#125; while(ch&gt;='0'&amp;&amp;ch&lt;='9')&#123;ret=ret*10+ch-'0';ch=getchar();&#125; return ret*f;&#125;inline void Solve(int s)&#123; int p=s+K[s],ret=1; while(Area[p]==Area[s])&#123;p=p+K[p];ret++;&#125; step[s]=ret;pos[s]=p;&#125;inline void Update(int s)&#123; int p=s+K[s],ret=1; while(Area[p]==Area[s])&#123;p=p+K[p];ret++;&#125; step[s]=ret;pos[s]=p; for(int i=s-1;Area[i]==Area[s];i--) if(Area[i+K[i]]==Area[i]) &#123;step[i]=step[i+K[i]]+1;pos[i]=pos[i+K[i]];&#125;&#125;inline void Query(int s)&#123; int p=s,ret=0; while(p&lt;=n)&#123;ret+=step[p];p=pos[p];&#125; printf("%d\n",ret);&#125;int main()&#123; n=read();S=sqrt(n)+1e-10; for(int i=1;i&lt;=n;i++) Area[i]=(i-1)/S+1; for(int i=1;i&lt;=n;i++) K[i]=read(); for(int i=n;i&gt;=1;i--) Solve(i); m=read(); while(m--) &#123; int a=read(),b=read()+1; if(a==1) Query(b); else&#123;int c=read();K[b]=c;Update(b);&#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>分块</category>
      </categories>
      <tags>
        <tag>分块</tag>
        <tag>LCT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[公告]]></title>
    <url>%2F2018%2F12%2F22%2F%E5%85%AC%E5%91%8A%2F</url>
    <content type="text"><![CDATA[什么？女装发blog？不存在的… 欢迎访问蒟蒻我的blog. 蒟蒻我万年不更新的Blog终于在网站开通后n个星期准备开始更新了。。。 蒟蒻我和巨佬XXC女装的事，想必各位dalao都知道了。 关于女装，可说来话长了。是这么一回事： NOIP2018 day2考完出场，ZJ初三小蒟蒻我感觉两腿绵软无力，很显然我这只蒟蒻是考boom了。day2 T1我傻逼样得想用一种奇妙的方法来解决这棵基环外向树，然后写了两个小时还没有结果，CCF给的大样例也过不了。出了考场和各位大佬一起交流了一下才发现暴力枚举删掉的边然后重构图即可。因为T1没做出来，T2的45分结论分也没拿到。自己估摸了一下，不该丢的分一共丢了85分，预估不翻车的情况下分数为应该379，省一GG… 事后，蒟蒻我写了一首诗来表达自己内心的想法(我有一句mmp不知当不当讲)： 于是乎，我便当众立了一个flag：我CCF评出来400分以上就那啥！ 然鹅等到CCF出成绩的那天，由于CCF的数据非常友好，我总分399(CCF万岁) 但是成绩出来之后，跟各位dalao一讨论，参考了一下CCF的文件，发现蒟蒻我省一仍然没有太大希望qwq。 于是乎，我又当众立了一个flag：我省一就那啥！ 12.04，CCF发布获奖名单，我惊奇地发现CCF修改了省一获奖名额的分配方案。CCF万岁万岁万万岁。蒟蒻我先是高兴了一会儿，然后想起了之前立的flag… 我&amp;^%￥#T@(文明你我他) 然后就没有然后了… 为了不让Matsusaki这位dalao破费，我决定等XXC巨佬女装后把衣服借来用用。 听说我已近被安排上了？好像就在81022018年12月30/31号？ XXC巨佬的blog(据说这里会放上他她的女装图)]]></content>
      <categories>
        <category>公告</category>
      </categories>
      <tags>
        <tag>女装</tag>
        <tag>公告</tag>
      </tags>
  </entry>
</search>
